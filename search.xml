<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo使用</title>
    <url>/2022/07/10/Hexo%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="Hexo-官网-https-hexo-io-zh-cn"><a href="#Hexo-官网-https-hexo-io-zh-cn" class="headerlink" title="Hexo 官网 https://hexo.io/zh-cn/"></a>Hexo 官网 <a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></h4><h5 id="安装相关工具"><a href="#安装相关工具" class="headerlink" title="安装相关工具"></a>安装相关工具</h5><ul>
<li><p>安装Node.js</p>
</li>
<li><p>安装Git</p>
</li>
<li><p>安装Hexo脚手架</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="github上建项目"><a href="#github上建项目" class="headerlink" title="github上建项目"></a>github上建项目</h4><ul>
<li><p>登录后点击“+”号，选择New repository，下一步</p>
</li>
<li><p>在Repository name下面填写你要创建的地址，这个地址是就是你的域名，以github.io结尾。**例如填写hlqhlq.github.io以后就在地址栏直接输入wapchief.github.io就可以访问网站</p>
</li>
<li><p>按照提示一步步完成创建。</p>
</li>
<li><p>创建之后，点击setting设置远程库：</p>
</li>
<li><p>找到GitHub Pages点击Automatic page generator</p>
</li>
<li><p>等待github pages创建完成，然后输入你创建的地址测试github pager是否创建成功。此时页面是空的没有任何东西。</p>
<p><img src="/2022/07/10/Hexo%E4%BD%BF%E7%94%A8/52dcbd638f8efd76e8470d25a3f57c05.png"></p>
</li>
</ul>
<p>使用hexo模板将源码放到github</p>
<h4 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h4><ul>
<li><p>创建一个文件夹用于存放hexo</p>
</li>
<li><p>安装hexo</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化hexo基础配置文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化hexo</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<ul>
<li>生成网站静态文件到默认设置的 public 文件夹</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<ul>
<li>启动本地服务器，用于预览主题。默认地址： <a href="http://localhost:4000/">http://localhost:4000/</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h4 id="安装ayer主题"><a href="#安装ayer主题" class="headerlink" title="安装ayer主题"></a>安装ayer主题</h4><p><strong>方法一：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i hexo-theme-ayer -S</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是新安装本主题，安装完成后会在根目录生成一个<code>_config.ayer.yml</code>文件，直接编辑<code>_config.ayer.yml</code>文件进行配置即可。</li>
<li>如果是主题升级，建议先把配置内容做备份，然后用<code>npm uninstall hexo-theme-ayer -S</code>先卸载主题，再<code>npm i hexo-theme-ayer -S</code>重新安装。</li>
</ul>
<p><strong>方法二（hexo &lt; 5.0）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 国内用户如果速度较慢，可以把github地址替换为：https://gitee.com/mirrors/ayer.git</span><br><span class="line">git clone https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer</span><br></pre></td></tr></table></figure>

<h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>将博客根目录下的 <code>_config.yml</code> 里的 <code>theme</code> 值修改成 <code>ayer</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: ayer</span><br></pre></td></tr></table></figure>

<h4 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h4><p> npm 安装本主题，那么在根目录执行以下命令就可更新。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COPYnpm update hexo-theme-ayer -S</span><br></pre></td></tr></table></figure>

<h4 id="写作博客"><a href="#写作博客" class="headerlink" title="写作博客"></a>写作博客</h4><ul>
<li><p>创建一篇新文章或者新的页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>分类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>然后将以下复制到 /source/categories/index.md 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加属性</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;	</span><br></pre></td></tr></table></figure></li>
<li><p>标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>然后将以下复制到 /source/tags/index.md 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加属性</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;	</span><br></pre></td></tr></table></figure></li>
<li><p>​    设置文章分类和标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: Hexo使用</span><br><span class="line">date: 2022-07-10 18:32:13</span><br><span class="line">#分类</span><br><span class="line">categories:</span><br><span class="line">- Hexo</span><br><span class="line">- Hexo #二级分类</span><br><span class="line">#标签</span><br><span class="line">tags:</span><br><span class="line">- Hexo</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><ul>
<li><p>安装部署插件 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li>
<li><p>修改站点配置文件，打开站点下的<code>_config,yml</code>文件，添加<code>deploy</code>信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: https://github.com/username/username.github.io</span><br><span class="line">    branch: master					</span><br></pre></td></tr></table></figure></li>
<li><p>部署命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean    //清理缓存</span><br><span class="line">hexo g      //生成静态文件</span><br><span class="line">hexo d      //部署网站到创建的仓库</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ IDEA常用快捷键</title>
    <url>/2022/07/15/IntelliJ-IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">双击Shift：查找所有</span><br><span class="line">Ctrl+Shift+R：全局搜索</span><br><span class="line">ALT+INSERT: 生成代码(如GET,SET方法,构造函数等)</span><br><span class="line">Ctrl + Shift + v: 自动补全对象返回类型</span><br><span class="line">Ctrl+I: 实现方法</span><br><span class="line">Ctrl+O: 重写方法    </span><br><span class="line">Ctrl + Alt + B：跳转到实现方法  </span><br><span class="line">Ctrl + G: 跳至指定行、列</span><br><span class="line">Ctrl + Shift + U：大小写转换</span><br><span class="line">    </span><br><span class="line">Alt + Enter：显示建议操作</span><br><span class="line">Ctrl + Alt + L：格式化代码</span><br><span class="line">Ctrl + P：参数信息提醒</span><br><span class="line">Alt + <span class="number">7</span>：显示结构窗口</span><br><span class="line">Ctrl + Alt + l: 自动对齐代码    </span><br><span class="line">Ctrl + Tab：切换活动文件</span><br><span class="line">Ctrl + E：最近的文件</span><br><span class="line">Ctrl + Shift + Backspace：返回上次编辑位置    </span><br><span class="line">Ctrl + Alt + Left：后退</span><br><span class="line">Ctrl + Alt + Right：前进</span><br><span class="line">    </span><br><span class="line">Ctrl + /：添加行注释</span><br><span class="line">Ctrl + Shift + /：添加块注释</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Java定时器</title>
    <url>/2022/07/19/Java%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<h4 id="Java定时器任务"><a href="#Java定时器任务" class="headerlink" title="Java定时器任务"></a>Java定时器任务</h4><h5 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a><strong>Timer</strong></h5><p><strong>JDK 自带的定时任务执行类</strong>，无论任何项目都可以直接使用 Timer 来实现定时任务，所以 Timer 的优点就是使用方便</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTimerTask</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义一个任务</span></span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">timerTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Run timerTask：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 计时器</span></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="comment">// 添加执行任务（延迟 1s 执行，每 3s 执行一次）</span></span><br><span class="line">        timer.schedule(timerTask, <span class="number">1000</span>, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点分析</p>
<p><strong>①任务执行时间长影响其他任务</strong></p>
<p>当一个任务的执行时间过长时，会影响其他任务的调度，如下代码所示：</p>
<p>当任务 1 运行时间超过设定的间隔时间时，任务 2 也会延迟执行。 原本任务 1 和任务 2 的执行时间间隔都是 3s，但因为任务 1 执行了 5s，因此任务 2 的执行时间间隔也变成了 10s（和原定时间不符）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTimerTask</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义任务 1</span></span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">timerTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;进入 timerTask 1：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 休眠 5 秒</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Run timerTask 1：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 定义任务 2</span></span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">timerTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Run timerTask 2：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 计时器</span></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="comment">// 添加执行任务（延迟 1s 执行，每 3s 执行一次）</span></span><br><span class="line">        timer.schedule(timerTask, <span class="number">1000</span>, <span class="number">3000</span>);</span><br><span class="line">        timer.schedule(timerTask2, <span class="number">1000</span>, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">进入 timerTask <span class="number">1</span>：Mon Aug <span class="number">17</span> <span class="number">21</span>:<span class="number">44</span>:08 CST <span class="number">2020</span></span><br><span class="line">Run timerTask <span class="number">1</span>：Mon Aug <span class="number">17</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">13</span> CST <span class="number">2020</span>  Run timerTask <span class="number">2</span>：Mon Aug <span class="number">17</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">13</span> CST <span class="number">2020</span></span><br><span class="line">进入 timerTask <span class="number">1</span>：Mon Aug <span class="number">17</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">13</span> CST <span class="number">2020</span></span><br><span class="line">Run timerTask <span class="number">1</span>：Mon Aug <span class="number">17</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">18</span> CST <span class="number">2020</span></span><br><span class="line">进入 timerTask <span class="number">1</span>：Mon Aug <span class="number">17</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">18</span> CST <span class="number">2020</span></span><br><span class="line">Run timerTask <span class="number">1</span>：Mon Aug <span class="number">17</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">23</span> CST <span class="number">2020</span>  Run timerTask <span class="number">2</span>：Mon Aug <span class="number">17</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">23</span> CST <span class="number">2020</span></span><br><span class="line">进入 timerTask <span class="number">1</span>：Mon Aug <span class="number">17</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">23</span> CST <span class="number">2020</span></span><br></pre></td></tr></table></figure>

<p><strong>②任务异常影响其他任务</strong></p>
<p>使用 Timer 类实现定时任务时，当一个任务抛出异常，其他任务也会终止运行，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTimerTask</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义任务 1</span></span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">timerTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;进入 timerTask 1：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                <span class="comment">// 模拟异常</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">8</span> / <span class="number">0</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;Run timerTask 1：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 定义任务 2</span></span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">timerTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Run timerTask 2：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 计时器</span></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="comment">// 添加执行任务（延迟 1s 执行，每 3s 执行一次）</span></span><br><span class="line">        timer.schedule(timerTask, <span class="number">1000</span>, <span class="number">3000</span>);</span><br><span class="line">        timer.schedule(timerTask2, <span class="number">1000</span>, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Timer 小结</p>
<p><strong>Timer 类实现定时任务的优点是方便，因为它是 JDK 自定的定时任务，但缺点是任务如果执行时间太长或者是任务执行异常，会影响其他任务调度</strong>，所以在生产环境下建议谨慎使用</p>
<h5 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a><strong>ScheduledExecutorService</strong></h5><p><strong>ScheduledExecutorService 也是 JDK 1.5 自带的 API</strong>，我们可以使用它来实现定时任务的功能，也就是说 ScheduledExecutorService <strong>可以实现 Timer 类具备的所有功能，并且它可以解决了 Timer 类存在的所有问题。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyScheduledExecutorService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建任务队列</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span></span><br><span class="line">                Executors.newScheduledThreadPool(<span class="number">10</span>); <span class="comment">// 10 为线程数量</span></span><br><span class="line">  		<span class="comment">// 执行任务</span></span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Run Schedule：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS); <span class="comment">// 1s 后开始执行，每 3s 执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ScheduledExecutorService 小结</p>
<p><strong>在单机生产环境下建议使用 ScheduledExecutorService 来执行定时任务</strong>，它是 JDK 1.5 之后自带的 API，因此使用起来也比较方便，并且使用 ScheduledExecutorService 来执行任务，不会造成任务间的相互影响。</p>
<h5 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring Task"></a><strong>Spring Task</strong></h5><p>如果使用的是 <strong>Spring 或 Spring Boot 框架</strong>，可以直接使用 Spring Framework 自带的定时任务，使用上面两种定时任务的实现方式，很难实现设定了<strong>具体时间的定时任务</strong>，比如当我们需要每周五来执行某项任务时，但如果使用 Spring Task 就可轻松的实现此需求。</p>
<p>以 Spring Boot 为例，实现定时任务只需两步：</p>
<ul>
<li>开启定时任务</li>
<li>添加定时任务</li>
</ul>
<p>① 开启定时任务</p>
<p>开启定时任务只需要在 Spring Boot 的启动类上声明 <strong>@EnableScheduling</strong> 即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 开启定时任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">    <span class="comment">// do someing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② 添加定时任务</p>
<p>定时任务的添加只需要使用 <strong>@Scheduled 注解标注</strong>即可，如果有多个定时任务可以创建多个 @Scheduled 注解标注的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 把此类托管给 Spring，不能省略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskUtils</span> &#123;</span><br><span class="line">    <span class="comment">// 添加定时任务</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;59 59 23 0 0 5&quot;)</span> <span class="comment">// cron 表达式，每周五 23:59:59 执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTask</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是定时任务~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Task 的实现需要使用 cron 表达式来声明执行的频率和规则</p>
<p><img src="/2022/07/19/Java%E5%AE%9A%E6%97%B6%E5%99%A8/42E5476AD7944654AD48B290D4FE0629.jpg"></p>
<ul>
<li><p>缺点：<strong>jvm启动之后会记录系统时间，然后jvm根据CPU ticks自己来算时间</strong>，此时<strong>获取的是定时任务的基准时间</strong>。如果此时将<strong>系统时间进行了修改</strong>，当Spring将之前获取的基准时间与当下获取的系统时间进行比对时，就会造成<strong>Spring内部定时任务失效</strong>。因为此时系统时间发生变化了，不会触发定时任务。</p>
</li>
<li><p>方案：为了避免使用@Scheduled注解，在修改服务器时间导致定时任务不执行情况的发生。在项目中需要使用定时任务场景的情况下，使<strong>ScheduledThreadPoolExecutor进行替代</strong>，它任务的调度是<strong>基于相对时间的</strong>，原因是它在任务的内部 存储了该任务距离下次调度还需要的时间（使用的是基于 System.nanoTime实现的相对时间 ，不会因为系统时间改变而改变，如距离下次执行还有10秒，不会因为将系统时间调前6秒而变成4秒后执行）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
        <category>定时器</category>
      </categories>
      <tags>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA线上故障排查全套解决方案</title>
    <url>/2022/10/10/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%85%A8%E5%A5%97%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h4 id="JAVA线上故障排查全套解决方案"><a href="#JAVA线上故障排查全套解决方案" class="headerlink" title="JAVA线上故障排查全套解决方案"></a>JAVA线上故障排查全套解决方案</h4><p>线上故障主要会包括<strong>cpu、磁盘、内存以及网络</strong>问题，而大多数故障可能会包含不止一个层面的问题，所以进行排查时候尽量四个方面依次排查一遍。同时例如<strong>jstack、jmap</strong>等工具也是不囿于一个方面的问题的，基本上出问题就是<strong>df、free、top</strong> 三连，然后依次jstack、jmap伺候，具体问题具体分析即可</p>
<h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a><strong>CPU</strong></h4><p>一般来讲我们首先会排查cpu方面的问题。cpu异常往往还是比较好定位的。原因包括<strong>业务逻辑问题(死循环)、频繁gc以及上下文切换过多</strong>。而最常见的往往是业务逻辑(或者框架逻辑)导致的，可以使用jstack来分析对应的堆栈情况</p>
<p><strong>使用jstack分析cpu问题</strong></p>
<p>ps命令找到对应进程的pid(如果你有好几个目标进程，可以先用top看一下哪个占用比较高)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、对应进程的pid</span><br><span class="line">ps -ef | grep 进程关键字</span><br><span class="line">2、找到cpu使用率比较高的一些线程</span><br><span class="line">top -H -p pid</span><br><span class="line">3、将占用最高的pid转换为16进制printf &#x27;%x\n&#x27; pid得到nid</span><br><span class="line">printf &#x27;%x\n&#x27; pid</span><br><span class="line">4、直接在jstack中找到相应的堆栈信息</span><br><span class="line">jstack pid |grep &#x27;nid&#x27; -C5 –color</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/10/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%85%A8%E5%A5%97%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230319185335954.png" alt="image-20230319185335954"></p>
<p>可以看到我们已经找到了nid为0x42的堆栈信息，接着只要仔细分析一番即可。</p>
<p>当然更常见的是我们对整个jstack文件进行分析，通常我们会比较关注WAITING和TIMED_WAITING的部分，BLOCKED就不用说了。我们可以使用命令cat jstack.log | grep “java.lang.Thread.State” | sort -nr | uniq -c来对jstack的状态有一个整体的把握，如果WAITING之类的特别多，那么多半是有问题啦。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat jstack.log | grep &quot;java.lang.Thread.State&quot; | sort -nr | uniq -c</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/10/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%85%A8%E5%A5%97%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230319185422418.png" alt="image-20230319185422418"></p>
<h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a><strong>磁盘</strong></h4><p>1.利用 df 查询磁盘状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>

<p>2.获取目录下文件夹大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du -sh *</span><br></pre></td></tr></table></figure>

<p>3.磁盘问题还是性能上的问题。我们可以通过iostat -d -k -x来进行分析</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、iostat属于sysstat软件包</span><br><span class="line">yum install sysstat</span><br><span class="line">2、iostat -d -k -x 1</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/10/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%85%A8%E5%A5%97%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230319185649578.png" alt="image-20230319185649578"></p>
<p>%util可以看到每块磁盘写入的程度</p>
<p>rrqpm/s以及wrqm/s分别表示读写速度，一般就能帮助定位到具体哪块磁盘出现问题</p>
<p>4.需要知道是哪个进程在进行读写，用iotop命令来进行定位文件读写的来源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iotop</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/10/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%85%A8%E5%A5%97%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230319185746056.png" alt="image-20230319185746056"></p>
<p>5.不过这边拿到的是tid，我们要转换成pid，可以通过readlink来找到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readlink -f /proc/*/task/tid/../..</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/10/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%85%A8%E5%A5%97%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230319185902218.png" alt="image-20230319185902218"></p>
<p>6.找到pid之后就可以看这个进程具体的读写情况cat /proc/pid/io</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/pid/io</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/10/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%85%A8%E5%A5%97%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230319185953457.png" alt="image-20230319185953457"></p>
<p>7.lsof命令来确定具体的文件读写情况lsof -p pid</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof -p pid</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/10/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%85%A8%E5%A5%97%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230319190034159.png" alt="image-20230319190034159"></p>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a><strong>内存</strong></h4><p>主要包括OOM、GC问题和堆外内存。一般来讲，我们会先用free命令先来检查一发内存的各种情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">free</span><br><span class="line">free -g</span><br><span class="line">free -m</span><br></pre></td></tr></table></figure>

<h4 id="堆内内存"><a href="#堆内内存" class="headerlink" title="堆内内存"></a>堆内内存</h4><p>内存问题大多还都是堆内内存问题。表象上主要分为OOM和StackOverflow</p>
<p>OOM</p>
<p>JMV中的内存不足，OOM大致可以分为以下几种：</p>
<p><strong>Exception in thread “main” java.lang.OutOfMemoryError: unable to create new native thread</strong></p>
<p>这个意思是<strong>没有足够的内存空间给线程分配java栈，基本上还是线程池代码写的有问题</strong>，比如说忘记shutdown，所以说应该首先从代码层面来寻找问题，<strong>使用jstack或者jmap</strong>。如果一切都正常，JVM方面可以通过指定<strong>Xss来减少单个thread stack的大小</strong>。另外也可以在系统层面，可以通过修改/etc/security/limits.conf  nofile和nproc来增大os对线程的限制</p>
<p><img src="/2022/10/10/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%85%A8%E5%A5%97%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230319190209877.png" alt="image-20230319190209877"></p>
<p><strong>Exception in thread “main” java.lang.OutOfMemoryError: Java heap space</strong></p>
<p>这个意思是堆的内存占用已经达到-Xmx设置的最大值，应该是最常见的OOM错误了。解决思路仍然是先应该在代码中找，<strong>怀疑存在内存泄漏</strong>，<strong>通过jstack和jmap去定位问题</strong>。如果说一切都正常，才需要通过<strong>调整Xmx的值来扩大内存</strong>。</p>
<p><strong>Caused by: java.lang.OutOfMemoryError: Meta space</strong></p>
<p>这个意思是<strong>元数据区的内存占用已经达到XX:MaxMetaspaceSize设置的最大值</strong>，排查思路和上面的一致，参数方面可以通过<strong>XX:MaxPermSize来进行调整</strong>(这里就不说1.8以前的永久代了)</p>
<p><strong>Stack Overflow</strong></p>
<p><strong>栈内存溢出</strong>，这个大家见到也比较多。</p>
<p><strong>Exception in thread “main” java.lang.StackOverflowError</strong></p>
<p>表示线程栈需要的内存大于<strong>Xss值</strong>，同样也是先进行排查，参数方面通过Xss来调整，但调整的太大可能又会引起OOM</p>
<h4 id="使用JMAP定位代码内存泄漏"><a href="#使用JMAP定位代码内存泄漏" class="headerlink" title="使用JMAP定位代码内存泄漏"></a>使用<strong>JMAP</strong>定位代码内存泄漏</h4><p>上述关于OOM和StackOverflow的代码排查方面，我们一般使用JMAP</p>
<p> jmap -dump:format=b,file=filename pid来导出dump文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap -dump:format=b,file=filename pid</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/10/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%85%A8%E5%A5%97%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230319190407933.png" alt="image-20230319190407933"></p>
<p><strong>mat(Eclipse Memory Analysis Tools)导入dump文件进行分析</strong>，内存泄漏问题一般我们直接选Leak Suspects即可，mat给出了内存泄漏的建议。另外也可以选择Top Consumers来查看最大对象报告。和线程相关的问题可以选择thread overview进行分析。除此之外就是选择Histogram类概览来自己慢慢分析，大家可以搜搜mat的相关教程。（idea插件篇之java内存分析工具(<strong>JProfiler</strong>)）</p>
<p><img src="/2022/10/10/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%85%A8%E5%A5%97%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230319190439697.png" alt="image-20230319190439697"></p>
<p>日常开发中，代码产生内存泄漏是比较常见的事，并且比较隐蔽，需要开发者更加关注细节。比如说每次请求都new对象，导致大量重复创建对象；进行文件流操作但未正确关闭；手动不当触发gc；ByteBuffer缓存分配不合理等都会造成代码OOM。</p>
<p>另一方面，我们可以在<strong>启动参数中指定-XX:+HeapDumpOnOutOfMemoryError来保存OOM时的dump文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内存OOM时，自动生成dump文件</span> </span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=/data/logs/</span><br></pre></td></tr></table></figure>

<p>GC问题</p>
<p>通过GC日志来排查问题的，在启动参数中加上**-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps**来开启GC日志。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-verbose:gc -XX:+PrintGCDetails </span><br><span class="line">-XX:+PrintGCDateStamps </span><br><span class="line">-XX:+PrintGCTimeStamps</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>线上故障</category>
      </categories>
      <tags>
        <tag>线上故障</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾回收机制</title>
    <url>/2022/07/25/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>在java中，程序员是<strong>不需要显示的去释放一个对象的内存的</strong>，而是<strong>由虚拟机自行执行</strong>。在JVM中，<br>有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有<strong>在虚拟机空闲或者当前</strong><br><strong>堆内存不足时，才会触发执行</strong>，<strong>扫面那些没有被任何引用的对象</strong>，并将它们添加到要回收的集合<br>中，进行回收<br>程序员可以**手动执行System.gc()**，通知GC运行，但是Java语言规范并不保证GC一定会执行</p>
<h4 id="怎么判断对象是否可以被回收"><a href="#怎么判断对象是否可以被回收" class="headerlink" title="怎么判断对象是否可以被回收"></a>怎么判断对象是否可以被回收</h4><h5 id="引用计数器法"><a href="#引用计数器法" class="headerlink" title="引用计数器法"></a>引用计数器法</h5><p>为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数-1，当计数器为 0 时就可以被回收。它有一个<strong>缺点不能解决循环引用</strong>的问题。</p>
<p>循环引用的问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;-- 背景 --&gt;</span><br><span class="line"><span class="comment">// 对象objA 和 objB 都有字段 name</span></span><br><span class="line"><span class="comment">// 两个对象相互进行引用，除此之外这两个人对象没有任何引用</span></span><br><span class="line">objA.name = objB；</span><br><span class="line">objB.name = objA；</span><br><span class="line"></span><br><span class="line">&lt;-- 问题 --&gt;</span><br><span class="line"><span class="comment">// 实际上这两个对象已经不可能再被访问，应该要被垃圾收集器进行回收</span></span><br><span class="line"><span class="comment">// 但因为他们相互引用，所以导致计数器不为0，这导致引用计数算法无法通知垃圾收集器回收该两个对象</span></span><br></pre></td></tr></table></figure>

<h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a><strong>可达性分析算法</strong></h5><p>从 <strong>GC Roots 开始向下搜索，搜索所走过的路径称为引用链</strong>。<strong>当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的</strong>。（市场上用的非常非常广泛）</p>
<p>上面例子中两个循环引用的对象，虽然都存在一个强引用，但是不被任何GC root对象直接或者间接引用到</p>
<h4 id="什么是GC-Root对象"><a href="#什么是GC-Root对象" class="headerlink" title="什么是GC Root对象"></a><strong>什么是GC Root对象</strong></h4><h5 id="虚拟机栈中引用的对象"><a href="#虚拟机栈中引用的对象" class="headerlink" title="虚拟机栈中引用的对象"></a><strong>虚拟机栈中引用的对象</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rumenz</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	     <span class="type">Rumenz</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rumenz</span>();</span><br><span class="line">	     a = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">a是栈帧中的本地变量,a就是GC Root,</span><br><span class="line">由于a=<span class="literal">null</span>,a与<span class="keyword">new</span> <span class="title class_">Rumenz</span>()对象断开了链接,所以对象会被回收</span><br></pre></td></tr></table></figure>

<h5 id="方法区类的静态成员引用的对象"><a href="#方法区类的静态成员引用的对象" class="headerlink" title="方法区类的静态成员引用的对象"></a><strong>方法区类的静态成员引用的对象</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rumenz</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Rumenz=r;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       Rumenz a=<span class="keyword">new</span> <span class="title class_">Rumenz</span>();</span><br><span class="line">       a.r=<span class="keyword">new</span> <span class="title class_">Rumenz</span>();</span><br><span class="line">       a=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">栈帧中的本地变量a=<span class="literal">null</span>,由于a断开了与GC Root对象(a对象)的联系,所以a对象会被回收。</span><br><span class="line">由于给Rumenz的成员变量r赋值了变量的引用,</span><br><span class="line">并且r成员变量是静态的,所以r就是一个GC Root对象,所以r指向的对象不会被回收。</span><br></pre></td></tr></table></figure>

<h5 id="方法区常量引用的对象"><a href="#方法区常量引用的对象" class="headerlink" title="方法区常量引用的对象"></a><strong>方法区常量引用的对象</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rumenz</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Rumenz=r;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       Rumenz a=<span class="keyword">new</span> <span class="title class_">Rumenz</span>();</span><br><span class="line">       a.r=<span class="keyword">new</span> <span class="title class_">Rumenz</span>();</span><br><span class="line">       a=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">栈帧中的本地变量a=<span class="literal">null</span>,由于a断开了与GC Root对象(a对象)的联系,所以a对象会被回收。</span><br><span class="line">由于给Rumenz的成员变量r赋值了变量的引用,</span><br><span class="line">并且r成员变量是静态的,所以r就是一个GC Root对象,所以r指向的对象不会被回收。</span><br></pre></td></tr></table></figure>

<h5 id="方法区常量引用的对象-1"><a href="#方法区常量引用的对象-1" class="headerlink" title="方法区常量引用的对象"></a><strong>方法区常量引用的对象</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rumenz</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Rumenz r=<span class="keyword">new</span> <span class="title class_">Rumenz</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       Rumenz a=<span class="keyword">new</span> <span class="title class_">Rumenz</span>();</span><br><span class="line">       a=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">常量r引用的对象不会因为a引用的对象的回收而被回收</span><br></pre></td></tr></table></figure>

<h4 id="JVM-中都有哪些引用类型？"><a href="#JVM-中都有哪些引用类型？" class="headerlink" title="JVM 中都有哪些引用类型？"></a>JVM 中都有哪些引用类型？</h4><ul>
<li><strong>强引用</strong>：发生 gc 的时候不会被回收。比如new创建对象，反射获得一个对象等</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>软引用</strong>：有用但不是必须的对象，在发生内存溢出之前会被回收。</li>
</ul>
<p> 通过SoftReference引用对象时，这个引用就是软引用。<strong>使用场景： 适用于网页缓存、图片缓存</strong>，防止内存溢出，在内存充足的时候，缓存对象会一直存在，在内存不足的时候，缓存对象占用的内存会被垃圾收集器回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>弱引用</strong>：有用但不是必须的对象，在下一次GC时会被回收。通过WeakReference引用对象，这种引用方式为弱引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;WeakReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>虚引用</strong>（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，必须和引用队列一起使用，虚引用的用途是在 gc 时返回一个通知</li>
</ul>
<p>使用PlantomReference引用对象时，这种引用方式就是虚引用,一般用来跟踪垃圾回收过程。使用虚引用的目的就是为了得知对象被GC的时机，所以可以利用虚引用来进行销毁前的一些操作，比如说资源释放等</p>
<h4 id="JVM-垃圾回收算法有哪些？"><a href="#JVM-垃圾回收算法有哪些？" class="headerlink" title="JVM 垃圾回收算法有哪些？"></a>JVM 垃圾回收算法有哪些？</h4><ul>
<li><strong>标记-清除</strong>算法：<strong>标记无用对象，然后进行清除回收</strong>。缺点：效率不高，无法清除垃圾碎片。</li>
<li><strong>复制</strong>算法：按照容量划分<strong>二个大小相等的内存区域</strong>，当一块用完的时候将<strong>活着的对象复制到另一块上</strong>，然后再把<strong>已使用的内存空间一次清理掉</strong>。缺点：内存使用率不高，只有原来的一半。</li>
<li><strong>标记-整理</strong>算法<strong>：标记无用对象</strong>，让所有<strong>存活的对象都向一端移动</strong>，然后直接<strong>清除掉端边界以外的内存</strong>。需要进行局部对象移动，一定程度上降低了效率</li>
<li><strong>分代算法</strong>：根据<strong>对象存活周期</strong>的不同将内存划分为几块，一般是<strong>新生代和老年代</strong>，新生代基本采用<strong>复制</strong>算法，老年代采用<strong>标记整理</strong>算法。</li>
</ul>
<h4 id="JVM-有哪些垃圾回收器"><a href="#JVM-有哪些垃圾回收器" class="headerlink" title="JVM 有哪些垃圾回收器"></a>JVM 有哪些垃圾回收器</h4><p><img src="/2022/07/25/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/19A0DA8B897D45D48C9F002444AC33AF.jpg"></p>
<ul>
<li><strong>Parallel Scavenge收集器</strong> (复制算法): 新生代并行收集器，<strong>追求高吞吐量</strong>，高效利用 CPU。<strong>吞吐量</strong></li>
</ul>
<p><strong>= 用户线程时间/(用户线程时间+GC线程时间)</strong></p>
<ul>
<li><strong>CMS</strong>(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收</li>
</ul>
<p>停顿时间为目标的收集器，具有高并发、低停顿的特点，<strong>追求最短GC回收停顿时间</strong></p>
<h4 id="分代垃圾回收器是怎么工作的？"><a href="#分代垃圾回收器是怎么工作的？" class="headerlink" title="分代垃圾回收器是怎么工作的？"></a>分代垃圾回收器是怎么工作的？</h4><ul>
<li>分代回收器有两个分区：老生代和新生代，<strong>新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</strong>参数 <strong>–XX:NewRatio</strong> 来指定</li>
<li>新生代使用的是<strong>复制算法</strong>，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 <strong>8:1:1</strong>，参数 <strong>-XX:SurvivorRatio</strong> 来指定，它的执行流程如下： </li>
<li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li>
<li>清空 Eden 和 From Survivor 分区；</li>
<li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变From Survivor。</li>
<li>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，<strong>当年龄到达 15（默认配置是 15，</strong>-XX:MaxTenuringThreshold<strong>）时，升级为老生代</strong>。大对象也会直接进入老生代。</li>
<li><strong>老生代当空间占用到达某个值之后就会触发全局垃圾收回</strong>，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</li>
</ul>
<h4 id="新生代、老年代、永久代的区别"><a href="#新生代、老年代、永久代的区别" class="headerlink" title="新生代、老年代、永久代的区别"></a>新生代、老年代、永久代的区别</h4><p><img src="/2022/07/25/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/C7DFF5C6F06648809B579D49754CAB08.jpg"></p>
<p>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。而新生代 ( Young )又被划分为三个区域：<strong>Eden、From Survivor、To Survivor</strong>。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。</p>
<p><strong>新生代</strong>中一般保存新出现的对象，所以<strong>每次垃圾收集时都发现大批对象死去</strong>，只有少量对象存活，便采用了 <strong>复制算法</strong> ，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p><strong>老年代</strong>中一般保存存活了很久的对象，他们<strong>存活率高</strong>、没有额外空间对它进行分配担保，就必须采用 <strong>“标记-清理”或者“标记-整理” 算法</strong>。</p>
<p><strong>永久代就是JVM的方法区</strong>。在这里都是放着一些<strong>被虚拟机加载的类信息，静态变量，常量</strong>等数据。这个区中的东西比老年代和新生代更不容易回收</p>
<h4 id="为什么新生代要分Eden和两个-Survivor-区域？"><a href="#为什么新生代要分Eden和两个-Survivor-区域？" class="headerlink" title="为什么新生代要分Eden和两个 Survivor 区域？"></a>为什么新生代要分Eden和两个 Survivor 区域？</h4><p><strong>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代</strong>。<strong>老年代很快被填满</strong>，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。</p>
<p>Survivor的存在意义，就是<strong>减少被送到老年代的对象</strong>，<strong>进而减少Full GC的发生</strong>，Survivor的预筛选保证，只有经历<strong>15次Minor GC还能在新生代中存活的对象，才会被送到老年代</strong>。</p>
<p><strong>设置两个Survivor区最大的好处就是解决了碎片化</strong>，<strong>刚刚新建的对象在Eden中，经历一次MinorGC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1</strong>（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象<strong>占用连续的内存空间</strong>，<strong>避免了碎片化的发生</strong>）</p>
<h4 id="Minor-GC、Major-GC、Full-GC区别及触发条件"><a href="#Minor-GC、Major-GC、Full-GC区别及触发条件" class="headerlink" title="Minor GC、Major GC、Full GC区别及触发条件"></a>Minor GC、Major GC、Full GC区别及触发条件</h4><h5 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h5><p>新生代GC，指的是<strong>发生在新生代的垃圾收集动作</strong>。由于java对象大都是朝生夕死的， 所以<strong>Minor GC非常频繁，一般回收速度也比较快</strong>。（一般采用<strong>复制算法回收垃圾</strong>） </p>
<p>Minor GC 触发条件一般为： </p>
<ol>
<li><strong>eden区满时，触发MinorGC</strong>。即申请一个对象时，发现eden区不够用，则触发一次 MinorGC。 </li>
<li>新创建的对象大小 &gt; Eden所剩空间时</li>
</ol>
<h5 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h5><p>老年代GC，指的是发生在<strong>老年代的GC</strong>，通常执行Major GC会连着Minor GC一起执 行。Major GC的速度要比Minor GC慢的多。（可采用<strong>标记清楚法和标记整理法</strong>）</p>
<h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>清理整个堆空间，包括年轻代和老年代</p>
<p>触发Minor GC Major GC和Full GC 触发条件一般为：<br><strong>Major GC通常是跟full GC是等价的</strong> </p>
<ol>
<li>每次<strong>晋升到老年代的对象平均大小&gt;老年代剩余空间</strong></li>
<li><strong>MinorGC后存活的对象超过了老年代剩余空间</strong></li>
<li>永久代空间不足 </li>
<li>执行<strong>System.gc()</strong> </li>
<li>CMS GC异常</li>
<li><strong>堆内存分配很大的对象</strong>（指需要大量连续内存空间的java对象）</li>
</ol>
<h4 id="常用的-JVM-调优的参数"><a href="#常用的-JVM-调优的参数" class="headerlink" title="常用的 JVM 调优的参数"></a><strong>常用的 JVM 调优的参数</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms：初始堆大小，JVM 启动的时候，给定堆空间大小。</span><br><span class="line"></span><br><span class="line">-Xmx：最大堆大小，JVM 运行过程中，如果初始堆空间不足的时候，最大可以扩展到多少。</span><br><span class="line"></span><br><span class="line">-Xmn：设置堆中年轻代大小**。整个堆大小=年轻代大小+年老代大小+持久代大小。</span><br><span class="line"></span><br><span class="line">-XX:NewSize=n 设置年轻代初始化大小大小</span><br><span class="line"></span><br><span class="line">-XX:MaxNewSize=n 设置年轻代最大值</span><br><span class="line"></span><br><span class="line">-XX:NewRatio=n 设置年轻代和年老代的比值</span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio=n 年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。<span class="number">8</span></span><br><span class="line"></span><br><span class="line">表示两个Survivor :eden=<span class="number">2</span>:<span class="number">8</span> ,即一个Survivor占年轻代的<span class="number">1</span>/<span class="number">10</span>，默认就为<span class="number">8</span></span><br><span class="line"></span><br><span class="line">-Xss：设置每个线程的堆栈大小。JDK5后每个线程 Java 栈大小为 1M，以前每个线程堆栈大小为 256K。</span><br><span class="line"></span><br><span class="line">-XX:ThreadStackSize=n 线程堆栈大小</span><br><span class="line"></span><br><span class="line">-XX:PermSize=n 设置持久代初始值</span><br><span class="line"></span><br><span class="line">-XX:MaxPermSize=n 设置持久代大小</span><br><span class="line"></span><br><span class="line">-XX:MaxTenuringThreshold=n 设置年轻带垃圾对象最大年龄</span><br></pre></td></tr></table></figure>



<h4 id="JVM的GC收集器设置"><a href="#JVM的GC收集器设置" class="headerlink" title="JVM的GC收集器设置"></a>JVM的GC收集器设置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-xx:+Use xxx GC     xxx 代表垃圾收集器名称</span><br><span class="line"></span><br><span class="line">-XX:ParallelGCThreads=<span class="number">8</span>：表示JVM在进行并行GC的时候，用于GC的线程数。</span><br><span class="line"></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError：可以让JVM在出现内存溢出时候Dump出当前的内存转储快照</span><br><span class="line"></span><br><span class="line">-XX:HeapDumpPath：生成DUMP文件的路径，如不设置，默认存储在jvm 运行环境目录</span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDetails：打印GC详细信息</span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDateStamps：记录GC日志并不会特别地影响Java程序性能，推荐你尽可能记录日志</span><br><span class="line"></span><br><span class="line">-Xloggc：指定GC log的位置，以文件输出。帮助开发人员分析问题</span><br><span class="line"></span><br><span class="line">-XX:+DisableExplicitGC：这个将会忽略手动调用 GC 的代码使得 System.gc() 的调用就会变成一个空调用，完全不会触发任何 GC</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL日志的作用</title>
    <url>/2023/09/08/MySQL%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h1 id="MySQL-日志：undo-log、redo-log、binlog-有什么用？"><a href="#MySQL-日志：undo-log、redo-log、binlog-有什么用？" class="headerlink" title="MySQL 日志：undo log、redo log、binlog 有什么用？"></a>MySQL 日志：undo log、redo log、binlog 有什么用？</h1><p><strong>执行一条 update 语句，期间发生了什么？</strong>，比如这一条 update 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t_user <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;xiaolin&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>查询语句的那一套流程，更新语句也是同样会走一遍：</p>
<ul>
<li>客户端先通过连接器建立连接，连接器自会判断用户身份；</li>
<li>因为这是一条 update 语句，所以不需要经过查询缓存，但是表上有更新语句，是会把整个表的查询缓存清空的，所以说查询缓存很鸡肋，在 MySQL 8.0 就被移除这个功能了；</li>
<li>解析器会通过词法分析识别出关键字 update，表名等等，构建出语法树，接着还会做语法分析，判断输入的语句是否符合 MySQL 语法；</li>
<li>预处理器会判断表和字段是否存在；</li>
<li>优化器确定执行计划，因为 where 条件中的 id 是主键索引，所以决定要使用 id 这个索引；</li>
<li>执行器负责具体执行，找到这一行，然后更新。</li>
</ul>
<p>不过，更新语句的流程会涉及到 undo log（回滚日志）、redo log（重做日志） 、binlog （归档日志）这三种日志：</p>
<ul>
<li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li>
<li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li>
<li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>日志</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM运行时数据区</title>
    <url>/2022/07/25/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>VM(Java Virtual Machine/Java 虚拟机)在执行 Java 程序的过程中会把它所管理的<strong>内存划分为若干个不同的数据区域</strong>。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机<a href="https://www.jianshu.com/p/94b7c2ab84ac">进程</a>的启动而一直存在，有的区域则是依赖用户线程的启动和结束而建立和销毁</p>
<p><img src="/2022/07/25/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/CA1BB924A33442FC9CFC3BC482E62ABB.jpg"></p>
<h4 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a><strong>运行时数据区</strong></h4><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h5><p>保存当前线程所正在执行的字节码指令的地址(行号)<strong>，为了</strong>线程切换后能恢复到正确的执行位置**，每条线程都有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储</p>
<p><strong>为什么要线程计数器？因为线程是不具备记忆功能</strong></p>
<h5 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a><strong>虚拟机栈</strong></h5><p><strong>线程私有</strong>的，它的<strong>生命周期和线程相同</strong></p>
<p>虚拟机栈描述的是Java方法执行的内存模型： 每个方法在执行的同时 都会创建一个<strong>栈帧</strong>（StackFrame）用于<strong>存储局部变量表、操作数栈、动态链接、方法出口</strong>等信息。</p>
<p>虚拟机栈中是有单位的，单位就是栈帧，<strong>一个方法一个栈帧</strong>。一个栈帧中他又要存储，局部变量，操作数栈，动态链接，出口等。</p>
<p><img src="/2022/07/25/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/0F361B626063436CA773F219E67AC2AC.jpg"></p>
<p>解析栈帧：</p>
<ul>
<li> <strong>局部变量表</strong>：是用来<strong>存储我们临时8个基本数据类型、对象引用地址、returnAddress类型</strong>。</li>
</ul>
<p>  （returnAddress中保存的是return后要执行的字节码的指令地址。）</p>
<ul>
<li> <strong>操作数栈</strong>：操作数栈就是用来操作的，例如代码中有个 i = 6*6，他在一开始的时候就会进行操</li>
</ul>
<p>  作，读取我们的代码，<strong>进行计算后再放入局部变量表</strong>中去</p>
<ul>
<li><p><strong>动态链接</strong>：假如我方法中，有个 service.add()方法，要链接到别的方法中去，这就是动态链接，</p>
<p>存储链接的地方。</p>
</li>
<li><p><strong>出口</strong>：出口是什呢，出口正常的话就是return 不正常的话就是抛出异常落</p>
</li>
</ul>
<h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a><strong>堆</strong></h5><p>被<strong>所有线程共享的一块内存区</strong>，<strong>存放对象实例</strong>，所有的对象实例以及数组都要在堆上分配</p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><strong>本地方法栈</strong></h5><p>栈很像，只不过方法上带了 <strong>native 关键字的栈字</strong>，且native关键字修饰的大部分源码都是C和C++的代码</p>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><strong>方法区</strong></h5><p>所有<strong>线程共享的内存区域</strong>，它用于存储已<strong>被Java虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据，别命叫Non-Heap（非堆）</p>
<h4 id="JVM运行流程"><a href="#JVM运行流程" class="headerlink" title="JVM运行流程"></a>JVM运行流程</h4><p><img src="/2022/07/25/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/D3E84FA2772A4286B75ED4870D0CFB1D.jpg"></p>
<p>JVM包含两个子系统和两个组件: 两个子系统为Class loader(类装载)、Execution engine(执行引擎)； 两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。</p>
<ul>
<li><p>Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。</p>
</li>
<li><p>Execution engine（执行引擎）：执行classes中的指令。</p>
</li>
<li><p>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</p>
</li>
<li><p>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</p>
</li>
</ul>
<p>流程 ：首先通过<strong>编译器把 Java 代码转换成字节码</strong>，<strong>类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内</strong>，而<strong>字节码文件</strong>只是 JVM 的一套指令集规范，<strong>并不能直接交给底层操作系统去执行</strong>，因此<strong>需要特定的命令解析器执行引擎</strong>（Execution Engine），<strong>将字节码翻译成底层系统指令，</strong>再交由 CPU 去执行，而这个过程中需要<strong>调用其他语言的本地库接口</strong>（Native Interface）来实现整个程序的功能。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Read view 在MVCC里如何工作的</title>
    <url>/2024/03/17/Read-view-%E5%9C%A8MVCC%E9%87%8C%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
    <content><![CDATA[<h2 id="Read-View-在-MVCC-里如何工作的？"><a href="#Read-View-在-MVCC-里如何工作的？" class="headerlink" title="Read View 在 MVCC 里如何工作的？"></a>Read View 在 MVCC 里如何工作的？</h2><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 **Read View **来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。**「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View**。</p>
<p>我们需要了解两个知识：</p>
<ul>
<li>Read View 中四个字段作用；</li>
<li>聚簇索引记录中两个跟事务有关的隐藏列；</li>
</ul>
<p>那 Read View 到底是个什么东西？</p>
<p><img src="/2024/03/17/Read-view-%E5%9C%A8MVCC%E9%87%8C%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/readview%E7%BB%93%E6%9E%84.drawio.png" alt="img"></p>
<p>Read View 有四个重要的字段：</p>
<ul>
<li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li>
<li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li>
<li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li>
<li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li>
</ul>
<p>知道了 Read View 的字段，我们还需要了解聚簇索引记录中的两个隐藏列。</p>
<p>假设在账户余额表插入一条小林余额为 100 万的记录，然后我把这两个隐藏列也画出来，该记录的整个示意图如下：</p>
<p><img src="/2024/03/17/Read-view-%E5%9C%A8MVCC%E9%87%8C%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/f595d13450878acd04affa82731f76c5.png" alt="图片"></p>
<p>对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：</p>
<ul>
<li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li>
<li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li>
</ul>
<p>在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：</p>
<p><img src="/2024/03/17/Read-view-%E5%9C%A8MVCC%E9%87%8C%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/ReadView.drawio.png" alt="img"></p>
<p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p>
<ul>
<li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</li>
<li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</li>
<li>如果记录的 trx_id 值在 Read View 的min_trx_id和max_trx_id之间，需要判断 trx_id 是否在 m_ids 列表中：<ul>
<li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li>
<li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li>
</ul>
</li>
</ul>
<p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</strong></p>
<p>MVCC是在<strong>并发访问数据库</strong>时，通过<strong>对数据做多版本管理</strong>，<strong>避免因为写锁的阻塞而造成读数据的并发阻塞问题</strong>。</p>
<p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。InnoDB中，MVCC是通过Undo Log + Read View进行数据读取，Undo Log保存了历史快照，而Read View规则帮我们判断当前版本的数据是否可见</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事务是在 MySQL 引擎层实现的，我们常见的 InnoDB 引擎是支持事务的，事务的四大特性是原子性、一致性、隔离性、持久性，我们这次主要讲的是隔离性。</p>
<p>当多个事务并发执行的时候，会引发脏读、不可重复读、幻读这些问题，那为了避免这些问题，SQL 提出了四种隔离级别，分别是读未提交、读已提交、可重复读、串行化，从左往右隔离级别顺序递增，隔离级别越高，意味着性能越差，InnoDB 引擎的默认隔离级别是可重复读。</p>
<p>要解决脏读现象，就要将隔离级别升级到读已提交以上的隔离级别，要解决不可重复读现象，就要将隔离级别升级到可重复读以上的隔离级别。</p>
<p>而对于幻读现象，不建议将隔离级别升级为串行化，因为这会导致数据库并发时性能很差。MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇<a href="https://xiaolincoding.com/mysql/transaction/phantom.html">文章 (opens new window)</a>），解决的方案有两种：</p>
<ul>
<li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li>
<li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li>
</ul>
<p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：</p>
<ul>
<li>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</li>
<li>「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。</li>
</ul>
<p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</p>
<p>在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MVCC</category>
      </categories>
      <tags>
        <tag>MVCC</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 线程模型</title>
    <url>/2023/01/15/Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h2><h3 id="Redis-是单线程吗？"><a href="#Redis-是单线程吗？" class="headerlink" title="#Redis 是单线程吗？"></a><a href="https://www.xiaolincoding.com/redis/base/redis_interview.html#redis-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%90%97">#</a>Redis 是单线程吗？</h3><p><strong>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</strong>，这也是我们常说 Redis 是单线程的原因。</p>
<p>但是，<strong>Redis 程序并不是单线程的</strong>，Redis 在启动的时候，是会<strong>启动后台线程</strong>（BIO）的：</p>
<ul>
<li><strong>Redis 在 2.6 版本</strong>，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；</li>
<li><strong>Redis 在 4.0 版本之后</strong>，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 lazyfree 线程。例如执行 unlink key / flushdb async / flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 unlink 命令来异步删除大key。</li>
</ul>
<p>之所以 Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。</p>
<p>后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。</p>
<p><img src="/2023/01/15/Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B.jpg" alt="img"></p>
<p>关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列：</p>
<ul>
<li>BIO_CLOSE_FILE，关闭文件任务队列：当队列有任务后，后台线程会调用 close(fd) ，将文件关闭；</li>
<li>BIO_AOF_FSYNC，AOF刷盘任务队列：当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 fsync(fd)，将 AOF 文件刷盘，</li>
<li>BIO_LAZY_FREE，lazy free 任务队列：当队列有任务后，后台线程会 free(obj) 释放对象 / free(dict) 删除数据库所有对象 / free(skiplist) 释放跳表对象；</li>
</ul>
<h3 id="Redis-单线程模式是怎样的？"><a href="#Redis-单线程模式是怎样的？" class="headerlink" title="Redis 单线程模式是怎样的？"></a>Redis 单线程模式是怎样的？</h3><p>Redis 6.0 版本之前的单线模式如下图：</p>
<p><img src="/2023/01/15/Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.drawio.png" alt="img"></p>
<p>图中的蓝色部分是一个事件循环，是由主线程负责的，可以看到网络 I/O 和命令处理都是单线程。 Redis 初始化的时候，会做下面这几件事情：</p>
<ul>
<li>首先，调用 epoll_create() 创建一个 epoll 对象和调用 socket() 创建一个服务端 socket</li>
<li>然后，调用 bind() 绑定端口和调用 listen() 监听该 socket；</li>
<li>然后，将调用 epoll_ctl() 将 listen socket 加入到 epoll，同时注册「连接事件」处理函数。</li>
</ul>
<p>初始化完后，主线程就进入到一个<strong>事件循环函数</strong>，主要会做以下事情：</p>
<ul>
<li><p>首先，先调用<strong>处理发送队列函数</strong>，看是发送队列里是否有任务，如果有发送任务，则通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</p>
</li>
<li><p>接着，调用 epoll_wait 函数等待事件的到来：</p>
<ul>
<li><p>如果是<strong>连接事件</strong>到来，则会调用<strong>连接事件处理函数</strong>，该函数会做这些事情：调用 accpet 获取已连接的 socket -&gt; 调用 epoll_ctl 将已连接的 socket 加入到 epoll -&gt; 注册「读事件」处理函数；</p>
</li>
<li><p>如果是<strong>读事件</strong>到来，则会调用<strong>读事件处理函数</strong>，该函数会做这些事情：调用 read 获取客户端发送的数据 -&gt; 解析命令 -&gt; 处理命令 -&gt; 将客户端对象添加到发送队列 -&gt; 将执行结果写到发送缓存区等待发送；</p>
</li>
<li><p>如果是<strong>写事件</strong>到来，则会调用<strong>写事件处理函数</strong>，该函数会做这些事情：通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会继续注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</p>
</li>
</ul>
</li>
</ul>
<p>（另外版本：</p>
<p>redis 内部使⽤<strong>⽂件事件处理器</strong> file event handler ，这个<strong>⽂件事件处理器是单线程的</strong>，所 以 redis 才叫做单线程的模型。它<strong>采⽤ IO 多路复⽤机制同时监听多个 socket</strong>，<strong>将产⽣事件的 socket 压⼊内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进⾏处 理</strong>。</p>
<p><img src="/2023/01/15/Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20240512180058421.png" alt="image-20240512180058421">)</p>
<h3 id="Redis-采用单线程为什么还这么快？"><a href="#Redis-采用单线程为什么还这么快？" class="headerlink" title="Redis 采用单线程为什么还这么快？"></a>Redis 采用单线程为什么还这么快？</h3><p>官方使用基准测试的结果是，<strong>单线程的 Redis 吞吐量可以达到 10W/每秒</strong></p>
<p>之所以 Redis 采用单线程（网络 I/O 和执行命令）那么快，有如下几个原因：</p>
<ul>
<li>Redis 的大部分操作<strong>都在内存中完成</strong>，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；</li>
<li>Redis 采用单线程模型可以<strong>避免了多线程之间的竞争</strong>，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</li>
<li>Redis 采用了 <strong>I/O 多路复用机制</strong>处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</li>
</ul>
<h3 id="Redis-6-0-之前为什么使用单线程？"><a href="#Redis-6-0-之前为什么使用单线程？" class="headerlink" title="Redis 6.0 之前为什么使用单线程？"></a>Redis 6.0 之前为什么使用单线程？</h3><p>我们都知道单线程的程序是无法利用服务器的多核 CPU 的，那么早期 Redis 版本的主要工作（网络 I/O 和执行命令）为什么还要使用单线程呢？我们不妨先看一下Redis官方给出的<a href="https://link.juejin.cn/?target=https://redis.io/topics/faq">FAQ</a></p>
<p><img src="/2023/01/15/Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/redis%E5%AE%98%E6%96%B9%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%9B%9E%E7%AD%94.png" alt="img"></p>
<p>核心意思是：<strong>CPU 并不是制约 Redis 性能表现的瓶颈所在</strong>，更多情况下是受到内存大小和网络I/O的限制，所以 Redis 核心网络模型使用单线程并没有什么问题，如果你想要使用服务的多核CPU，可以在一台服务器上启动多个节点或者采用分片集群的方式。</p>
<p>除了上面的官方回答，选择单线程的原因也有下面的考虑。</p>
<p>使用了单线程后，可维护性高，多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，<strong>增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗</strong>。</p>
<h3 id="Redis-6-0-之后为什么引入了多线程？"><a href="#Redis-6-0-之后为什么引入了多线程？" class="headerlink" title="#Redis 6.0 之后为什么引入了多线程？"></a><a href="https://www.xiaolincoding.com/redis/base/redis_interview.html#redis-6-0-%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B">#</a>Redis 6.0 之后为什么引入了多线程？</h3><p>虽然 Redis 的主要工作（网络 I/O 和执行命令）一直是单线程模型，但是<strong>在 Redis 6.0 版本之后，也采用了多个 I/O 线程来处理网络请求</strong>，<strong>这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上</strong>。</p>
<p>所以为了提高网络 I/O 的并行度，Redis 6.0 对于网络 I/O 采用多线程来处理。**但是对于命令的执行，Redis 仍然使用单线程来处理，*<em>所以大家*<em>不要误解</em></em> Redis 有多线程同时执行命令。</p>
<p>Redis 官方表示，<strong>Redis 6.0 版本引入的多线程 I/O 特性对性能提升至少是一倍以上</strong>。</p>
<p>Redis 6.0 版本支持的 I/O 多线程特性，默认情况下 I/O 多线程只针对发送响应数据（write client socket），并不会以多线程的方式处理读请求（read client socket）。要想开启多线程处理客户端读请求，就需要把 Redis.conf 配置文件中的 io-threads-do-reads 配置项设为 yes。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读请求也使用io多线程</span></span><br><span class="line">io-threads-<span class="keyword">do</span>-reads yes </span><br></pre></td></tr></table></figure>

<p>同时， Redis.conf 配置文件中提供了 IO 多线程个数的配置项。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io-threads N，表示启用 N-1 个 I/O 多线程（主线程也算一个 I/O 线程）</span></span><br><span class="line">io-threads <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>关于线程数的设置，官方的建议是如果为 4 核的 CPU，建议线程数设置为 2 或 3，如果为 8 核 CPU 建议线程数设置为 6，线程数一定要小于机器核数，线程数并不是越大越好。</p>
<p>因此， Redis 6.0 版本之后，Redis 在启动的时候，默认情况下会<strong>额外创建 6 个线程</strong>（<em>这里的线程数不包括主线程</em>）：</p>
<ul>
<li>Redis-server ： Redis的主线程，主要负责执行命令；</li>
<li>bio_close_file、bio_aof_fsync、bio_lazy_free：三个后台线程，分别异步处理关闭文件任务、AOF刷盘任务、释放内存任务；</li>
<li>io_thd_1、io_thd_2、io_thd_3：三个 I/O 线程，io-threads 默认是 4 ，所以会启动 3（4-1）个 I/O 多线程，用来分担 Redis 网络 I/O 的压力。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/UDP协议</title>
    <url>/2022/07/27/TCP-UDP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h4 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h4><ul>
<li><p><strong>TCP是面向连接的协议</strong>，发送数据前要先建立连接，<strong>TCP提供可靠的服务</strong>，也就是说，通过TCP连接<strong>传输的数据不会丢失</strong>，没有重复，并且按顺序到达；</p>
</li>
<li><p><strong>UDP是无连接的协议</strong>，发送数据前<strong>不需要建立连接</strong>，是<strong>没有可靠性</strong>；</p>
</li>
<li><p><strong>UDP传输速度快，TCP相对慢一些</strong></p>
</li>
<li><p>TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；</p>
</li>
<li><p>UDP通信类似于学校广播，靠着广播播报直接进行通信。</p>
</li>
<li><p>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</p>
</li>
<li><p><strong>TCP是面向字节流的</strong>，<strong>UDP是面向报文的</strong>； <strong>面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送</strong>，而<strong>UDP一个报文只能一次发完</strong>。</p>
</li>
<li><p>TCP首部开销（20字节）比UDP首部开销（8字节）要大</p>
</li>
<li><p>UDP 的主机不需要维持复杂的连接状态表</p>
</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>UDP应用场景：某些<strong>实时性要求比较高</strong>的情况，比如<strong>游戏，媒体通信，实时直播</strong>，即使出现传输错误 也可以容忍</p>
<p>TCP应用场景: <strong>HTTP</strong>都是用TCP，因为要求<strong>传输的内容可靠，不出现丢失</strong>的情况</p>
<p><strong>TCP协议</strong>：http(超文本传输协议)、https、FTP(文件传输协议)、POP3(邮局协议,收邮件)、SMTP(简单邮件传输协议,发邮件)</p>
<p><strong>UDP协议</strong>：DHCP(动态主机配置协议,动态主机配置协议)、NTP(网络时间协议,用于网络同步)</p>
<h4 id="用现实理解三次握手的具体细节"><a href="#用现实理解三次握手的具体细节" class="headerlink" title="用现实理解三次握手的具体细节"></a><strong>用现实理解三次握手的具体细节</strong></h4><p>三次握手的目的是建立可靠的通信信道，主要的目的就是<strong>双方确认自己与对方的发送与接收机能正常</strong></p>
<p><img src="/2022/07/27/TCP-UDP%E5%8D%8F%E8%AE%AE/B263ECD21A60439BA729B9B3311B7B27.jpg"></p>
<ul>
<li>第一次握手：客户什么都不能确认；服务器确认了对方发送正常</li>
<li>第二次握手：客户确认了：自己发送、接收正常，对方发送、接收正常；服务器确认 了：自己接收正常，对方发送正常</li>
<li>第三次握手：客户确认了：自己发送、接收正常，对方发送、接收正常；服务器确认 了：自己发送、接收正常，对方发送接收正常 所以三次握手就能确认双发收发功能都正常，缺一不可</li>
</ul>
<h5 id="建立连接可以两次握手吗？为什么"><a href="#建立连接可以两次握手吗？为什么" class="headerlink" title="建立连接可以两次握手吗？为什么?"></a><strong>建立连接可以两次握手吗？为什么?</strong></h5><p>因为可能会出现<strong>已失效的连接请求</strong>报文段又传到了服务器端</p>
<p>server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。<strong>假设不采用 “三次握手</strong>”，那么<strong>只要 server 发出确认，新的连接就建立了</strong>。由于现在 <strong>client 并没有发出建立连接的请求，因此不会理睬 server 的确认</strong>，也不会向 server 发送数据。但 <strong>server 却以为新的运输连接已经建立，并一直等待 client 发来数据</strong>。这样，server 的很多<strong>资源就白白浪费</strong>掉了</p>
<p>采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，<strong>client 不会向 server 的确认发出确认server 由于收不到确认，就知道 client 并没有要求建立连接</strong></p>
<h4 id="什么是TCP的四次挥手"><a href="#什么是TCP的四次挥手" class="headerlink" title="什么是TCP的四次挥手?"></a><strong>什么是TCP的四次挥手?</strong></h4><p>在网络数据传输中，传输层协议断开连接的过程我们称为四次挥手</p>
<p><img src="/2022/07/27/TCP-UDP%E5%8D%8F%E8%AE%AE/9E02A1D33F3D4A09AF4C04B25FD91F33.jpg"></p>
<p>TCP的四次挥手</p>
<p><strong>四次挥手断开连接</strong>是因为<strong>要确定数据全部传输完</strong>了</p>
<ul>
<li>客户与服务器交谈结束之后，客户要结束此次会话，就会对服务器说：我要关闭连接了（第一 次挥手）</li>
<li>服务器收到客户的消息后说：好的，你要关闭连接了。（第二次挥手）</li>
<li> 然后服务器确定了没有话要和客户说了，服务器就会对客户说，我要关闭连接了。(第三次挥 手)</li>
<li>客户收到服务器要结束连接的消息后说：已收到你要关闭连接的消息。(第四次挥手)，才关闭</li>
</ul>
<h5 id="CLOSE-WAIT状态意义是什么"><a href="#CLOSE-WAIT状态意义是什么" class="headerlink" title="CLOSE_WAIT状态意义是什么"></a><strong>CLOSE_WAIT状态意义是什么</strong></h5><p>为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（<strong>CLOSE_WAIT状态意义是什么</strong>）？</p>
<p>因为<strong>服务器收到客户端断开连接的请求时，可能还有一些数据没有发完</strong>，这时先回复ACK，表示接</p>
<p>收到了断开连接的请求。<strong>等到数据发完之后再发FIN</strong>，断开服务器到客户端的数据传送</p>
<h5 id="客户端TIME-WAIT状态的意义是什么？"><a href="#客户端TIME-WAIT状态的意义是什么？" class="headerlink" title="客户端TIME_WAIT状态的意义是什么？"></a><strong>客户端TIME_WAIT状态的意义是什么</strong>？</h5><p><strong>第四次挥手时，客户端发送给服务器的ACK有可能丢失</strong>，<strong>TIME_WAIT状态就是用来重发可能丢失的ACK报文</strong>。如</p>
<p>果Server没有收到ACK，就会<strong>重发FIN</strong>，如果<strong>Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待</strong></p>
<p><strong>2MSL</strong>，<strong>防止Server没有收到ACK而不断重发FIN</strong>。 MSL(MaximumSegment Lifetime)，指一个片段在网络中最</p>
<p>大的存活时间，<strong>2MSL就是一个发送和一个回复所需的最大时间</strong>。<strong>如果直到2MSL，Client都没有再次收到FIN，那</strong></p>
<p><strong>么Client推断ACK已经被成功接收，则结束TCP连接。</strong></p>
<h4 id="从输入址到获得页面的过程"><a href="#从输入址到获得页面的过程" class="headerlink" title="从输入址到获得页面的过程"></a><strong>从输入址到获得页面的过程</strong></h4><ul>
<li><p>浏览器查询 DNS，获取域名对应的IP地址</p>
</li>
<li><p>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求</p>
</li>
<li><p>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器</p>
</li>
<li><p>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源</p>
</li>
<li><p>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面</p>
</li>
</ul>
<h4 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a><strong>Http协议</strong></h4><p><strong>Http协议</strong>是对客户端和服务器端之间数据之间实现<strong>可靠性的传输文字、图片、音频、视频</strong>等超文本数据的规范，格式简称为“<strong>超文本传输协议</strong>”</p>
<h5 id="http和https的区别？"><a href="#http和https的区别？" class="headerlink" title="http和https的区别？"></a>http和https的区别？</h5><p>其实HTTPS就是从HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护</p>
<ul>
<li><strong>端口不一样，http是80，https443</strong></li>
<li>http是超文本传输协议，信息是<strong>明文传输</strong>，https则是具有安全性的<strong>ssl加密传输协议</strong>。</li>
</ul>
<h5 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h5><p><img src="/2022/07/27/TCP-UDP%E5%8D%8F%E8%AE%AE/A5310E2F789945829BB4F8552F135745.jpg"></p>
<h5 id="GET方法与POST方法的区别"><a href="#GET方法与POST方法的区别" class="headerlink" title="GET方法与POST方法的区别"></a>GET方法与POST方法的区别</h5><ul>
<li><p>get重点在从服务器上<strong>获取资源</strong>，post重点在向服务器<strong>发送数据</strong></p>
</li>
<li><p><strong>Get传输的数据量小</strong>，因为<strong>受URL长度限制</strong>，但效率较高； <strong>Post可以传输大量数据</strong>，所以上传文件时只能用Post方式</p>
</li>
<li><p><strong>get是不安全</strong>的，因为get请求<strong>发送数据是在URL上，是可见的</strong>，可能会泄露私密信息，如密码等； <strong>post是放在请求头部的，是安全的</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>TCP/UDP</category>
      </categories>
      <tags>
        <tag>TCP/UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC Controller并发安全问题</title>
    <url>/2022/07/21/SpringMVC-Controller%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h4><p>根据Tomcat官网中的介绍，<strong>对于一个浏览器请求，tomcat会指定一个处理线程</strong>，或是在线程池中选取空闲的，或者新建一个线程。</p>
<p>在Tomcat容器中，每个servlet是单例的。<strong>在SpringMVC中，Controller 默认也是单例</strong>。 采用单例模式的最大好处，就是可以<strong>在高并发场景下极大地节省内存资源，提高服务抗压能力</strong>。</p>
<p>单例模式容易出现的问题是：在Controller中定义的<strong>实例变量</strong>，在多个请求并发时会出现竞争访问，<strong>Controller中的实例变量不是线程安全的</strong>。</p>
<h4 id="Controller不是线程安全的"><a href="#Controller不是线程安全的" class="headerlink" title="Controller不是线程安全的"></a><strong>Controller不是线程安全的</strong></h4><p>正因为Controller默认是单例，所以不是线程安全的。如果用SpringMVC 的 Controller时，尽量不在 Controller中使用实例变量，否则会出现线程不安全性的情况，导致数据逻辑混乱。</p>
<p>举一个简单的例子，在一个Controller中定义一个非静态成员变量 num 。通过Controller成员方法来对 num 增加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/addNum&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(++num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">首先访问 http:<span class="comment">// localhost:8080 / addNum，得到的答案是1</span></span><br><span class="line">再次访问 http:<span class="comment">// localhost:8080 / addNum，得到的答案是 2。</span></span><br><span class="line">两次访问得到的结果不同，num已经被修改，并不是我们希望的结果，接口的幂等性被破坏。</span><br></pre></td></tr></table></figure>

<p>所有的请求访问同一个Controller实例，<strong>Controller的私有成员变量就是线程共用的</strong>。某个请求对应的线程如果修改了这个变量，那么在别的请求中也可以读到这个变量修改后的的值。</p>
<h4 id="Controller并发安全的解决办法"><a href="#Controller并发安全的解决办法" class="headerlink" title="Controller并发安全的解决办法"></a><strong>Controller并发安全的解决办法</strong></h4><ul>
<li><p>尽量不要在 Controller 中定义成员变量 ；</p>
</li>
<li><p>如果必须要定义一个非静态成员变量，那么可以通过注解 @Scope(“prototype”) ，将Controller设置为多例模式，容器在接受到该类型对象的请求时，每次都会重新生成一个新的对象给请求方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Scope(value=&quot;prototype&quot;)</span><span class="comment">// 多例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/addNum&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(++num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Controller 中使用 ThreadLocal 变量。 每一个线程都有一个变量的副本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal &lt;Integer&gt; uniqueNum =</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">ThreadLocal</span> &lt;Integer&gt; () &#123;</span><br><span class="line">                 <span class="meta">@Override</span> <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">                     <span class="keyword">return</span> num;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/addNum&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">unum</span> <span class="operator">=</span> uniqueNum.get();</span><br><span class="line">       uniqueNum.set(++unum);</span><br><span class="line">       System.out.println(uniqueNum.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">以上代码运行以后，每次请求 http:<span class="comment">// localhost:8080 / addNum , 得到的结果都是1。</span></span><br><span class="line">更严格的做法是用AtomicInteger类型定义成员变量，对于成员变量的操作使用AtomicInteger的自增方法完成。</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
        <category>SprigMVC</category>
      </categories>
      <tags>
        <tag>SprigMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue的生命周期</title>
    <url>/2022/07/12/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h4 id="Vue的优点"><a href="#Vue的优点" class="headerlink" title="Vue的优点"></a>Vue的优点</h4><ul>
<li><strong>轻量级框架</strong>：只<strong>关注视图层</strong></li>
<li><strong>双向数据绑定</strong>：保留了 angular 的特点，在数据操作方面更为简单</li>
<li><strong>组件化</strong>：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势</li>
<li><strong>虚拟DOM</strong>：dom 操作是非常耗费性能的， 不再使用原生的 dom 操作节点。而是预先通过JavaScript进行各种计算，把最终的DOM操作计算出来并优化。由于这个DOM操作属于预处理操作，并没有真实的操作DOM，所以叫做虚拟DOM。只有最后在计算完毕才真正将DOM操作提交，将DOM操作变化反映到DOM树上</li>
</ul>
<h4 id="对MVVM的理解？"><a href="#对MVVM的理解？" class="headerlink" title="对MVVM的理解？"></a>对MVVM的理解？</h4><p>MVVM 由 <strong>Model、View、ViewModel</strong> 三部分构成，<strong>Model 层代表数据模型</strong>，也可以在Model中定义数据修改和操作的业务逻辑；<strong>View 代表UI 组件</strong>，它负责将数据模型转化成UI 展现出来；<strong>ViewModel 是一个同步View 和 Model的对象</strong>。</p>
<p>在MVVM架构下，<strong>View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互</strong>，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p>
<p><strong>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的</strong>，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理</p>
<h4 id="Vue数据双向绑定原理"><a href="#Vue数据双向绑定原理" class="headerlink" title="Vue数据双向绑定原理"></a>Vue数据双向绑定原理</h4><p>实现mvvm的数据双向绑定，是采用<strong>数据劫持结合发布者-订阅者模式的方式</strong>，通过<strong>Object.defineProperty()来给各个属性添加setter，getter并劫持监听</strong>，在<strong>数据变动时发布消息给订阅者，触发相应的监听回调</strong>。就必须要实现以下几点：</p>
<ol>
<li>实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者</li>
<li>实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</li>
<li>实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</li>
</ol>
<p><img src="/2022/07/12/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/clipboard.png"></p>
<h4 id="生命周期简介"><a href="#生命周期简介" class="headerlink" title="生命周期简介"></a>生命周期简介</h4><p><strong>每个Vue实例在被创建时都要经过一系列的初始化过程</strong>，例如：需要设置<strong>数据的监听</strong>，编译模板，将<strong>实例挂载</strong>到DOM上，并且在<strong>数据变化时更新DOM</strong>等，这些过程统称为Vue实例的生命周期。</p>
<p>这个过程中也会运行一些叫做<strong>生命周期钩子的函数</strong>，这给了用户在不同阶段添加自己的代码的机会</p>
<p>Vue实例的生命周期，主要分为三个阶段，每个阶段都会执行不同的钩子函数</p>
<h5 id="挂载-初始化相关属性-例如watch属性，method属性"><a href="#挂载-初始化相关属性-例如watch属性，method属性" class="headerlink" title="挂载(初始化相关属性,例如watch属性，method属性)"></a><strong>挂载</strong>(初始化相关属性,例如watch属性，method属性)</h5><ul>
<li>beforeCreate</li>
<li>created</li>
<li>beforeMount</li>
<li>mounted</li>
</ul>
<h5 id="更新-元素或组件的变更操作"><a href="#更新-元素或组件的变更操作" class="headerlink" title="**更新(**元素或组件的变更操作)"></a>**更新(**元素或组件的变更操作)</h5><ul>
<li>beforeUpdate</li>
<li>updated</li>
</ul>
<h5 id="销毁（销毁相关属性）"><a href="#销毁（销毁相关属性）" class="headerlink" title="销毁（销毁相关属性）"></a><strong>销毁</strong>（销毁相关属性）</h5><ul>
<li>beforeDestroy</li>
<li>destroyed</li>
</ul>
<p><img src="/2022/07/12/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/clipboard2.png"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeCreate</span>( )<span class="comment">// 该钩子函数执行时，组件实例还未创建.</span></span><br><span class="line"><span class="title function_">created</span>()<span class="comment">//组件初始化完毕，各种数据可以使用，可以使用ajax发送异步请求获取数据</span></span><br><span class="line"><span class="title function_">beforeMounted</span>()<span class="comment">// 未执行渲染，更新，虚拟DOM完成，真实DOM未创建</span></span><br><span class="line"><span class="title function_">mounted</span>()<span class="comment">// 初始化阶段结束，真实DOM已经创建，可以发送异步请求获取数据,也可以访问dom元素</span></span><br><span class="line"><span class="title function_">beforeUpdate</span>()<span class="comment">//更新前，可用于获取更新前各种状态数据</span></span><br><span class="line"><span class="title function_">updated</span>()<span class="comment">//更新后执行该钩子函数，所有的状态数据是最新的。</span></span><br><span class="line"><span class="title function_">beforeDestroy</span>() <span class="comment">// 销毁前执行，可以用于一些定时器的清除。</span></span><br><span class="line"><span class="title function_">destroyed</span>()<span class="comment">//组件已经销毁，事件监听器被移除，所有的子实例也会被销毁。</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis value过大问题</title>
    <url>/2022/07/22/Redis-value%E8%BF%87%E5%A4%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="多大的-key-算大？"><a href="#多大的-key-算大？" class="headerlink" title="多大的 key 算大？"></a><strong>多大的 key 算大？</strong></h4><p>阿里云Redis 最佳实践中提到 合理的 <strong>Key 中 Value 的字节大小，推荐小于10 KB</strong>。过大的 Value 会引发<strong>数据倾斜、热点Key、实例流量或 CPU 性能被占满</strong>等问题，应从设计源头上避免此类问题带来的性能影响。那么 value Bytes &gt;10kb 可以作为判断 大 key 的一个参考值</p>
<h4 id="怎么发现大-Key-？"><a href="#怎么发现大-Key-？" class="headerlink" title="怎么发现大 Key ？"></a><strong>怎么发现大 Key ？</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--bigkeys 命令</span><br></pre></td></tr></table></figure>

<p>–bigkeys 是 redis 自带的命令，<strong>对整个 Key 进行扫描</strong>，统计 string，list，set，zset，hash 这几个常见数据类型中每种类型里的 最大的 key。<strong>string 类型统计的是 value 的字节数</strong>；<strong>另外 4 种复杂结构的类型统计的是 元素个数，不能直观的看出 value 占用字节数</strong>，所以 –bigkeys 对分析 string 类型的大 key 是有用的，而复杂结构的类型还需要一些第三方工具。（ 元素个数少，不一定 value 不大；元素个数多，也不一定 value 就大）</p>
<p>root@vm1:~# redis-cli -h 127.0.0.1 -p 6379 -a “password” –bigkeys #　<strong>–bigkeys　是以 scan 延迟计算的方式扫描所有 key，因此执行过程中不会阻塞 redis，但实例存在 大量的 keys 时，命令执行的时间会很长</strong>，这种情况建议在 slave 上扫描。</p>
<p>–-bigkeys 统计能直观的看出 string 类型 value 的大小，非 string 类型通常有以下两种方式统计：</p>
<ul>
<li>Redis 4.0 以后的版本：支持 了 <strong>memory 命令查看 key 的大小</strong></li>
<li><strong>Rdbtools 工具包</strong>： Rdbtools 是 python写的 一个第三方开源工具，用来<strong>解析 Redis 快照文件</strong>。除了解析 rdb 文件，还提供了 <strong>统计单个 key 大小的工具</strong>。</li>
</ul>
<h4 id="如何优雅的删除-大-key-？"><a href="#如何优雅的删除-大-key-？" class="headerlink" title="如何优雅的删除 大 key ？"></a><strong>如何优雅的删除 大 key ？</strong></h4><h5 id="del-命令"><a href="#del-命令" class="headerlink" title="del 命令"></a>del 命令</h5><p>del 命令删除单个很大的 key 和 del 批量删除 大 key。</p>
<p><strong>直接 del 命令 粗暴的 删大 key 容易造成 redis 线程阻塞</strong>。<strong>4.0 以前要优雅的删除就是针对不同的类型 写脚本，拆分链表，hash 表，分批删除</strong>。</p>
<h5 id="UNLINK-命令"><a href="#UNLINK-命令" class="headerlink" title="UNLINK 命令"></a><strong>UNLINK</strong> 命令</h5><p><strong>4.0 版本以后</strong>官方对 删 大key 有了特别优化，<strong>支持了 lazy free 功能</strong>， 通常不需要开发脚本就可以删    </p>
<p><strong>UNLINK mykey</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; UNLINK mykey </span><br><span class="line">unlink 命令是  del 的异步版本，由 Lazyfree 机制实现。</span><br><span class="line">Lazyfree 机制的原理是在删除的时候只进行逻辑删除，</span><br><span class="line">把 key 释放操作放在 bio (Background I/O)单独的子线程中惰性处理，</span><br><span class="line">减少删除大 key 对 redis 主线程的阻塞，有效地避免因删除大key带来的性能问题。</span><br><span class="line">unlink 即使在批量删除 大 key 时，也不会对阻塞造成阻塞。</span><br></pre></td></tr></table></figure>



<h5 id="被动删除大-key"><a href="#被动删除大-key" class="headerlink" title="被动删除大 key"></a><strong>被动删除大 key</strong></h5><p>被动删除是指 Redis 自身的 key 清除策略</p>
<ul>
<li>Redis 内存不够时 key 的淘汰策略 ，即超过了 maxmemory 的配置</li>
<li>惰性删除：（建议开启惰性清除策略 ）</li>
<li>定时删除：( redis 默认策略 )</li>
</ul>
<h4 id="Redis的-bigkey-有哪些影响"><a href="#Redis的-bigkey-有哪些影响" class="headerlink" title="Redis的 bigkey 有哪些影响"></a><strong>Redis的 bigkey 有哪些影响</strong></h4><ul>
<li><strong>影响性能</strong></li>
</ul>
<p>因为 Redis <strong>单线程</strong>的工作机制，主线程处理所有key的增删改查。<strong>对bigkey的操作耗时增加将阻塞主线程处理其他业务请求，进而影响整体吞吐量</strong>。</p>
<ul>
<li><strong>影响带宽</strong></li>
</ul>
<p>前面的案例即是一个例子，单个key 7MB ，如果每秒100次查询，则带来700MB 的带宽，虽然现在大部分是万兆网卡<strong>，业务请求量再大一些，网卡也有被打满的风险</strong>。</p>
<ul>
<li><strong>数据倾斜</strong></li>
</ul>
<p><strong>对于分片的redis集群，存在bigkey 会导致单个分片数据量远大于其他节点，整体不均衡</strong>。<strong>如果一个分片空间容量满了，对系统造成不可访问</strong>，而且也不能随意扩容，因为不拆分key的情况下扩容，单个分片还是存在数据倾斜。更惨的是，<strong>数据量比较大，那么访问就增加，容易形成热点</strong>。热点不都是因为数据倾斜导致，数据倾斜会大概率导致热点。</p>
<ul>
<li><strong>影响主从同步</strong></li>
</ul>
<p>Redis Server 的输出大小通常是不可控制的。存在bigkey的时候，就会产生体积庞大的返回数据。另外也有可能因为执行了太多命令，导致产生返回数据的速率超过了往客户端发送的速率，导致服务器堆积大量消息，从而<strong>导致输出缓冲区越来越大，占用过多内存，甚至导致系统崩溃</strong>。Redis 通过设置client-output-buffer-limit 来保护系统安全。</p>
<h4 id="如何解决大key？"><a href="#如何解决大key？" class="headerlink" title="如何解决大key？"></a><strong>如何解决大key？</strong></h4><p>其实就是一个字 “拆”。</p>
<ul>
<li><p>对于字符串类型的key，我们通常要在业务层面将value的大小控制在10KB左右，如果value确实很大，可以考虑<strong>采用序列化算法和压缩算法来处理</strong>，推荐常用的几种序列化算法:Protostuff、Kryo或者Fst。</p>
</li>
<li><p>对于集合类型的key，我们通常要通过控制集合内元素数量来避免bigKey，通常的做法是将<strong>一个大的集合类型的key拆分成若干小集合类型的key来达到目的</strong>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>count(*) 和 count(1) 有什么区别？</title>
    <url>/2024/05/12/count-%E5%92%8C-count-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="count-和-count-1-有什么区别？哪个性能最好？"><a href="#count-和-count-1-有什么区别？哪个性能最好？" class="headerlink" title="count(*) 和 count(1) 有什么区别？哪个性能最好？"></a>count(*) 和 count(1) 有什么区别？哪个性能最好？</h1><p>当我们对一张数据表中的记录进行统计的时候，习惯都会使用 count 函数来统计，但是 count 函数传入的参数有很多种，比如 count(1)、count(<code>*</code>)、count(字段) 等。</p>
<p>到底哪种效率是最好的呢？是不是 count(<code>*</code>) 效率最差？</p>
<p>我曾经以为 count(<code>*</code>) 是效率最差的，因为认知上 <code>selete * from t</code> 会读取所有表中的字段，所以凡事带有 <code>*</code> 字符的就觉得会读取表中所有的字段，当时网上有很多博客也这么说。</p>
<p>但是，当我深入 count 函数的原理后，被啪啪啪的打脸了！</p>
<p><img src="/2024/05/12/count-%E5%92%8C-count-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/d9b9817e92f805e9a16faf31a2c10d9a.png" alt="图片"></p>
<h2 id="哪种-count-性能最好？"><a href="#哪种-count-性能最好？" class="headerlink" title="哪种 count 性能最好？"></a>哪种 count 性能最好？</h2><p>我先直接说结论：</p>
<p><img src="/2024/05/12/count-%E5%92%8C-count-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/af711033aa3423330d3a4bc6baeb9532.png" alt="图片"></p>
<p>要弄明白这个，我们得要深入 count 的原理，以下内容基于常用的 innodb 存储引擎来说明。</p>
<h3 id="count-是什么？"><a href="#count-是什么？" class="headerlink" title="#count() 是什么？"></a><a href="https://www.xiaolincoding.com/mysql/index/count.html#count-%E6%98%AF%E4%BB%80%E4%B9%88">#</a>count() 是什么？</h3><p>count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是<strong>统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个</strong>。</p>
<p>假设 count() 函数的参数是字段名，如下：</p>
<p><code>select count(name) from t_order;</code></p>
<p>这条语句是统计「 t_order 表中，name 字段不为 NULL 的记录」有多少个。也就是说，如果某一条记录中的 name 字段的值为 NULL，则就不会被统计进去。</p>
<p>再来假设 count() 函数的参数是数字 1 这个表达式，如下：</p>
<p><code>select count(1) from t_order;</code></p>
<p>这条语句是统计「 t_order 表中，1 这个表达式不为 NULL 的记录」有多少个。</p>
<p>1 这个表达式就是单纯数字，它永远都不是 NULL，所以上面这条语句，其实是在统计 t_order 表中有多少个记录</p>
<h3 id="count-主键字段-执行过程是怎样的？"><a href="#count-主键字段-执行过程是怎样的？" class="headerlink" title="count(主键字段) 执行过程是怎样的？"></a>count(主键字段) 执行过程是怎样的？</h3><p>在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。</p>
<p>server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端。</p>
<p>InnoDB 是通过 B+ 树来保存记录的，根据索引的类型又分为聚簇索引和二级索引，它们区别在于，聚簇索引的叶子节点存放的是实际数据，而二级索引的叶子节点存放的是主键值，而不是实际数据。</p>
<p>用下面这条语句作为例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>id 为主键值</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(id) <span class="keyword">from</span> t_order;</span><br></pre></td></tr></table></figure>

<p>如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。</p>
<p><img src="/2024/05/12/count-%E5%92%8C-count-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/9bb4f32ac843467684a2664d4db61ae3.png" alt="图片"></p>
<p>但是，如果表里有二级索引时，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。</p>
<p><img src="/2024/05/12/count-%E5%92%8C-count-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/aac550602ef1022e0b45020dbe0f716a.png" alt="图片"></p>
<p>这是因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样遍历二级索引的 I/O 成本比遍历聚簇索引的 I/O 成本小，因此「优化器」优先选择的是二级索引。</p>
<h3 id="count-1-执行过程是怎样的？"><a href="#count-1-执行过程是怎样的？" class="headerlink" title="count(1) 执行过程是怎样的？"></a>count(1) 执行过程是怎样的？</h3><p>用下面这条语句作为例子：</p>
<p><code>select count(1) from t_order;</code></p>
<p>如果表里只有主键索引，没有二级索引时。</p>
<p>那么，InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，<strong>但是不会读取记录中的任何字段的值</strong>，因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。</p>
<p>可以看到，count(1) 相比 count(主键字段) 少一个步骤，就是不需要读取记录中的字段值，所以通常会说 count(1) 执行效率会比 count(主键字段) 高一点。</p>
<p>但是，如果表里有二级索引时，InnoDB 循环遍历的对象就二级索引了。</p>
<h3 id="count-执行过程是怎样的？"><a href="#count-执行过程是怎样的？" class="headerlink" title="count(*) 执行过程是怎样的？"></a>count(*) 执行过程是怎样的？</h3><p>看到 <code>*</code> 这个字符的时候，是不是大家觉得是读取记录中的所有字段值？</p>
<p>对于 <code>selete *</code> 这条语句来说是这个意思，但是在 count(*) 中并不是这个意思。</p>
<p>**count(<code>\*</code>) 其实等于 count(<code>0</code>)**，也就是说，当你使用 count(<code>*</code>) 时，MySQL 会将 <code>*</code> 参数转化为参数 0 来处理。</p>
<p><img src="/2024/05/12/count-%E5%92%8C-count-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/27b229f049b27898f3a86c7da7e26114.png" alt="图片"></p>
<p>所以，<strong>count(*) 执行过程跟 count(1) 执行过程基本一样的</strong>，性能没有什么差异。</p>
<p>在 MySQL 5.7 的官方手册中有这么一句话：</p>
<p><em>InnoDB handles SELECT COUNT(<code>\*</code>) and SELECT COUNT(<code>1</code>) operations in the same way. There is no performance difference.</em></p>
<p><em>翻译：InnoDB以相同的方式处理SELECT COUNT（<code>\*</code>）和SELECT COUNT（<code>1</code>）操作，没有性能差异。</em></p>
<p>而且 MySQL 会对 count(*) 和 count(1) 有个优化，如果有多个二级索引的时候，优化器会使用key_len 最小的二级索引进行扫描。</p>
<p>只有当没有二级索引的时候，才会采用主键索引来进行统计。</p>
<h3 id="count-字段-执行过程是怎样的？"><a href="#count-字段-执行过程是怎样的？" class="headerlink" title="count(字段) 执行过程是怎样的？"></a>count(字段) 执行过程是怎样的？</h3><p>count(字段) 的执行效率相比前面的 count(1)、 count(*)、 count(主键字段) 执行效率是最差的。</p>
<p>用下面这条语句作为例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> name不是索引，普通字段</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(name) <span class="keyword">from</span> t_order;</span><br></pre></td></tr></table></figure>

<p>对于这个查询来说，会采用全表扫描的方式来计数，所以它的执行效率是比较差的。</p>
<p><img src="/2024/05/12/count-%E5%92%8C-count-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/f24dfeb85e2cfce0e4dc3a17b893b3f5.png" alt="图片"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。</p>
<p>所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。</p>
<p>再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。</p>
<h2 id="为什么要通过遍历的方式来计数？"><a href="#为什么要通过遍历的方式来计数？" class="headerlink" title="为什么要通过遍历的方式来计数？"></a>为什么要通过遍历的方式来计数？</h2><p>你可能会好奇，为什么 count 函数需要通过遍历的方式来统计记录个数？</p>
<p>我前面将的案例都是基于 Innodb 存储引擎来说明的，但是在 MyISAM 存储引擎里，执行 count 函数的方式是不一样的，通常在没有任何查询条件下的 count(*)，MyISAM 的查询速度要明显快于 InnoDB。</p>
<p>使用 MyISAM 引擎时，执行 count 函数只需要 O(1 )复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息有存储了row_count值，由表级锁保证一致性，所以直接读取 row_count 值就是 count 函数的执行结果。</p>
<p>而 InnoDB 存储引擎是支持事务的，同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的，所以无法像 MyISAM一样，只维护一个 row_count 变量。</p>
<p>举个例子，假设表 t_order 有 100 条记录，现在有两个会话并行以下语句：</p>
<p><img src="/2024/05/12/count-%E5%92%8C-count-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/04d714293f5c687810562e984b67d2e7.png" alt="图片"></p>
<p>在会话 A 和会话 B的最后一个时刻，同时查表 t_order 的记录总个数，可以发现，显示的结果是不一样的。所以，在使用 InnoDB 存储引擎时，就需要扫描表来统计具体的记录。</p>
<p>而当带上 where 条件语句之后，MyISAM 跟 InnoDB 就没有区别了，它们都需要扫描表来进行记录个数的统计。</p>
<h2 id="如何优化-count-？"><a href="#如何优化-count-？" class="headerlink" title="如何优化 count(*)？"></a>如何优化 count(*)？</h2><p>如果对一张大表经常用 count(*) 来做统计，其实是很不好的。</p>
<p>比如下面我这个案例，表 t_order 共有 1200+ 万条记录，我也创建了二级索引，但是执行一次 <code>select count(*) from t_order</code> 要花费差不多 5 秒！</p>
<p><img src="/2024/05/12/count-%E5%92%8C-count-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/74a4359b58dc6ed41a241e425f43764d.png" alt="图片"></p>
<p>面对大表的记录统计，我们有没有什么其他更好的办法呢？</p>
<h3 id="第一种，近似值"><a href="#第一种，近似值" class="headerlink" title="#第一种，近似值"></a><a href="https://www.xiaolincoding.com/mysql/index/count.html#%E7%AC%AC%E4%B8%80%E7%A7%8D-%E8%BF%91%E4%BC%BC%E5%80%BC">#</a>第一种，近似值</h3><p>如果你的业务对于统计个数不需要很精确，比如搜索引擎在搜索关键词的时候，给出的搜索结果条数是一个大概值。</p>
<p><img src="/2024/05/12/count-%E5%92%8C-count-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/cd18879de0c0b37660f53a5f1af3d172.png" alt="图片"></p>
<p>这时，我们就可以使用 show table status 或者 explain 命令来表进行估算。</p>
<p>执行 explain 命令效率是很高的，因为它并不会真正的去查询，下图中的 rows 字段值就是 explain 命令对表 t_order 记录的估算值。</p>
<p><img src="/2024/05/12/count-%E5%92%8C-count-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/7590623443e8f225e5652109e6d9e3d2.png" alt="图片"></p>
<h3 id="第二种，额外表保存计数值"><a href="#第二种，额外表保存计数值" class="headerlink" title="第二种，额外表保存计数值"></a>第二种，额外表保存计数值</h3><p>如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。</p>
<p>当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/07/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>openFeign介绍</title>
    <url>/2022/07/10/openFeign%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>Feign是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务，简化成就像调用本地方法那样简单。</p>
<p>OpenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequestMaping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMaping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务</p>
<p>OpenFeign 是对 JDK 的 HttpURLConnection（以及第三方库 HttpClient 和 OkHttp）的包装和简化</p>
<h5 id="简单总结下-OpenFeign-能用来做什么："><a href="#简单总结下-OpenFeign-能用来做什么：" class="headerlink" title="简单总结下 OpenFeign 能用来做什么："></a>简单总结下 OpenFeign 能用来做什么：</h5><p>OpenFeign 是声明式的 HTTP 客户端，让远程调用更简单。</p>
<p>提供了HTTP请求的模板，编写简单的接口和插入注解，就可以定义好HTTP请求的参数、格式、地址等信息</p>
<p>整合了Ribbon（负载均衡组件）和 Hystix（服务熔断组件），不需要显示使用这两个组件</p>
<p>Spring Cloud Feign 在 Netflix Feign的基础上扩展了对SpringMVC注解的支持</p>
<h5 id="梳理-OpenFeign-的核心流程："><a href="#梳理-OpenFeign-的核心流程：" class="headerlink" title="梳理 OpenFeign 的核心流程："></a>梳理 OpenFeign 的核心流程：</h5><p><img src="/2022/07/10/openFeign%E4%BB%8B%E7%BB%8D/clipboard.png"></p>
<ul>
<li><p>在 Spring 项目启动阶段，服务 A 的OpenFeign 框架会发起一个主动的扫包流程。</p>
</li>
<li><p>从指定的目录下扫描并加载所有被 @FeignClient 注解修饰的接口，然后将这些接口转换成 Bean，统一交给 Spring 来管理。</p>
</li>
<li><p>根据这些接口会经过 MVC Contract 协议解析，将方法上的注解都解析出来，放到 MethodMetadata 元数据中。</p>
</li>
<li><p>基于上面加载的每一个 FeignClient 接口，会生成一个动态代理对象，指向了一个包含对应方法的 MethodHandler 的 HashMap。MethodHandler 对元数据有引用关系。生成的动态代理对象会被添加到 Spring 容器中，并注入到对应的服务里。</p>
</li>
<li><p>服务 A 调用接口，准备发起远程调用。</p>
</li>
<li><p>从动态代理对象 Proxy 中找到一个 MethodHandler 实例，生成 Request，包含有服务的请求 URL（不包含服务的 IP）。</p>
</li>
<li><p>经过负载均衡算法找到一个服务的 IP 地址，拼接出请求的 URL</p>
</li>
<li><p>服务 B 处理服务 A 发起的远程调用请求，执行业务逻辑后，返回响应给服务 A</p>
</li>
</ul>
<h5 id="代码helloword："><a href="#代码helloword：" class="headerlink" title="代码helloword："></a>代码helloword：</h5><p>1、依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br></pre></td></tr></table></figure>

<p>2、主启动类添加@EnableFeignClients @EnableDiscoveryClient</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yl.openfeign.order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenFeignOrder80Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OpenFeignOrder80Application.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、编写service接口调用远程服务，添加@FeignClient注解（value：调用的服务名）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支付</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;PAYMENT&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentFeignService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    CommonResult&lt;Payment&gt; <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、编写controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支付</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/order&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFeignController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 查询结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> paymentFeignService.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5、被调用的服务controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支付</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> Y-wee</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/payment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 查询结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> paymentService.getPaymentById(id);</span><br><span class="line">        <span class="keyword">if</span> (payment != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">200</span>, <span class="string">&quot;查询成功:&quot;</span> + serverPort, payment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">444</span>, <span class="string">&quot;没有对应记录,查询ID: &quot;</span> + id, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="feign中http-client"><a href="#feign中http-client" class="headerlink" title="feign中http client"></a>feign中http client</h5><p>如果不做特殊配置，OpenFeign默认使用jdk自带的HttpURLConnection，我们知道HttpURLConnection没有连接池、性能和效率比较低，如果采用默认，很可能会遇到性能问题导致系统故障。</p>
<p>可以采用Apache HttpClient</p>
<p>@ConditionalOnClass({ApacheHttpClient.class})注解可知，只需要在pom文件上加上HttpClient依赖即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">feign.httpclient.enabled=<span class="literal">true</span> #不配置也是默认为<span class="literal">true</span>的</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">9.4</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>也可以采用OkHttpClient</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">10.2</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>框架</category>
        <category>SpringCould</category>
        <category>openFeign</category>
      </categories>
      <tags>
        <tag>SpringCould</tag>
      </tags>
  </entry>
  <entry>
    <title>redisson获取锁失败</title>
    <url>/2022/07/17/redisson%E8%8E%B7%E5%8F%96%E9%94%81%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<h5 id="lock-lock-方法"><a href="#lock-lock-方法" class="headerlink" title="lock.lock()方法"></a>lock.lock()方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// do sth.</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lock()源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lockInterruptibly();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">lockInterruptibly(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看lockInterruptibly方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">(<span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123; <span class="comment">// 获取成功</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 异步订阅redis chennel</span></span><br><span class="line">RFuture&lt;RedissonLockEntry&gt; future = subscribe(threadId);</span><br><span class="line">commandExecutor.syncSubscription(future); <span class="comment">// 阻塞获取订阅结果</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">// 循环判断知道获取锁</span></span><br><span class="line">        ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">        <span class="comment">// lock acquired</span></span><br><span class="line">        <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// waiting for message</span></span><br><span class="line">    <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    	getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	getEntry(threadId).getLatch().acquire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	unsubscribe(future, threadId);<span class="comment">// 取消订阅</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结lockInterruptibly：</p>
<p>获取锁，<strong>不成功则订阅释放锁的消息，获得消息前阻塞</strong>。</p>
<p><strong>得到释放通知后再去循环获取锁</strong>。</p>
<h5 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h5><p>tryLock()方法是有返回值的，它表示用来尝试获取锁<br>如果获取成功，则返回true<br><strong>如果获取失败（即锁已被其他线程获取），则返回false</strong><br>这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待</p>
<h5 id="tryLock-long-waitTime-long-leaseTime-TimeUnit-unit"><a href="#tryLock-long-waitTime-long-leaseTime-TimeUnit-unit" class="headerlink" title="tryLock(long waitTime, long leaseTime, TimeUnit unit)"></a>tryLock(long waitTime, long leaseTime, TimeUnit unit)</h5><p><strong>没获取到锁时，在指定的重试时间内，会尝试重新获取锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 尝试获取锁</span></span><br><span class="line"><span class="comment">* waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span></span><br><span class="line"><span class="comment">* leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> rLock.tryLock(waitTimeout, leaseTime, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>举例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String lockKey, <span class="type">long</span> lockWaitTime, <span class="type">long</span> lockTime)</span> &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个参数lockWaitTime是等待时间，n毫秒内获取不到锁，则直接返回</span></span><br><span class="line">        <span class="comment">// 第二个参数lockTime是锁超时时间，m毫秒后强制释放锁</span></span><br><span class="line">        <span class="keyword">return</span> lock.tryLock(lockWaitTime, lockTime, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;LOCK FAILED: key=%s||tryLockTime=%s||lockExpiredTime=%s&quot;</span>, lockKey, lockWaitTime, lockTime);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解锁:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String lockKey)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line">        <span class="keyword">if</span> (lock != <span class="literal">null</span>) &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;UNLOCK FAILED: key=%s&quot;</span>, lockKey);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行解锁代码后，有时会出现以下报错，这是什么原因呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread</span><br></pre></td></tr></table></figure>

<p>比如下面这段代码，在获取锁成功之后，持有的时间是8秒，而<strong>如果你的锁内业务执行时间超过8秒后，锁会自动释放，锁自动释放后，而在你的finally里面又手动去释放锁，就导致了这个错误</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取锁，持有8秒后，自动释放</span></span><br><span class="line">        tryLock(key, <span class="number">1000L</span>, <span class="number">8000L</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String lockKey)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line">        <span class="keyword">if</span> (lock != <span class="literal">null</span> &amp;&amp; lock.isHeldByCurrentThread()) &#123; </span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;UNLOCK FAILED: key=%s&quot;</span>, lockKey);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解锁时，<strong>增加lock.isHeldByCurrentThread()判断</strong>，意思是<strong>查询当前线程是否持有该锁</strong>，如果还持有，则释放，未持有，说明已释放</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
        <category>Redisson</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redisson</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么MySQL采用B+树作为索引</title>
    <url>/2023/03/10/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E9%87%87%E7%94%A8B-%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="为什么-MySQL-采用-B-树作为索引？"><a href="#为什么-MySQL-采用-B-树作为索引？" class="headerlink" title="为什么 MySQL 采用 B+ 树作为索引？"></a>为什么 MySQL 采用 B+ 树作为索引？</h1><p>MySQL 是会将数据持久化在硬盘，而存储功能是由 MySQL 存储引擎实现的，所以讨论 MySQL 使用哪种数据结构作为索引，实际上是在讨论存储引使用哪种数据结构作为索引，InnoDB 是 MySQL 默认的存储引擎，它就是采用了 B+ 树作为索引的数据结构。</p>
<p>要设计一个 MySQL 的索引数据结构，不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑磁盘 I/0 的操作次数。因为索引和记录都是存放在硬盘，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I/0 的操作次数内完成。</p>
<p>二分查找树虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是它存在一种极端的情况，每当插入的元素都是树内最大的元素，就会导致二分查找树退化成一个链表，此时查询复杂度就会从 O(logn)降低为 O(n)。</p>
<p>为了解决二分查找树退化成链表的问题，就出现了自平衡二叉树，保证了查询操作的时间复杂度就会一直维持在 O(logn) 。但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。</p>
<p>而树的高度决定于磁盘 I/O 操作的次数，因为树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作，也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。</p>
<p>B 树和 B+ 都是通过多叉树的方式，会将树的高度变矮，所以这两个数据结构非常适合检索存于磁盘中的数据。</p>
<p>但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：</p>
<ul>
<li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。</li>
<li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li>
<li>B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。</li>
</ul>
<p>完！</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/2022/09/04/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p>享元模式（Flyweight Pattern）主要用于<strong>减少创建对象的数量，以减少内存占用和提高性能</strong></p>
<p><strong>String常量池、数据库连接池、缓冲池</strong>等等都是享元模式的应用，所以说享元模式是池技术的重要实现方式</p>
<p>比如我们每次创建字符串对象时，都需要创建一个新的字符串对象的话，内存开销会很大，所以如果第一次创建了字符串对象“adam“，下次再创建相同的字符串”adam“时，只是把它的引用指向”adam“，这样就实现了”adam“字符串再内存中的共享</p>
<p><strong>用HashMap/HashTable存储</strong> </p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是缓存雪崩、击穿、穿透？</title>
    <url>/2022/11/05/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="什么是缓存雪崩、击穿、穿透"><a href="#什么是缓存雪崩、击穿、穿透" class="headerlink" title="什么是缓存雪崩、击穿、穿透"></a>什么是缓存雪崩、击穿、穿透</h1><p>用户的数据一般都是存储于数据库，数据库的数据是落在磁盘上的，磁盘的读写速度可以说是计算机里最慢的硬件了。</p>
<p>当用户的请求，都访问数据库的话，请求数量一上来，数据库很容易就奔溃的了，所以为了避免用户直接访问数据库，会用 Redis 作为缓存层。</p>
<p>因为 Redis 是内存数据库，我们可以将数据库的数据缓存在 Redis 里，相当于数据缓存在内存，内存的读写速度比硬盘快好几个数量级，这样大大提高了系统性能</p>
<p><img src="/2022/11/05/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%EF%BC%9F/37e4378d2edcb5e217b00e5f12973efd-20230309232858764.png" alt="图片"></p>
<p>引入了缓存层，就会有缓存异常的三个问题，分别是<strong>缓存雪崩、缓存击穿、缓存穿透</strong>。</p>
<p><img src="/2022/11/05/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%EF%BC%9F/61781cd6d82e4a0cc5f7521333049f0d.png" alt="图片"></p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>通常我们为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。</p>
<p><img src="/2022/11/05/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%EF%BC%9F/e2b8d2eb5536aa71664772457792ec40-20230309232851699.png" alt="图片"></p>
<p>那么，当<strong>大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机</strong>时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是<strong>缓存雪崩</strong>的问题。</p>
<p><img src="/2022/11/05/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%EF%BC%9F/717343a0da7a1b05edab1d1cdf8f28e5.png" alt="图片"></p>
<p>可以看到，发生缓存雪崩有两个原因：</p>
<ul>
<li>大量数据同时过期；</li>
<li>Redis 故障宕机；</li>
</ul>
<p>不同的诱因，应对的策略也会不同</p>
<h3 id="大量数据同时过期"><a href="#大量数据同时过期" class="headerlink" title="大量数据同时过期"></a>大量数据同时过期</h3><p><em>1. 均匀设置过期时间</em></p>
<p>如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，<strong>给这些数据的过期时间加上一个随机数</strong>，这样就保证数据不会在同一时间过期。</p>
<p><em>2. 互斥锁</em></p>
<p>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p>
<p>实现互斥锁的时候，最好设置<strong>超时时间</strong>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p>
<p><em>3. 数据预热</em></p>
<p>在业务刚上线的时候，我们最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建</p>
<h3 id="Redis-故障宕机"><a href="#Redis-故障宕机" class="headerlink" title="Redis 故障宕机"></a>Redis 故障宕机</h3><p>针对 Redis 故障宕机而引发的缓存雪崩问题，常见的应对方法有下面这几种：</p>
<ul>
<li>服务熔断或请求限流机制；</li>
<li>构建 Redis 缓存高可靠集群；</li>
</ul>
<p><em>1. 服务熔断或请求限流机制</em></p>
<p>因为 Redis 故障宕机而导致缓存雪崩问题时，我们可以启动<strong>服务熔断</strong>机制，<strong>暂停业务应用对缓存服务的访问，直接返回错误</strong>，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。</p>
<p>服务熔断机制是保护数据库的正常允许，但是暂停了业务应用访问缓存服系统，全部业务都无法正常工作</p>
<p>为了减少对业务的影响，我们可以启用<strong>请求限流</strong>机制，<strong>只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</strong>，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p>
<p><em>2. 构建 Redis 缓存高可靠集群</em></p>
<p>服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过<strong>主从节点的方式构建 Redis 缓存高可靠集群</strong>。</p>
<p>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。</p>
<p>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>的问题。</p>
<p><img src="/2022/11/05/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%EF%BC%9F/acb5f4e7ef24a524a53c39eb016f63d4-20230309232840753.png" alt="图片"></p>
<p>可以发现缓存击穿跟缓存雪崩很相似，你可以认为缓存击穿是缓存雪崩的一个子集。</p>
<p>应对缓存击穿可以采取前面说到两种方案：</p>
<ul>
<li>互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li>
<li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li>
</ul>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>当发生缓存雪崩或击穿时，数据库中还是保存了应用要访问的数据，一旦缓存恢复相对应的数据，就可以减轻数据库的压力，而缓存穿透就不一样了。</p>
<p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题。</p>
<p><img src="/2022/11/05/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%EF%BC%9F/b7031182f770a7a5b3c82eaf749f53b0-20230309232834574.png" alt="图片"></p>
<p>缓存穿透的发生一般有这两种情况：</p>
<ul>
<li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li>
<li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li>
</ul>
<p>应对缓存穿透的方案，常见的方案有三种。</p>
<ul>
<li>第一种方案，非法请求的限制；</li>
<li>第二种方案，缓存空值或者默认值；</li>
<li>第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；</li>
</ul>
<p>第一种方案，非法请求的限制</p>
<p>当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</p>
<p>第二种方案，缓存空值或者默认值</p>
<p>当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</p>
<p><em>第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。</em></p>
<p>我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。</p>
<p>即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>缓存异常会面临的三个问题：缓存雪崩、击穿和穿透。</p>
<p>其中，缓存雪崩和缓存击穿主要原因是数据不在缓存中，而导致大量请求访问了数据库，数据库压力骤增，容易引发一系列连锁反应，导致系统奔溃。不过，一旦数据被重新加载回缓存，应用又可以从缓存快速读取数据，不再继续访问数据库，数据库的压力也会瞬间降下来。因此，缓存雪崩和缓存击穿应对的方案比较类似。</p>
<p>而缓存穿透主要原因是数据既不在缓存也不在数据库中。因此，缓存穿透与缓存雪崩、击穿应对的方案不太一样。</p>
<p>我这里整理了表格，你可以从下面这张表格很好的知道缓存雪崩、击穿和穿透的区别以及应对方案。</p>
<p><img src="/2022/11/05/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%EF%BC%9F/061e2c04e0ebca3425dd75dd035b6b7b.png" alt="图片"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2022/08/12/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>通过代理控制对象的访问，可以在这个<strong>对象调用方法之前、调用方法之后去处理/添加新的功能</strong></p>
<p>代理在<strong>原有代码乃至原业务流程都不修改的情况</strong>下，直接在业务流程中<strong>切入新代码，增加新功能</strong></p>
<p>如：<strong>Spring AOP、日志打印、异常处理、事务控制、权限控制</strong>等</p>
<p><strong>Subject抽象主题角色</strong></p>
<p>抽象主题类可以是抽象类也可以是接口，是一个最普通的业务类型定义，无特殊要求。</p>
<p><strong>RealSubject具体主题角色</strong></p>
<p>也叫做被委托角色、被代理角色。是业务逻辑的具体执行者。</p>
<p><strong>Proxy代理主题角色</strong></p>
<p>把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在真实主题角色处理完毕前后做预处理和善后处理工作，Proxy和具体主题都是去实现抽象主题。</p>
<h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a><strong>静态代理</strong></h5><p>所谓静态也就是<strong>在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了</strong></p>
<p>缺点：每个需要代理的对象都需要自己重复编写代理，很不舒服，</p>
<p>优点：但是可以面相实际对象或者是接口的方式实现代理</p>
<p>如何能在不修改UserDao接口类的情况下开事务和关闭事务呢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainRun</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        UserDao userDao=<span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">        <span class="type">UserDaoProxy</span> <span class="variable">userDaoProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao);</span><br><span class="line">        userDaoProxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是保存数据方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">extends</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事务&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭事务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p><img src="C:/Users/helq/AppData/Roaming/Typora/typora-user-images/image-20230318154047794.png" alt="image-20230318154047794"></p>
<p>动态代理也叫做，<strong>JDK代理、接口代理</strong>。</p>
<p>动态代理的对象，是利用JDK的API，<strong>动态的在内存中构建代理对象</strong>（是<strong>根据被代理的接口来动态</strong></p>
<p><strong>生成代理类的class文件</strong>，并加载运行的过程），这就叫动态代理</p>
<p>在程序运行时，运用<strong>反射机制动态创建而成</strong></p>
<p>缺点：必须是面向接口，目标业务类必须实现接口</p>
<p>优点：不用关心代理类，只需要在运行阶段才指定代理哪一个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainRun</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//被代理的对象</span></span><br><span class="line">        UserDao userDaoImpl=<span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        <span class="comment">//代理对象的类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> userDaoImpl.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// interfaces 所有你需要代理的方法的接口</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = userDaoImpl.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">//代理类 动态代理方法在执行时，会调用h里面的invoke方法去执行</span></span><br><span class="line">        <span class="type">InvocaionHandlerImpl</span> <span class="variable">invocaionHandler</span> <span class="operator">=</span> <span class="keyword">new</span>                       <span class="title class_">InvocaionHandlerImpl</span>(userDaoImpl);</span><br><span class="line">        </span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDaoProxy</span> <span class="operator">=</span> (UserDao) Proxy.newProxyInstance(classLoader, interfaces, invocaionHandler);</span><br><span class="line">        userDaoProxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是保存数据的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvocaionHandlerImpl</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//业务实现类对象，用来调用具体的业务方法</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数传入目标对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvocaionHandlerImpl</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态代理实际运行的代理方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;开始事务&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;打印日志&quot;</span>);</span><br><span class="line">        <span class="comment">//下面invoke()方法是以反射的方式来创建对象，第一个参数是要创建的对象，</span></span><br><span class="line">        <span class="comment">// 第二个是构成方法的参数，由第二个参数来决定创建对象使用哪个构造方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭事务&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a><strong>CGLIB动态代理</strong></h5><p>利用<strong>asm开源包</strong>，对代理对象类的class文件加载进来，<strong>通过修改其字节码生成子类来处理</strong></p>
<p>什么是CGLIB动态代理</p>
<p>CGLIB动态代理和jdk代理一样，使用反射完成代理，不同的是他可以直接代理类（jdk动态代理不</p>
<p>行，他必须目标业务类必须实现接口），CGLIB动态代理底层使用字节码技术，CGLIB动态代理不</p>
<p>能对 final类进行继承。（CGLIB动态代理需要导入jar包）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainRun</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        CglibProxy cglibProxy=<span class="keyword">new</span> <span class="title class_">CglibProxy</span>();</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao)cglibProxy.getProxyInstance(<span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>());</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object targetObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给目标对象创建一个代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Object targetObject)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.targetObject=targetObject;</span><br><span class="line">        <span class="comment">// 设置需要创建子类的类</span></span><br><span class="line">        <span class="comment">//1.工具类</span></span><br><span class="line">        Enhancer en=<span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//2.设置父类</span></span><br><span class="line">        en.setSuperclass(targetObject.getClass());</span><br><span class="line">        <span class="comment">//3.设置回调调用intercept方法</span></span><br><span class="line">        en.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//4.创建子类(代理对象)</span></span><br><span class="line">        <span class="keyword">return</span> en.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截所有目标类方法的调用</span></span><br><span class="line"><span class="comment">     * obj  目标类的实例</span></span><br><span class="line"><span class="comment">     * m   目标方法的反射对象</span></span><br><span class="line"><span class="comment">     * args  方法的参数</span></span><br><span class="line"><span class="comment">     * proxy代理类的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事务&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> methodProxy.invoke(targetObject, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭事务&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式Session解决方案</title>
    <url>/2022/07/12/%E5%88%86%E5%B8%83%E5%BC%8FSession%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h4 id="分布式session解决方案"><a href="#分布式session解决方案" class="headerlink" title="分布式session解决方案"></a>分布式session解决方案</h4><h5 id="cookie和session的区别和联系"><a href="#cookie和session的区别和联系" class="headerlink" title="cookie和session的区别和联系"></a>cookie和session的区别和联系</h5><ul>
<li>cookie是本地客户端用来存储少量数据信息的，保存在客户端，用户能够很容易的获取，安全性不高，存储的数据量小</li>
<li>session是服务器用来存储部分数据信息，保存在服务器，用户不容易获取，安全性高，储存的数据量相对大，存储在服务器，会占用一些服务器资源，但是对于它的优点来说，这个缺点可以忽略了</li>
</ul>
<h5 id="session有什么用"><a href="#session有什么用" class="headerlink" title="session有什么用"></a>session有什么用</h5><ul>
<li><p>在一次客户端和服务器为之间的会话中，客户端(浏览器)向服务器发送请求，首先cookie会自动携带上次请求存储的数据(JSESSIONID)到服务器，服务器根据请求参数中的JSESSIONID到服务器中的session库中查询是否存在此JSESSIONID的信息，如果存在，那么服务器就知道此用户是谁，如果不存在，就会创建一个JSESSIONID，并在本次请求结束后将JSESSIONID返回给客户端，同时将此JSESSIONID在客户端cookie中进行保存</p>
</li>
<li><p>客户端和服务器之间是通过http协议进行通信，但是http协议是无状态的，不同次请求会话是没有任何关联的，但是优点是处理速度快</p>
</li>
<li><p>session是一次浏览器和服务器的交互的会话，当浏览器关闭的时候，会话就结束了，但是会话session还在，默认session是还保留30分钟的</p>
</li>
</ul>
<h5 id="分布式session一致性"><a href="#分布式session一致性" class="headerlink" title="分布式session一致性"></a>分布式session一致性</h5><p>客户端发送一个请求，经过负载均衡后该请求会被分配到服务器中的其中一个，由于不同服务器含有不同的web服务器(例如Tomcat)，不同的web服务器中并不能发现之前web服务器保存的session信息，就会再次生成一个JSESSIONID，之前的状态就会丢失</p>
<h5 id="分布式session的几种实现方式"><a href="#分布式session的几种实现方式" class="headerlink" title="分布式session的几种实现方式"></a>分布式session的几种实现方式</h5><ul>
<li><p><strong>粘性session</strong></p>
<p><strong>原理</strong>：粘性Session是指将用户锁定到某一个服务器上，比如上面说的例子，用户第一次请求时，负载均衡器将用户的请求转发到了A服务器上，如果负载均衡器设置了粘性Session的话，那么用户以后的每次请求都会转发到A服务器上，相当于把用户和A服务器粘到了一块，这就是粘性Session机制。</p>
<p><strong>优点</strong>：简单，不需要对session做任何处理。</p>
<p><strong>缺点</strong>：缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的session信息都将失效。</p>
<p><strong>适用场景</strong>：发生故障对客户产生的影响较小；服务器发生故障是低概率事件。</p>
<p><strong>实现方式</strong>：以Nginx为例，在upstream模块配置ip_hash属性即可实现粘性Session。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream mycluster&#123;</span><br><span class="line">    #这里添加的是上面启动好的两台Tomcat服务器</span><br><span class="line">    ip_hash;#粘性Session</span><br><span class="line">     server 192.168.22.229:8080 weight=1;</span><br><span class="line">     server 192.168.22.230:8080 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>服务器session复制</strong></p>
<p><strong>原理</strong>：任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。</p>
<p><strong>优点</strong>：可容错，各个服务器间session能够实时响应。</p>
<p><strong>缺点</strong>：会对网络负荷造成一定压力，如果session量大的话可能会造成网络堵塞，拖慢服务器性能。</p>
<p><strong>实现方式</strong>：</p>
<p>① 设置tomcat ，server.xml 开启tomcat集群功能</p>
<p><img src="/2022/07/12/%E5%88%86%E5%B8%83%E5%BC%8FSession%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/80CB811C-CC17-4a43-A2E9-9324813A4B0C.png"></p>
</li>
</ul>
<p>​        Address:填写本机ip即可，设置端口号，预防端口冲突。</p>
<p>​       ② 在应用里增加信息：通知应用当前处于集群环境中，支持分布式，在web.xml中添加选项</p>
<p>**session共享机制 ** <strong>基于redis存储session方案</strong></p>
<p>基于redis存储session方案流程示意图</p>
<p><img src="/2022/07/12/%E5%88%86%E5%B8%83%E5%BC%8FSession%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2019070810495327.png"></p>
<p>引入pom依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-data-starter-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：</p>
<ul>
<li><p>这是企业中使用的最多的一种方式</p>
</li>
<li><p>spring为我们封装好了spring-session，直接引入依赖即可</p>
</li>
<li><p>数据保存在redis中，无缝接入，不存在任何安全隐患</p>
</li>
<li><p>redis自身可做集群，搭建主从，同时方便管理</p>
</li>
</ul>
<p><strong>缺点</strong>：多了一次网络调用，web容器需要向redis访问</p>
<p><strong>总结</strong>：一般会将web容器所在的服务器和redis所在的服务器放在同一个机房，减少网络开销，走内网进行连接 </p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>Session</category>
      </categories>
      <tags>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式定时器解决方案</title>
    <url>/2022/07/19/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E5%99%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h4 id="背景问题"><a href="#背景问题" class="headerlink" title="背景问题"></a>背景问题</h4><p>项目同时部署在多台集群机器上，因此到达指定的定时时间时，<strong>多台机器上的定时器可能会同时启动，造成重复数据或者程序异常等问题</strong></p>
<h4 id="一般的解决方案"><a href="#一般的解决方案" class="headerlink" title="一般的解决方案"></a>一般的解决方案</h4><h5 id="固定执行定时任务的机器"><a href="#固定执行定时任务的机器" class="headerlink" title="固定执行定时任务的机器"></a><strong>固定执行定时任务的机器</strong></h5><p>在多台机器中选择一台执行定时任务，<strong>每次执行的时候回判断当前机器和指定的机器是否一致</strong>或者启动时就指定好执行机器</p>
<p>优缺点：这种方法是可以有效避免多次执行的情况，，但是最明显的缺点就是<strong>单点故障问题</strong>，如果你指定的机器出现了宕机，，任务就不会执行了，业务逻辑就会奔溃</p>
<h5 id="ShedLock"><a href="#ShedLock" class="headerlink" title="ShedLock"></a><strong>ShedLock</strong></h5><p><strong>通过对公用的数据库中的某个表进行记录和加锁，使得同一时间点只有第一个执行定时任务并成功在数据库表中写入相应记录的节点能够成功执行而其他节点直接跳过该任务。</strong></p>
<p><strong>ShedLock</strong>：分布式环境中使用的定时任务框架，用于解决在分布式环境中的多个实例的相同定时任务在同一时间点重复执行的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;net.javacrumbs.shedlock&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;shedlock-spring&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">0.18</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"><span class="keyword">import</span> net.javacrumbs.shedlock.core.SchedulerLock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0/10 0 * * ?&quot;)</span></span><br><span class="line"><span class="meta">@SchedulerLock(name = &quot;scheduledTaskName&quot;, lockAtMostFor = 60 * 1000, lockAtLeastFor = 60 * 1000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduledTask</span><span class="params">()</span> &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;scheduledTask&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shedlockd的优点：<strong>通过注解的方式</strong>，把所有的一切都交给框架处理，使得<strong>代码不会受到影响</strong>，更加符合<strong>非侵入式</strong>编程的思想，使得代码更加简洁明了。</p>
<p>详细参考：<a href="https://blog.csdn.net/RenshenLi/article/details/121643790">https://blog.csdn.net/RenshenLi/article/details/121643790</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> shedlock (</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8mb4_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  lock_until <span class="type">timestamp</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  locked_at <span class="type">timestamp</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>(<span class="number">3</span>),</span><br><span class="line">  locked_by <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (name)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_bin;</span><br></pre></td></tr></table></figure>

<p>尝试向shedlock表插入一条记录，而name作为主键，如果不存在相同名称的锁，则插入记录，并成功占用该锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shedlock(name, lock_until, locked_at, locked_by) </span><br><span class="line"><span class="keyword">VALUES</span>(:name, :lockUntil, :now, :lockedBy)</span><br></pre></td></tr></table></figure>

<p>如果已经存在同名的锁，则将违反主键唯一约束，插入失败，此时会尝试筛选出shedlock表中锁名称相同并且已经释放（lock_until&lt;当前时间）的记录，如果有符合条件的，则更新该记录，并成功占用该锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> shedlock <span class="keyword">SET</span> lock_until <span class="operator">=</span> :lockUntil, locked_at <span class="operator">=</span> :now, </span><br><span class="line">locked_by <span class="operator">=</span> :lockedBy <span class="keyword">WHERE</span> name <span class="operator">=</span> :name <span class="keyword">AND</span> lock_until <span class="operator">&lt;=</span> :now</span><br></pre></td></tr></table></figure>

<p>释放锁lock.get().unlock()</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> shedlock <span class="keyword">SET</span> lock_until <span class="operator">=</span> :unlockTime <span class="keyword">WHERE</span> name <span class="operator">=</span> :name</span><br></pre></td></tr></table></figure>

<h5 id="Redis-过期时间和分布式锁"><a href="#Redis-过期时间和分布式锁" class="headerlink" title="Redis 过期时间和分布式锁"></a>Redis 过期时间和分布式锁</h5><h6 id="setnx"><a href="#setnx" class="headerlink" title="setnx"></a>setnx</h6><p>为你的定时器在<strong>Redis中定义一个键值对，可以用项目名称和服务器ip</strong>，<strong>执行任务前先从Redis中读取键，若没有值代表任务未被执行，同样的该台机器先更新redis，再触发定时任务。由于Redis存在过期机制，因此可以设置过期时间保证下次判断正常</strong></p>
<p>优缺点：该方法个人比较推荐，简单，对业务逻辑的改变也会少很多，只需要在原来的定时器上加上简单判断即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoInsertVuserToGroupBuying</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 */10 * * * ?&quot;)</span>  <span class="comment">//定时器10分钟一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先判断redis中是否有锁记录,如果能设值成功,代表拿到锁，不能设值成功就是锁还没释放</span></span><br><span class="line">        <span class="keyword">if</span>(redisTemplate.opsForValue().setIfAbsent(key, value))&#123;</span><br><span class="line">            <span class="comment">//设值成功后,设置锁超时时间 (我这里是9分钟)</span></span><br><span class="line">            redisTemplate.expire(key, <span class="number">9</span>, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            dojob();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="ZSet-实现方式"><a href="#ZSet-实现方式" class="headerlink" title="ZSet 实现方式"></a><strong>ZSet 实现方式</strong></h6><p>将<strong>定时任务存放到 ZSet 集合</strong>中，并且<strong>将过期时间存储到 ZSet 的 Score 字段中</strong>，然后通过一个无线循环来判断当前时间内是否有需要执行的定时任务，如果有则进行执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zrange zs1 <span class="number">0</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h6 id="键空间通知"><a href="#键空间通知" class="headerlink" title="键空间通知"></a><strong>键空间通知</strong></h6><p>给所有的定时任务设置一个过期时间，等到了过期之后，我们<strong>通过订阅过期消息就能感知到定时任务需要被执行了</strong>，此时我们执行定时任务即可。</p>
<p>默认情况下 Redis 是不开启<strong>键空间通知</strong>的，需要我们通过 <strong>config set notify-keyspace-events Ex 的命令手动开启</strong>，开启之后定时任务的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPubSub;</span><br><span class="line"><span class="keyword">import</span> utils.JedisUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_TOPIC</span> <span class="operator">=</span> <span class="string">&quot;__keyevent@0__:expired&quot;</span>; <span class="comment">// 订阅频道名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 执行定时任务</span></span><br><span class="line">        doTask(jedis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅过期消息，执行定时任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doTask</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">        <span class="comment">// 订阅过期消息</span></span><br><span class="line">        jedis.psubscribe(<span class="keyword">new</span> <span class="title class_">JedisPubSub</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPMessage</span><span class="params">(String pattern, String channel, String message)</span> &#123;</span><br><span class="line">                <span class="comment">// 接收到消息，执行定时任务</span></span><br><span class="line">                System.out.println(<span class="string">&quot;收到消息：&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, _TOPIC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="分布式任务的开源框架"><a href="#分布式任务的开源框架" class="headerlink" title="分布式任务的开源框架"></a><strong>分布式任务的开源框架</strong></h5><p><strong>Quartz</strong></p>
<p>方法：如果你的项目使用的是Spring自带有Task定时任务机制，quartz框架本身就是支持集群环境，可以搭建集群环境下的定时器，也能解决上述问题 不过需要配置11张数据库表</p>
<p>优缺点：该解决方案最大的问题是需要配置11张左右的数据库表，工作量非常大</p>
<p><strong>Elastic-job、XXL-JOB</strong></p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>定时器</category>
      </categories>
      <tags>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>如何避免死锁</title>
    <url>/2023/05/12/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h2 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h2><p>死锁的四个必要条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。</p>
<p>死锁产生的条件</p>
<ul>
<li><strong>互斥使用</strong>，即当资源被一个线程占用时，别的线程不能使用</li>
<li><strong>不可抢占</strong>，资源请求者不能强制从资源占有者手中抢夺资源，资源只能由占有者主动释放</li>
<li><strong>请求和保持</strong>，当资源请求者在请求其他资源的同时保持对原因资源的占有</li>
<li><strong>循环等待</strong>，多个线程存在环路的锁依赖关系而永远等待下去，例如T1占有T2的资源，T2占有T3的资源，T3占有T1的资源，这种情况可能会形成一个等待环路</li>
</ul>
<p>在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：</p>
<ul>
<li><p><strong>设置事务等待锁的超时时间</strong>。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 <code>innodb_lock_wait_timeout</code> 是用来设置超时时间的，默认值时 50 秒。</p>
<p>当发生超时后，就出现下面这个提示：</p>
<p><img src="/2023/05/12/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81/c296c1889f0101d335699311b4ef20a8.png" alt="图片"></p>
</li>
<li><p><strong>开启主动死锁检测</strong>。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑，默认就开启。</p>
<p>当检测到死锁后，就会出现下面这个提示：</p>
<p><img src="/2023/05/12/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81/f380ef357d065498d8d54ad07f145e09.png" alt="图片"></p>
<p>检测到死锁之后，选择插入更新或者删除的行数最少的事务回滚，基于 INFORMATION_SCHEMA.INNODB_TRX 表中的 trx_weight 字段来判断。如果插入更新或者删除的行数一样则回滚后面执行的那条事务。</p>
</li>
</ul>
<p>避免死锁:</p>
<p>有多种方法可以避免死锁，这里只介绍常见的三种：</p>
<ol>
<li>如果不同程序会并发存取多个表，<strong>尽量约定以相同的顺序访问表</strong>，可以大大降低死锁机会。</li>
<li>在同一个事务中，<strong>尽可能做到一次锁定所需要的所有资源，减少死锁产生概率</strong>；</li>
<li>对于非常容易产生死锁的业务部分，<strong>可以尝试使用升级锁粒度，通过表级锁定来减少死锁产生的概率</strong>；</li>
<li><strong>尽可能的缩小锁的范围，防止锁住的资源过多引发阻塞和饥饿</strong></li>
<li><strong>使用定时锁，比如Lock中的tryLock()</strong></li>
<li><strong>为表添加合理的索引</strong>。如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大</li>
<li><strong>降低隔离级别</strong>，如果业务允许</li>
<li><strong>按顺序申请锁</strong>，不会造成互相等待</li>
<li>在同一个事务中，<strong>尽可能做到一次锁定所需要的所有资源</strong>，减少死锁概率。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>死锁</category>
      </categories>
      <tags>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2022/08/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li><p><strong>保证一个类只有一个实例</strong>，并且提供一个访问该全局访问点</p>
</li>
<li><p>对于 Java 来说，<strong>单例模式可以保证在一个 JVM 中只存在单一实例</strong>。单例模式的应用场景主要有以下几个方面。</p>
</li>
<li><p><strong>需要频繁创建的一些类</strong>，使用单例可以<strong>降低系统的内存压力，减少 GC</strong>。</p>
</li>
<li><p>某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</p>
</li>
<li><p><strong>某些类创建实例时占用资源较多，或实例化耗时较长</strong>，且经常使用。</p>
</li>
<li><p><strong>某类需要频繁实例化，而创建的对象又频繁被销毁的时候</strong>，如<strong>多线程的线程池、网络连接池</strong>等。</p>
</li>
<li><p>频繁访问数据库或文件的对象。</p>
</li>
<li><p>对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。</p>
</li>
<li><p><strong>当对象需要被共享的场合</strong>。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等</p>
</li>
</ul>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>构造方法私有化，</li>
<li>获取方法公开化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// private私有 避免类在外部被实例化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="单例防止反射漏洞攻击"><a href="#单例防止反射漏洞攻击" class="headerlink" title="单例防止反射漏洞攻击"></a><strong>单例防止反射漏洞攻击</strong></h5>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123; </span><br><span class="line">         flag = !flag; </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;单例模式被侵犯！&quot;</span>); </span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>​                </p>
<h5 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a><strong>懒汉式单例</strong></h5><p><strong>类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能</strong></p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 懒汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="comment">// 保证 instance 在所有线程中同步 防止指令重排序</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton();</span></span><br><span class="line"><span class="comment">     * 这段代码其实是分为三步执行：</span></span><br><span class="line"><span class="comment">     * 1. 为 uniqueInstance 分配内存空间</span></span><br><span class="line"><span class="comment">     * 2. 初始化 uniqueInstance</span></span><br><span class="line"><span class="comment">     * 3. 将 uniqueInstance 指向分配的内存地址</span></span><br><span class="line"><span class="comment">     * 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。、</span></span><br><span class="line"><span class="comment">        指令重排在单线程环境下不会出现问题，</span></span><br><span class="line"><span class="comment">     * 但是在多线程环境下会导致一个线程获得还没有初始化的实例。</span></span><br><span class="line"><span class="comment">       例如，线程 T1 执行了 1 和 3，此时 T2 调用</span></span><br><span class="line"><span class="comment">     * getUniqueInstance() 后发现 uniqueInstance 不为空，</span></span><br><span class="line"><span class="comment">       因此返回 uniqueInstance，但此时</span></span><br><span class="line"><span class="comment">     * uniqueInstance 还未被初始化。</span></span><br><span class="line"><span class="comment">     * 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// private私有 避免类在外部被实例化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                      </p>
<h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a><strong>饿汉式</strong></h5><p><strong>类加载阶段完成实例的初始化</strong>   类加载机制保证线程安全</p>
<p>类初始化时,会立即加载该对象，线程天生安全,调用效率高</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungrySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton instance=<span class="keyword">new</span> <span class="title class_">HungrySingleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungrySingleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                       </p>
<h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a><strong>静态内部类</strong></h5><p><strong>类加载机制保证线程安全</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 静态内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInnerSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StaticInnerSingleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">StaticInnerSingleton</span> <span class="variable">staticInnerSingleton</span></span><br><span class="line">            <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StaticInnerSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StaticInnerSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.staticInnerSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​         </p>
<h5 id="枚举单例式"><a href="#枚举单例式" class="headerlink" title="枚举单例式"></a><strong>枚举单例式</strong></h5><p>使用枚举实现单例模式 优点:实现简单、调用效率高，<strong>枚举本身就是单例，由jvm从根本</strong></p>
<p><strong>上提供保障</strong>!<strong>避免通过反射和反序列化的漏洞， 缺点没有延迟加载</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 枚举单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumSingleton</span> &#123;</span><br><span class="line">    <span class="comment">//定义枚举</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">        INSTANCE;<span class="comment">// 枚举元素为单例</span></span><br><span class="line">        <span class="keyword">private</span> EnumSingleton enumSingleton;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Demo</span><span class="params">()</span>&#123;</span><br><span class="line">            enumSingleton=<span class="keyword">new</span> <span class="title class_">EnumSingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> EnumSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> enumSingleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Demo.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EnumSingleton</span> <span class="variable">s1</span> <span class="operator">=</span> EnumSingleton.getInstance();</span><br><span class="line">        <span class="type">EnumSingleton</span> <span class="variable">s2</span> <span class="operator">=</span> EnumSingleton.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="双重检测锁方式"><a href="#双重检测锁方式" class="headerlink" title="双重检测锁方式"></a><strong>双重检测锁方式</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检测锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleCheckLock</span> &#123;</span><br><span class="line">    <span class="comment">// volatile 防止指令重排序优化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckLock doubleCheckLock;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DoubleCheckLock</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此处检测doubleCheckLock == null,是为了防止当singletonMode已经初始化后，</span></span><br><span class="line"><span class="comment">     * 还会继续调用同步锁，造成不必要的损耗</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckLock <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="comment">// 加锁目的，防止多线程同时进入造成对象多次实例化</span></span><br><span class="line">        <span class="keyword">if</span>(doubleCheckLock == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 为了在null的情况下创建实例，防止不必要的损耗</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLock.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(doubleCheckLock == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DoubleCheckLock</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> doubleCheckLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/2022/09/01/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><p>定义： <strong>隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口</strong></p>
<p>简单来说，该模式就是把一些复杂的流程封装成一个接口供给外部用户更简单的使用</p>
<p>优点：</p>
<p><strong>松散耦合</strong>：使得客户端和子系统之间解耦，让子系统内部的模块功能更容易扩展和维护；</p>
<p><strong>简单易用</strong>：客户端根本不需要知道子系统内部的实现，或者根本不需要知道子系统内部的构成，它只需要<strong>跟Facade类（门面）交互</strong>即可</p>
<p><img src><img src="/2022/09/01/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20230318160214913.png" alt="image-20230318160214913"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2022/09/18/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>对上层的使用者<strong>隔离对象创建的过程</strong></p>
<p>对象创建的过程复杂，使用者不容易掌握</p>
<p>对象创建要满足某种条件</p>
<p>为了隔离一些复杂的过程，使得<strong>这些复杂的过程不向外暴露</strong></p>
<p>在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象，实现了创建者和调用者分离</p>
<p>利用工厂模式可以<strong>降低程序的耦合性</strong></p>
<h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>简单工厂模式相当于是一个工厂中有各种产品，创建在一个类中，客户无需知道具体产品的名称，</p>
<p><strong>只需要知道产品类所对应的参数即可</strong></p>
<p>优点：</p>
<p>工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。</p>
<p>客户端无需知道所创建具体产品的类名，只需知道参数即可。</p>
<p>缺点：</p>
<p><strong>简单工厂模式的工厂类单一，负责所有产品的创建，职责过重</strong>，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。</p>
<p>使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度</p>
<p>系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂</p>
<p>简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    MouseFactory mouseFactory=<span class="keyword">new</span> <span class="title class_">MouseFactory</span>();</span><br><span class="line">    <span class="type">IMouse</span> <span class="variable">mouse</span> <span class="operator">=</span> mouseFactory.createMouse(<span class="string">&quot;联想&quot;</span>);</span><br><span class="line">    mouse.getMouseInfo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MouseFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IMouse <span class="title function_">createMouse</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;联想&quot;</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LenoveMouse</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;惠普&quot;</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HPMouse</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMouse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMouseInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HPMouse</span> <span class="keyword">implements</span> <span class="title class_">IMouse</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMouseInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是惠普鼠标&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LenoveMouse</span> <span class="keyword">implements</span> <span class="title class_">IMouse</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMouseInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是联想鼠标&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="工厂模式-1"><a href="#工厂模式-1" class="headerlink" title="工厂模式"></a>工厂模式</h4><p><strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类</strong>，工厂模式使其创建过程延迟到子类进行</p>
<p>工厂模式也就是鼠标工厂是个父类，有生产鼠标这个接口。</p>
<p>戴尔鼠标工厂，惠普鼠标工厂继承它，可以分别生产戴尔鼠标，惠普鼠标。</p>
<p>生产哪种鼠标不再由参数决定，而是创建鼠标工厂时，由戴尔鼠标工厂创建。</p>
<p>后续直接调用鼠标工厂.生产鼠标()即可</p>
<p><img src="/2022/09/18/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20230319174520291.png" alt="image-20230319174520291"></p>
<p>优点：</p>
<p><strong>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程</strong>。</p>
<p>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。</p>
<p>典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</p>
<p>缺点：</p>
<p>类的个数容易过多，增加复杂度</p>
<p>增加了系统的抽象性和理解难度</p>
<p>抽象产品<strong>只能生产一种产品</strong>，此弊端可使用抽象工厂模式解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  IMouseFactory lenoveMouserFactory=<span class="keyword">new</span> <span class="title class_">LenoveMouserFactory</span>();</span><br><span class="line">  lenoveMouserFactory.createMouse();</span><br><span class="line">  <span class="comment">//实例化惠普鼠标工厂</span></span><br><span class="line">  IMouseFactory hpMouserFactory=<span class="keyword">new</span> <span class="title class_">HPMouserFactory</span>();</span><br><span class="line">  <span class="comment">//输出惠普鼠标品牌</span></span><br><span class="line">  hpMouserFactory.createMouse();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMouseFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createMouse</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HPMouserFactory</span> <span class="keyword">implements</span> <span class="title class_">IMouseFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createMouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是惠普工厂生产的惠普鼠标&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LenoveMouserFactory</span> <span class="keyword">implements</span> <span class="title class_">IMouseFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createMouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是联想工厂生产的联想鼠标&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>工厂方法模式中我们把生成产品类的时间延迟，就是通过对应的工厂类来生成对应的产品类，在这里我们就可以实现“开发-封闭”原则，无论加多少产品类，我们都不用修改原来类中的代码，而是<strong>通过增加工厂类来实现</strong>。但是这还是有缺点的，如果添加键盘产品，就需要添加键盘工厂类。假如我们要实现的产品接口不止一个，也就是有多个产品接口，不同产品接口有对应的产品族。什么是产品族呢？简单的理解就是，不同厂家的不仅有鼠标，还有键盘，音响，笔记本可以组成一个产品族。对于这种情况我们可以采用抽象工厂模式</p>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p><strong>抽象工厂模式也就是不仅生产鼠标，同时生产键盘</strong>。  也就是PC厂商是个父类，有生产鼠标，生产键盘两个接口。  戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。  创建工厂时，由戴尔工厂创建。  后续工厂.生产鼠标()则生产戴尔鼠标，工厂.生产键盘()则生产戴尔键盘</p>
<p><img src="/2022/09/18/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20230319174714596.png" alt="image-20230319174714596"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    PCFactory lenoveFactory=<span class="keyword">new</span> <span class="title class_">LenoveFactory</span>();</span><br><span class="line">    lenoveFactory.createMouse().getMouseInfo();</span><br><span class="line">    lenoveFactory.createKeyBo().getKeyBoInfo();</span><br><span class="line"></span><br><span class="line">    PCFactory hpFactory=<span class="keyword">new</span> <span class="title class_">HPFactory</span>();</span><br><span class="line">    hpFactory.createMouse().getMouseInfo();</span><br><span class="line">    hpFactory.createKeyBo().getKeyBoInfo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PCFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IMouse <span class="title function_">createMouse</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> IKeyBo <span class="title function_">createKeyBo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LenoveFactory</span> <span class="keyword">implements</span> <span class="title class_">PCFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IMouse <span class="title function_">createMouse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LenoveMouse</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IKeyBo <span class="title function_">createKeyBo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LenoveKeyBo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMouse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMouseInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LenoveMouse</span> <span class="keyword">implements</span> <span class="title class_">IMouse</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMouseInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是联想鼠标&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们增加华硕工厂，则我们需要增加华硕工厂，和戴尔工厂一样，继承PC厂商。</p>
<p>之后创建华硕鼠标，继承鼠标类。创建华硕键盘，继承键盘类即可</p>
<p><img src="/2022/09/18/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20230319174825751.png" alt="image-20230319174825751"></p>
<p>假设我们增加耳麦这个产品，则首先我们需要增加耳麦这个父类，再加上戴尔耳麦，惠普耳麦这两个子类。</p>
<p>之后在PC厂商这个父类中，增加生产耳麦的接口。最后在戴尔工厂，惠普工厂这两个类中，分别实现生产戴尔耳麦，惠普耳麦的功能</p>
<p><img src="/2022/09/18/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20230319174859556.png" alt="image-20230319174859556"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库范式</title>
    <url>/2022/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<p>范式是关系数据库理论的基础，也是我们在设计数据库结构过程中所要遵循的规则和指导方法</p>
<h4 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h4><p>数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保<strong>每一列的原子性   (值不可再分)</strong></p>
<h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><p>满足1NF后，要求表中的<strong>所有列，都必须依赖于主键</strong>，而不能有任何一列与主键没有关系，也就是说<strong>一个表只描述一件事情</strong>；(<strong>消除了部份依赖</strong>)</p>
<p>例如：订单表只描述订单相关的信息，所以所有字段都必须与订单id相关 产品表只描述产品相关的信息，所以所有字段都必须与产品id相 关；因此不能在一张表中同时出现订单信息与产品信息</p>
<h4 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h4><p>必须先满足第二范式（2NF），要求：表中的<strong>每一列只与主键直接相关而不是间接相关</strong>，（表中的每一列只能依赖于主键）；(<strong>消除了传递依赖</strong>)</p>
<p>订单表中需要有客户相关信息，在分离出客户表之后，订单表中只需要有一个用户id即可，而不能有其他的客户信息。因为其他的客户信息直接关联于用户id，而不是直接与订单id直接相关</p>
<h4 id="数据库五大约束"><a href="#数据库五大约束" class="headerlink" title="数据库五大约束"></a>数据库五大约束</h4><ul>
<li><strong>primary KEY</strong>:设置主键约束；</li>
<li><strong>UNIQUE</strong>：设置唯一性约束，不能有重复值；</li>
<li><strong>DEFAULT</strong> 默认值约束，height DOUBLE(3,2)DEFAULT 1.2 height不输入是默认为1,2</li>
<li><strong>NOT NULL</strong>：设置非空约束，该字段不能为空；</li>
<li><strong>FOREIGN key</strong> :设置外键约束</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库和缓存如何保持一致性</title>
    <url>/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<h2 id="数据库和缓存如何保证一致性？"><a href="#数据库和缓存如何保证一致性？" class="headerlink" title="数据库和缓存如何保证一致性？"></a>数据库和缓存如何保证一致性？</h2><h3 id="先更新数据库，还是先更新缓存？"><a href="#先更新数据库，还是先更新缓存？" class="headerlink" title="先更新数据库，还是先更新缓存？"></a>先更新数据库，还是先更新缓存？</h3><p><strong>由于引入了缓存，那么在数据更新时，不仅要更新数据库，而且要更新缓存，这两个更新操作存在前后的问题</strong>：</p>
<ul>
<li><p>先更新数据库，再更新缓存；</p>
</li>
<li><p>先更新缓存，再更新数据库；</p>
</li>
</ul>
<h4 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h4><p>举个例子，比如「请求 A 」和「请求 B 」两个请求，同时更新「同一条」数据，则可能出现这样的顺序：</p>
<p><img src="/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%E6%80%A7/8febac10b14bed16cb96d1d944cd08da.png" alt="图片"></p>
<p>A 请求先将数据库的数据更新为 1，然后在更新缓存前，请求 B 将数据库的数据更新为 2，紧接着也把缓存更新为 2，然后 A 请求更新缓存为 1。</p>
<p>此时，数据库中的数据是 2，而缓存中的数据却是 1，<strong>出现了缓存和数据库中的数据不一致的现象</strong>。</p>
<h4 id="先更新缓存，再更新数据库"><a href="#先更新缓存，再更新数据库" class="headerlink" title="先更新缓存，再更新数据库"></a>先更新缓存，再更新数据库</h4><p>那换成「<strong>先更新缓存，再更新数据库</strong>」这个方案，还会有问题吗？</p>
<p>依然还是存在并发的问题，分析思路也是一样。</p>
<p>假设「请求 A 」和「请求 B 」两个请求，同时更新「同一条」数据，则可能出现这样的顺序：</p>
<p><img src="/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%E6%80%A7/454a8228a6549176ad7e0484fba3c92b.png" alt="图片"></p>
<p>A 请求先将缓存的数据更新为 1，然后在更新数据库前，B 请求来了， 将缓存的数据更新为 2，紧接着把数据库更新为 2，然后 A 请求将数据库的数据更新为 1。</p>
<p>此时，数据库中的数据是 1，而缓存中的数据却是 2，<strong>出现了缓存和数据库中的数据不一致的现象</strong>。</p>
<p>所以，<strong>无论是「先更新数据库，再更新缓存」，还是「先更新缓存，再更新数据库」，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象</strong>。</p>
<h3 id="先更新数据库，还是先删除缓存？"><a href="#先更新数据库，还是先删除缓存？" class="headerlink" title="先更新数据库，还是先删除缓存？"></a>先更新数据库，还是先删除缓存？</h3><p>思考了一番后，决定在更新数据时，<strong>不更新缓存，而是删除缓存中的数据。然后，到读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。</strong></p>
<p>个策略是有名字的，是叫 <strong>Cache Aside 策略</strong>，中文是叫旁路缓存策略。</p>
<p>该策略又可以细分为「读策略」和「写策略」。</p>
<p><img src="/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%E6%80%A7/6e3db3ba2f829ddc14237f5c7c00e7ce.png" alt="图片"></p>
<p><strong>写策略的步骤：</strong></p>
<ul>
<li>更新数据库中的数据；</li>
<li>删除缓存中的数据。</li>
</ul>
<p><strong>读策略的步骤：</strong></p>
<ul>
<li>如果读取的数据命中了缓存，则直接返回数据；</li>
<li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。</li>
</ul>
<p>「写策略」的时候，又陷入更深层次的思考，到底该选择哪种顺序呢？</p>
<ul>
<li>先删除缓存，再更新数据库；</li>
<li>先更新数据库，再删除缓存。</li>
</ul>
<p>用并发的角度来分析，看看这两种方案哪个可以保证数据库与缓存的数据一致性。</p>
<h4 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h4><p>以用户表的场景来分析。</p>
<p>假设某个用户的年龄是 20，请求 A 要更新用户年龄为 21，所以它会删除缓存中的内容。这时，另一个请求 B 要读取这个用户的年龄，它查询缓存发现未命中后，会从数据库中读取到年龄为 20，并且写入到缓存中，然后请求 A 继续更改数据库，将用户的年龄更新为 21。</p>
<p><img src="/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%E6%80%A7/cc208c2931b4e889d1a58cb655537767.png" alt="图片"></p>
<p>最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库的数据不一致。</p>
<p>可以看到，<strong>先删除缓存，再更新数据库，在「读 + 写」并发的时候，还是会出现缓存和数据库的数据不一致的问题</strong></p>
<h4 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h4><p>继续用「读 + 写」请求的并发的场景来分析。</p>
<p>假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为 21，并且清空缓存。这时请求 A 把从数据库中读到的年龄为 20 的数据写入到缓存中。</p>
<p><img src="/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%E6%80%A7/1cc7401143e79383ead96582ac11b615.png" alt="图片"></p>
<p>最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库数据不一致。</p>
<p>从上面的理论上分析，先更新数据库，再删除缓存也是会出现数据不一致性的问题，<strong>但是在实际中，这个问题出现的概率并不高</strong>。</p>
<p><strong>因为缓存的写入通常要远远快于数据库的写入</strong>，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。</p>
<p>而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。</p>
<p>所以，<strong>「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的</strong>。</p>
<p>而且为了确保万无一失，还给缓存数据加上了「<strong>过期时间</strong>」，就算在这期间存在缓存数据不一致，有过期时间来兜底，这样也能达到最终一致。</p>
<p>但是「先更新数据库， 再删除缓存」其实是两个操作，前面的所有分析都是建立在这两个操作都能同时执行成功，存在问题，<strong>在删除缓存（第二个操作）的时候失败了，会导致缓存中的数据是旧值</strong>。</p>
<p>好在之前给缓存加上了过期时间，所以过一段时间才更新生效的现象，假设如果没有这个过期时间的兜底，那后续的请求读到的就会一直是缓存中的旧数据，这样问题就更大了。</p>
<p>所以新的问题来了，<strong>如何保证「先更新数据库 ，再删除缓存」这两个操作能执行成功？</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我们继续说点其他。</p>
<p>「先更新数据库，再删除缓存」的方案虽然保证了数据库与缓存的数据一致性，但是每次更新数据的时候，缓存的数据都会被删除，这样会对缓存的命中率带来影响。</p>
<p>所以，<strong>如果我们的业务对缓存命中率有很高的要求，我们可以采用「更新数据库 + 更新缓存」的方案，因为更新缓存并不会出现缓存未命中的情况</strong>。</p>
<p>但是这个方案前面我们也分析过，在两个更新请求并发执行的时候，会出现数据不一致的问题，因为更新数据库和更新缓存这两个操作是独立的，而我们又没有对操作做任何并发控制，那么当两个线程并发更新它们的话，就会因为写入顺序的不同造成数据的不一致。</p>
<p>所以我们得增加一些手段来解决这个问题，这里提供两种做法：</p>
<ul>
<li>在更新缓存前先加个<strong>分布式锁</strong>，保证同一时间只运行一个请求更新缓存，就会不会产生并发问题了，当然引入了锁后，对于写入的性能就会带来影响。</li>
<li>在更新完缓存时，给缓存加上较短的<strong>过期时间</strong>，这样即时出现缓存不一致的情况，缓存的数据也会很快过期，对业务还是能接受的。</li>
</ul>
<p>对了，针对「先删除缓存，再更新数据库」方案在「读 + 写」并发请求而造成缓存不一致的解决办法是「<strong>延迟双删</strong>」。</p>
<p>延迟双删实现的伪代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#删除缓存</span><br><span class="line">redis.delKey(X)</span><br><span class="line">#更新数据库</span><br><span class="line">db.update(X)</span><br><span class="line">#睡眠</span><br><span class="line">Thread.sleep(N)</span><br><span class="line">#再删除缓存</span><br><span class="line">redis.delKey(X)</span><br></pre></td></tr></table></figure>

<p>加了个睡眠时间，主要是为了确保请求 A 在睡眠的时候，请求 B 能够在这这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，然后请求 A 睡眠完，再删除缓存。</p>
<p>所以，请求 A 的睡眠时间就需要大于请求 B 「从数据库读取数据 + 写入缓存」的时间。</p>
<p>但是具体睡眠多久其实是个<strong>玄学</strong>，很难评估出来，所以这个方案也只是<strong>尽可能</strong>保证一致性而已，极端情况下，依然也会出现缓存不一致的现象。</p>
<p>因此，还是比较建议用「先更新数据库，再删除缓存」的方案。</p>
<h3 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h3><p>为了提升数据访问的性能，引入 Redis 作为 MySQL 缓存层，但是这件事情并不是那么简单，因为还要考虑 Redis 和 MySQL 双写一致性的问题。</p>
<p>经过一番周折，最终选用了「<strong>先更新数据库，再删缓存</strong>」的策略，原因是这个策略即使在并发读写时，也能最大程度保证数据一致性。</p>
<p>还搞了个兜底的方案，就是给缓存加上了过期时间。</p>
<p>本以为就这样不会在出现数据一致性的问题，结果将功能上线后，还是收到用户的投诉「说自己明明更新了数据，但是数据要过一段时间才生效」，客户接受不了。</p>
<p>立马就登录服务器去排查问题，查看日志后得知了原因。</p>
<p>「先更新数据库， 再删除缓存」其实是两个操作，这次客户投诉的问题就在于，<strong>在删除缓存（第二个操作）的时候失败了，导致缓存中的数据是旧值，而数据库是最新值</strong>。</p>
<p>好在之前给缓存加上了过期时间，所以才会出现客户说的过一段时间才更新生效的现象，假设如果没有这个过期时间的兜底，那后续的请求读到的就会一直是缓存中的旧数据，这样问题就更大了。</p>
<p>所以新的问题来了，<strong>如何保证「先更新数据库 ，再删除缓存」这两个操作能执行成功？</strong></p>
<h3 id="如何保证两个操作都能执行成功？"><a href="#如何保证两个操作都能执行成功？" class="headerlink" title="如何保证两个操作都能执行成功？"></a>如何保证两个操作都能执行成功？</h3><p>这次用户的投诉是因为在删除缓存（第二个操作）的时候失败了，导致缓存还是旧值，而数据库是最新值，造成数据库和缓存数据不一致的问题，会对敏感业务造成影响。</p>
<p>举个例子，来说明下。</p>
<p>应用要把数据 X 的值从 1 更新为 2，先成功更新了数据库，然后在 Redis 缓存中删除 X 的缓存，但是这个操作却失败了，这个时候数据库中 X 的新值为 2，Redis 中的 X 的缓存值为 1，出现了数据库和缓存数据不一致的问题。</p>
<p><img src="/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%E6%80%A7/2a2ea2854bbc3ae8ae86d7da45fa32ee.png" alt="图片"></p>
<p>那么，后续有访问数据 X 的请求，会先在 Redis 中查询，因为缓存并没有 诶删除，所以会缓存命中，但是读到的却是旧值 1。</p>
<p>其实不管是先操作数据库，还是先操作缓存，只要第二个操作失败都会出现数据部一致的问题。</p>
<p>问题原因知道了，该怎么解决呢？有两种方法：</p>
<ul>
<li>重试机制。</li>
<li>订阅 MySQL binlog，再操作缓存。</li>
</ul>
<p>先来说第一种。</p>
<h5 id="重试机制"><a href="#重试机制" class="headerlink" title="#重试机制"></a><a href="https://www.xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6">#</a>重试机制</h5><p>我们可以引入<strong>消息队列</strong>，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。</p>
<ul>
<li>如果应用<strong>删除缓存失败</strong>，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是<strong>重试机制</strong>。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</li>
<li>如果<strong>删除缓存成功</strong>，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</li>
</ul>
<p>举个例子，来说明重试机制的过程。</p>
<p><img src="/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%E6%80%A7/a4440f0d572612e0832b903e4a62bd2b.png" alt="图片"></p>
<h5 id="订阅-MySQL-binlog，再操作缓存"><a href="#订阅-MySQL-binlog，再操作缓存" class="headerlink" title="订阅 MySQL binlog，再操作缓存"></a>订阅 MySQL binlog，再操作缓存</h5><p>「<strong>先更新数据库，再删缓存</strong>」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。</p>
<p>于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。</p>
<p>Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。</p>
<p>下图是 Canal 的工作原理：</p>
<p><img src="/2022/12/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%E6%80%A7/2ee2280e9f59b6b4879ebdec6eb0cf52.png" alt="图片"></p>
<p>所以，<strong>如果要想保证「先更新数据库，再删缓存」策略第二个操作能执行成功，我们可以使用「消息队列来重试缓存的删除」，或者「订阅 MySQL binlog 再操作缓存」，这两种方法有一个共同的特点，都是采用异步操作缓存。</strong></p>
<h2 id="为什么是删除缓存，而不是更新缓存呢？"><a href="#为什么是删除缓存，而不是更新缓存呢？" class="headerlink" title="为什么是删除缓存，而不是更新缓存呢？"></a>为什么是删除缓存，而不是更新缓存呢？</h2><p>删除一个数据，相比更新一个数据更加轻量级，出问题的概率更小。在实际业务中，缓存的数据可能不是直接来自数据库表，也许来自多张底层数据表的聚合。</p>
<p>比如商品详情信息，在底层可能会关联商品表、价格表、库存表等，如果更新了一个价格字段，那么就要更新整个数据库，还要关联的去查询和汇总各个周边业务系统的数据，这个操作会非常耗时。 从另外一个角度，不是所有的缓存数据都是频繁访问的，更新后的缓存可能会长时间不被访问，所以说，从计算资源和整体性能的考虑，更新的时候删除缓存，等到下次查询命中再填充缓存，是一个更好的方案。</p>
<p>系统设计中有一个思想叫 Lazy Loading，适用于那些加载代价大的操作，删除缓存而不是更新缓存，就是懒加载思想的一个应用。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>更新一条记录的流程</title>
    <url>/2023/07/21/%E6%9B%B4%E6%96%B0%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="更新一条记录的流程"><a href="#更新一条记录的流程" class="headerlink" title="更新一条记录的流程"></a>更新一条记录的流程</h2><p>具体更新一条记录 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 的流程如下:</p>
<ol>
<li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：<ul>
<li>如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li>
<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li>
</ul>
</li>
<li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul>
<li>如果一样的话就不进行后续更新流程；</li>
<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li>
</ul>
</li>
<li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li>
<li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>（Write-Ahead Logging）技术，<strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li>
<li>至此，一条记录更新完了。</li>
<li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li>
<li>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：<ul>
<li><strong>prepare 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li>
<li><strong>commit 阶段</strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li>
</ul>
</li>
<li>至此，一条更新语句执行完成。</li>
</ol>
<p>redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？</p>
<p>写入 redo log 的方式使用了追加操作， 所以磁盘操作是<strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是<strong>随机写</strong>。</p>
<p>磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。</p>
<p>针对「顺序写」为什么比「随机写」更快这个问题，可以比喻为你有一个本子，按照顺序一页一页写肯定比写一个字都要找到对应页写快得多。</p>
<p>可以说这是 WAL 技术的另外一个优点：-<strong>MySQL 的写操作从磁盘的「随机写」变成了「顺序写」</strong>，提升语句的执行性能。这是因为 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上 。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2022/09/15/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>在策略模式（Strategy Pattern）中，<strong>一个类的行为或其算法可以在运行时更改</strong></p>
<h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p><strong>意图：定义一系列的算法,把它们一个个封装起来</strong>, 并且使它们可相互替换。</p>
<p><strong>主要解决：</strong>在有多种算法相似的情况下，<strong>使用 if…else 所带来的复杂和难以维护</strong>。</p>
<p><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。</p>
<p><strong>如何解决：将这些算法封装成一个一个的类，任意地替换</strong>。</p>
<p><strong>关键代码：实现同一个接口</strong>。</p>
<p><strong>应用实例：</strong> 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。</p>
<p><strong>优点：</strong> 1、<strong>算法可以自由切换</strong>。 2、<strong>避免使用多重条件判断</strong>。 3、<strong>扩展性良好</strong>。</p>
<p><strong>缺点：</strong> 1、<strong>策略类会增多</strong>。 2、所有策略类都需要对外暴露。</p>
<p><strong>使用场景：</strong> 1、如果在一个系统里面有许多类，它们之间的<strong>区别仅在于它们的行为</strong>，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、<strong>一个系统需要动态地在几种算法中选择一种</strong>。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p>
<p><strong>注意事项：</strong>如果一个系统的策略多于四个S就需要考虑使用混合模式，解决策略类膨胀的问题。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>我们将创建一个定义活动的 <em>Strategy</em> 接口和实现了 <em>Strategy</em> 接口的实体策略类。<em>Context</em> 是一个使用了某种策略的类。</p>
<p><em>StrategyPatternDemo</em>，我们的演示类使用 <em>Context</em> 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/08/strategy_pattern_uml_diagram.jpg" alt="策略模式的 UML 图"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建实现接口的实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperationAdd</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> num1 + num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperationSubtract</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> num1 - num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperationMultiply</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> num1 * num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建 Context 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">executeStrategy</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 Context 来查看当它改变策略 Strategy 时的行为变化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyPatternDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">OperationAdd</span>());    </span><br><span class="line">      System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">      context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">OperationSubtract</span>());      </span><br><span class="line">      System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">      context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">OperationMultiply</span>());    </span><br><span class="line">      System.out.println(<span class="string">&quot;10 * 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行程序，输出结果</span></span><br><span class="line"><span class="number">10</span> + <span class="number">5</span> = <span class="number">15</span></span><br><span class="line"><span class="number">10</span> - <span class="number">5</span> = <span class="number">5</span></span><br><span class="line"><span class="number">10</span> * <span class="number">5</span> = <span class="number">50</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2022/09/10/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><p>定义： <strong>将抽象部分与它的实现部分分离</strong>，使它们都可以独立地变化</p>
<p>主要解决：在有多种可能会变化的情况下，<strong>用继承会造成类爆炸问题</strong>，扩展起来不灵活</p>
<p>何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。</p>
<p>如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合</p>
<p>桥接模式通常适用于以下场景：</p>
<p><strong>当一个类存在两个独立变化的维度</strong>，且这两个维度都需要进行扩展时</p>
<p>当一个系统<strong>不希望使用继承或因为多层次继承导致系统类的个数急剧增加</strong>时</p>
<p>Jdk中用到的桥接模式：<strong>JDBC</strong>，JDBC连接数据库时：<strong>利用驱动来桥接</strong>，JDBC连接数据库时，<strong>在各个数据库之间进行切换，基本不需要动太多的代码</strong>，甚至丝毫不动，原因就是JDBC提供了统一接口，<strong>每个数据库提供各自的实现</strong>，用一个叫做<strong>数据库驱动的程序来桥接</strong>就行了</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载机制</title>
    <url>/2022/07/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h4 id="类加载的机制及过程"><a href="#类加载的机制及过程" class="headerlink" title="类加载的机制及过程"></a>类加载的机制及过程</h4><p>程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过<strong>加载、连接、初始化</strong>3个步骤来对该类进行初始化</p>
<p><img src="/2022/07/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/EE841B01A90E4862827B1F2ACBE90643.jpg"></p>
<h5 id="类装载的执行过程"><a href="#类装载的执行过程" class="headerlink" title="类装载的执行过程"></a>类装载的执行过程</h5><p>类装载分为以下 5 个步骤： </p>
<ul>
<li><strong>加载</strong>：根据查找路径找到相应的 <strong>class 文件然后读入到内存</strong>；</li>
<li><strong>验证</strong>：检查加载的 class 文件,确保<strong>加载的类信息符合JVM规范</strong>； </li>
<li><strong>准备</strong>：给类中的<strong>静态变量分配内存空间</strong>； 类变量（static变量）分配内存并设置类变量初始值的阶段</li>
<li><strong>解析</strong>：虚拟机将<strong>常量池中的符号引用替换成直接引用的过程</strong>。符号引用就理解为一个标示， 而在直接引用直接指向内存中的地址； </li>
<li><strong>初始化</strong>：<strong>对静态变量和静态代码块执行初始化工作</strong></li>
</ul>
<h5 id="类装载方式"><a href="#类装载方式" class="headerlink" title="类装载方式"></a><strong>类装载方式</strong></h5><ul>
<li><strong>隐式装载</strong>：程序在运行过程中当碰到<strong>通过new 等方式生成对象</strong>时，隐式调用类装载器加载对应的类到jvm中</li>
<li><strong>显式装载</strong>： 通过<strong>class.forname()等方法</strong>，显式加载需要的类</li>
</ul>
<h4 id="什么是类加载器？"><a href="#什么是类加载器？" class="headerlink" title="什么是类加载器？"></a>什么是类加载器？</h4><p><strong>类加载器就是把java类文件加载到虚拟机</strong>中，也就是说通过一个类的全限定名来获取描述该类的二进制字节流。Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。<strong>类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例</strong></p>
<h4 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h4><p>如果一个<strong>类加载器收到了类加载的请求</strong>，它首先<strong>不会自己去加载这个类</strong>，而是把这个请求<strong>委派给父类加载器</strong>去完成，每一层的类加载器都是如此，这样<strong>所有的加载请求都会被传送到顶层的启动类加载器</strong>中，只有当<strong>父加载无法完成加载请求</strong>（它的搜索范围中没找到所需的类）时，<strong>子加载器才会尝试去加载类</strong></p>
<h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ul>
<li>双亲委派模型保证了Java程序的稳定运行，可以<strong>避免类的重复加载</strong>（<strong>JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类</strong>）</li>
<li><strong>保证了 Java 的核心 API 不被篡改</strong>。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p><strong>父级加载器无法加载子级类加载器路径中的类</strong></p>
<p>有时候比较局限，<strong>有时候必须打破双亲委派机制</strong>，例如：<strong>SPI机制</strong></p>
<h4 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h4><ul>
<li><strong>启动类加载器(引导类加载器)（Bootstrap ClassLoader）</strong>，是虚拟机自身的一部分，用来加载<strong>Java_HOME/lib/目录</strong>中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库</li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong>：负责加载<strong>\lib\ext目录</strong>或Java. ext. dirs系统变量指定的路径中的所有类库</li>
<li><strong>应用程序类加载器(系统类加载器)（Application ClassLoader）</strong>：<strong>负责加载用户类路径（classpath）上的指定类库</strong>，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器</li>
<li><strong>用户自定义类加载器（程序员自己写的）：</strong>继承ClassLoader，继承ClassLoader</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>线上遇到了OOM</title>
    <url>/2022/09/24/%E7%BA%BF%E4%B8%8A%E9%81%87%E5%88%B0%E4%BA%86OOM/</url>
    <content><![CDATA[<h4 id="线上问题遇到了OOM"><a href="#线上问题遇到了OOM" class="headerlink" title="线上问题遇到了OOM"></a>线上问题遇到了OOM</h4><p><img src="/2022/09/24/%E7%BA%BF%E4%B8%8A%E9%81%87%E5%88%B0%E4%BA%86OOM/image-20230319170526058.png" alt="image-20230319170526059"></p>
<h4 id="为什么会-OOM"><a href="#为什么会-OOM" class="headerlink" title="为什么会 OOM"></a>为什么会 OOM</h4><p><strong>OOM 全称 “Out Of Memory”，表示内存耗尽</strong>。当 <strong>JVM 因为没有足够的内存来为对象分配空间，并且垃圾回收器也已经没有空间可回收时</strong>，就会抛出这个错误</p>
<ul>
<li><p><strong>分配过少</strong>：JVM 初始化内存小，业务使用了大量内存；或者不同 JVM 区域分配内存不合理</p>
</li>
<li><p><strong>代码漏洞</strong>：某一个对象被频繁申请，不用了之后却没有被释放，导致内存耗尽</p>
</li>
<li><p><strong>内存泄漏</strong>：<strong>申请使用完的内存没有释放，导致虚拟机不能再次使用该内存</strong>，此时这段内存就泄露了。因为申请者不用了，而又不能被虚拟机分配给别人用</p>
</li>
<li><p><strong>内存溢出：申请的内存超出了 JVM 能提供的内存大小</strong>，此时称之为溢出</p>
</li>
</ul>
<p>​                           <strong>内存泄漏持续存在，最后一定会溢出</strong>，两者是因果关系</p>
<h4 id="常见的-OOM"><a href="#常见的-OOM" class="headerlink" title="常见的 OOM"></a>常见的 OOM</h4><ul>
<li><strong>java.lang.OutOfMemoryError: PermGen space</strong></li>
</ul>
<p><strong>Java7 永久代（方法区）溢出</strong>，它用于存储已被<strong>虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。每当一个类初次加载的时候，元数据都会存放到永久代</p>
<p><strong>一般出现于大量 Class 对象或者 JSP 页面，或者采用 CgLib 动态代理技术导致</strong></p>
<p>通过 -XX：PermSize 和 -XX：MaxPermSize 修改方法区大小</p>
<p><strong>Java8 将永久代变更为元空间</strong>，报错：<strong>java.lang.OutOfMemoryError: Metadata space</strong>，元空间内存不足默认进行动态扩展</p>
<ul>
<li><strong>java.lang.StackOverflowError</strong></li>
</ul>
<p><strong>虚拟机栈溢出</strong>，一般是由于<strong>程序中存在 死循环或者深度递归调用 造成的</strong>。如果<strong>栈大小设置过小也会</strong>出现溢出，可以通过 <strong>-Xss 设置栈的大小</strong></p>
<p><strong>虚拟机抛出栈溢出错误，可以在日志中定位到错误的类、方法</strong></p>
<ul>
<li><strong>java.lang.OutOfMemoryError: Java heap space</strong></li>
</ul>
<p><strong>Java 堆内存溢出</strong>，溢出的原因一般由于 <strong>JVM 堆内存设置不合理或者内存泄漏导致</strong></p>
<p>如果是内存泄漏，可以通过工具查看泄漏对象到 GC Roots 的引用链。掌握了泄漏对象的类型信息以及 GC Roots 引用链信息，就可以精准地定位出泄漏代码的位置</p>
<p>如果不存在内存泄漏，就是内存中的对象确实都还必须存活着，那就应该检查虚拟机的堆参数（-Xmx 与 -Xms），查看是否可以将虚拟机的内存调大些</p>
<h4 id="查看-JVM-内存分布"><a href="#查看-JVM-内存分布" class="headerlink" title="查看 JVM 内存分布"></a><strong>查看 JVM 内存分布</strong></h4><p>ps命令找到对应进程的pid</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep 进程关键字  </span><br></pre></td></tr></table></figure>

<p>假设我们 Java 应用 PID 为 15162，输入命令查看 JVM 内存分布</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap -heap 15162</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[xxx@xxx ~]# jmap -heap 15162</span><br><span class="line">Attaching to process ID 15162, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.161-b12</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Mark Sweep Compact GC</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 40 # 最小堆使用比例</span><br><span class="line">   MaxHeapFreeRatio         = 70 # 最大堆可用比例</span><br><span class="line">   MaxHeapSize              = 482344960 (460.0MB) # 最大堆空间大小</span><br><span class="line">   NewSize                  = 10485760 (10.0MB) # 新生代分配大小</span><br><span class="line">   MaxNewSize               = 160759808 (153.3125MB) # 最大新生代可分配大小</span><br><span class="line">   OldSize                  = 20971520 (20.0MB) # 老年代大小</span><br><span class="line">   NewRatio                 = 2 # 新生代比例</span><br><span class="line">   SurvivorRatio            = 8 # 新生代与 Survivor 比例</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB) # 元空间大小</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB) # Compressed Class Space 空间大小限制</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB # 最大元空间大小</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB) # G1 单个 Region 大小</span><br><span class="line"></span><br><span class="line">Heap Usage:  # 堆使用情况</span><br><span class="line">New Generation (Eden + 1 Survivor Space): # 新生代</span><br><span class="line">   capacity = 9502720 (9.0625MB) # 新生代总容量</span><br><span class="line">   used     = 4995320 (4.763908386230469MB) # 新生代已使用</span><br><span class="line">   free     = 4507400 (4.298591613769531MB) # 新生代剩余容量</span><br><span class="line">   52.56726495150862% used # 新生代使用占比</span><br><span class="line">Eden Space:  </span><br><span class="line">   capacity = 8454144 (8.0625MB) # Eden 区总容量</span><br><span class="line">   used     = 4029752 (3.8430709838867188MB) # Eden 区已使用</span><br><span class="line">   free     = 4424392 (4.219429016113281MB) # Eden 区剩余容量</span><br><span class="line">   47.665996699370154% used  # Eden 区使用占比</span><br><span class="line">From Space: # 其中一个 Survivor 区的内存分布</span><br><span class="line">   capacity = 1048576 (1.0MB)</span><br><span class="line">   used     = 965568 (0.92083740234375MB)</span><br><span class="line">   free     = 83008 (0.07916259765625MB)</span><br><span class="line">   92.083740234375% used</span><br><span class="line">To Space: # 另一个 Survivor 区的内存分布</span><br><span class="line">   capacity = 1048576 (1.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 1048576 (1.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">tenured generation: # 老年代</span><br><span class="line">   capacity = 20971520 (20.0MB)</span><br><span class="line">   used     = 10611384 (10.119804382324219MB)</span><br><span class="line">   free     = 10360136 (9.880195617675781MB)</span><br><span class="line">   50.599021911621094% used</span><br><span class="line"></span><br><span class="line">10730 interned Strings occupying 906232 bytes.</span><br></pre></td></tr></table></figure>

<p><strong>通过查看 JVM 内存分配以及运行时使用情况，可以判断内存分配是否合理</strong></p>
<p>另外，可以<strong>在 JVM 运行时查看最耗费资源的对象</strong>，<strong>jmap -histo:live 15162 | more</strong></p>
<p><strong>jmap -histo:live 执行此命令，JVM 会先触发 GC，再统计信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap -histo:live 15162 | more</span><br></pre></td></tr></table></figure>

<p>JVM 内存对象列表按照对象所占内存大小排序</p>
<ul>
<li><p>instances：实例数</p>
</li>
<li><p>bytes：单位 byte</p>
</li>
<li><p>class name：类名</p>
<p><img src="/2022/09/24/%E7%BA%BF%E4%B8%8A%E9%81%87%E5%88%B0%E4%BA%86OOM/image-20230319171713310.png" alt="image-20230319171713310"></p>
</li>
</ul>
<h4 id="Dump-文件分析"><a href="#Dump-文件分析" class="headerlink" title="Dump 文件分析"></a><strong>Dump 文件分析</strong></h4><p>Dump 文件是 <strong>Java 进程的内存镜像</strong>，其中主要包括 <strong>系统信息、虚拟机属性、完整的线程 Dump、所有类和对象的状态 等信息</strong></p>
<p>当程序发生内存溢出或 GC 异常情况时，怀疑 JVM 发生了 内存泄漏，这时我们就可以导出 Dump 文件分析</p>
<p>JVM 启动参数配置添加以下参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=./（参数为 Dump 文件生成路径）</span><br></pre></td></tr></table></figure>

<p><strong>当 JVM 发生 OOM 异常自动导出 Dump 文件，文件名称默认格式：java_pid{pid}.hprof</strong></p>
<p>上面配置是在应用抛出 OOM 后自动导出 Dump，或者<strong>可以在 JVM 运行时导出 Dump 文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap -dump:file=[文件路径] [pid]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line">jmap -dump:file=./jvmdump.hprof 15162</span><br></pre></td></tr></table></figure>

<p>在本地写一个测试代码，验证下 OOM 以及分析 Dump 文件</p>
<p>设置 VM 参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Xms3m -Xmx3m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./</span><br><span class="line">设置 VM 参数：</span><br><span class="line">-Xms3m -Xmx3m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Object&gt; oomList = Lists.newArrayList();</span><br><span class="line">  	// 无限循环创建对象</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        oomList.add(new Object());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过报错信息得知，java heap space 表示 OOM 发生在堆区，并生成了 hprof 二进制文件在当前文件夹下</p>
<p><img src="/2022/09/24/%E7%BA%BF%E4%B8%8A%E9%81%87%E5%88%B0%E4%BA%86OOM/image-20230319172025932.png" alt="image-20230319172025932"></p>
<h5 id="JvisualVM-分析"><a href="#JvisualVM-分析" class="headerlink" title="JvisualVM 分析"></a><strong>JvisualVM 分析</strong></h5><p><strong>Dump 分析工具有很多</strong>，相对而言 <strong>JvisualVM、JProfiler、Eclipse Mat</strong>，使用人群更多一些。下面以 JvisualVM 举例分析 Dump 文件</p>
<p><strong>运行JvisualVM</strong>    ./bin/jvisualvm.exe</p>
<p><img src="/2022/09/24/%E7%BA%BF%E4%B8%8A%E9%81%87%E5%88%B0%E4%BA%86OOM/image-20230319172220985.png" alt="image-20230319172220985"></p>
<p><strong>载入Dump 文件</strong></p>
<p><img src="/2022/09/24/%E7%BA%BF%E4%B8%8A%E9%81%87%E5%88%B0%E4%BA%86OOM/image-20230319172238653.png" alt="image-20230319172238653"></p>
<p><strong>查看触发 OOM 的线程堆栈，清晰得知程序溢出的原因</strong></p>
<p><img src="/2022/09/24/%E7%BA%BF%E4%B8%8A%E9%81%87%E5%88%B0%E4%BA%86OOM/image-20230319172306804.png" alt="image-20230319172306804"></p>
<p><img src="/2022/09/24/%E7%BA%BF%E4%B8%8A%E9%81%87%E5%88%B0%E4%BA%86OOM/image-20230319172422965.png" alt="image-20230319172422965"></p>
<p><strong>查看 JVM 内存里保留大小最大的对象，可以自由选择排查个<img src="/2022/09/24/%E7%BA%BF%E4%B8%8A%E9%81%87%E5%88%B0%E4%BA%86OOM/image-20230319172456139.png" alt="image-20230319172456139">数</strong></p>
<p>点击对象还可以跳转具体的对象引用详情页面</p>
<p><img src="/2022/09/24/%E7%BA%BF%E4%B8%8A%E9%81%87%E5%88%B0%E4%BA%86OOM/image-20230319172519873.png" alt="image-20230319172519873"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>线上如遇到 JVM 内存溢出，可以分以下几步排查</p>
<ol>
<li><strong>jmap -heap 查看是否内存分配过小</strong></li>
<li><strong>jmap -histo 查看是否有明显的对象分配过多且没有释放情况</strong></li>
<li><strong>jmap -dump 导出 JVM 当前内存快照，使用 JDK 自带或 MAT 等工具分析快照</strong></li>
</ol>
]]></content>
      <categories>
        <category>线上故障</category>
      </categories>
      <tags>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2022/08/08/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><strong>观察者模式</strong></h4><p>需要对<strong>某个事物（类的对象等）的某种状态进行监测</strong>，当<strong>被观察者的状态改变的时候</strong>，需要进行某些相应的操作</p>
<p>分为抽象被观察者、具体被观察者、抽象观察者、具体观察者</p>
<p>情景：在学校中，老师和学生听到上课铃声之后开始上课</p>
<h5 id="抽象观察者"><a href="#抽象观察者" class="headerlink" title="抽象观察者"></a><strong>抽象观察者</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IOberver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="具体观察者"><a href="#具体观察者" class="headerlink" title="具体观察者"></a><strong>具体观察者</strong></h5><p>学生</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">IOberver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;铃声响，学生开始上课！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>老师</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">IOberver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;铃声响，老师开始讲课！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="抽象被观察者"><a href="#抽象被观察者" class="headerlink" title="抽象被观察者"></a><strong>抽象被观察者</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ISubject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加观察者方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(IOberver oberver)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除观察者方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(IOberver oberver)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知观察者方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyOberver</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="具体的被观察者"><a href="#具体的被观察者" class="headerlink" title="具体的被观察者"></a><strong>具体的被观察者</strong></h5><p>铃响</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RingBell</span> <span class="keyword">implements</span> <span class="title class_">ISubject</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> List&lt;IOberver&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(IOberver oberver)</span> &#123;</span><br><span class="line">        list.add(oberver);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(IOberver oberver)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!list.isEmpty())&#123;</span><br><span class="line">            list.remove(oberver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyOberver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(IOberver oberver:list)&#123;</span><br><span class="line">            oberver.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ring</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;铃声响了&quot;</span>);</span><br><span class="line">        <span class="comment">// 通知老师学生</span></span><br><span class="line">        notifyOberver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *创建观察者实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Teacher</span> <span class="variable">mathTeacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">    Student studentA=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    Student studentB=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *被观察者实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RingBell ringBell=<span class="keyword">new</span> <span class="title class_">RingBell</span>();</span><br><span class="line">    ringBell.add(mathTeacher);</span><br><span class="line">    ringBell.add(studentA);</span><br><span class="line">    ringBell.add(studentB);</span><br><span class="line"></span><br><span class="line">    ringBell.ring();</span><br><span class="line">&#125;</span><br><span class="line">铃声响了</span><br><span class="line">铃声响，老师开始讲课！！！</span><br><span class="line">铃声响，学生开始上课！！！</span><br><span class="line">铃声响，学生开始上课！！！ </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式是什么</title>
    <url>/2022/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h4 id="设计模式是什么"><a href="#设计模式是什么" class="headerlink" title="设计模式是什么"></a>设计模式是什么</h4><p>​        代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。<strong>设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案</strong>。这些解决方案是众多软件开发人员经过相当长的一段时间的<strong>试验和错误总结出来的</strong>。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2022/08/18/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p>过滤器和拦截器</p>
<p>责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过<strong>前一对象记住其下一个对象的引用而连成一条链</strong>；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<p>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，请求会自动进行传递。所以责任链将请求的发送者和请求的处理者解耦了。</p>
<p>职责链模式主要包含以下角色：</p>
<ul>
<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>
<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//组装责任链</span></span><br><span class="line">        Handler handlerA=<span class="keyword">new</span> <span class="title class_">ConcreteHandlerA</span>();</span><br><span class="line">        Handler handlerB=<span class="keyword">new</span> <span class="title class_">ConcreteHandlerB</span>();</span><br><span class="line">        handlerA.setNext(handlerB);</span><br><span class="line">        <span class="comment">//提交请求</span></span><br><span class="line">        handlerA.handleRequest(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *功能描述  抽象处理者角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span>  <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Handler next;</span><br><span class="line">    <span class="keyword">public</span> Handler <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Handler next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理请求的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(String requset)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  具体处理者角色A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandlerA</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(String requset)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(requset.equals(<span class="string">&quot;A&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体处理者A负责处理该请求！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(getNext()!=<span class="literal">null</span>)&#123;</span><br><span class="line">                getNext().handleRequest(requset);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有人处理该请求！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  具体处理者角色B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandlerB</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(String requset)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(requset.equals(<span class="string">&quot;B&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体处理者B负责处理该请求！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(getNext()!=<span class="literal">null</span>)&#123;</span><br><span class="line">                getNext().handleRequest(requset);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有人处理该请求！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2022/08/04/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得<strong>原本由于接口不兼容而不能一起工作的那些类能一起工作</strong></p>
<p>例如，</p>
<p>1、<strong>讲中文的人同讲英文的人对话时需要一个翻译</strong></p>
<p>2、系统需要使用现有的类，而此类的接口不符合系统的需要</p>
<p>适配器模式（Adapter）包含以下主要角色。</p>
<p><strong>目标（Target）接口</strong>：当前系统业务所期待的接口，它可以是抽象类或接口。</p>
<p><strong>适配者（Adaptee）类</strong>：它是被访问和适配的现存组件库中的组件接口。</p>
<p><strong>适配器（Adapter）类</strong>：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</p>
<h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a><strong>类适配器</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainRun</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Target target=<span class="keyword">new</span> <span class="title class_">ClassAdapter</span>();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *功能描述 目标接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 将被适配的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;适配者中的业务代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类适配器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassAdapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a><strong>对象适配器模式</strong></h4><p>对象适配器与类适配器不同之处在于，<strong>类适配器通过继承来完成适配</strong>，<strong>对象适配器则是通过关联</strong>来完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 对象适配器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainRun</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Adaptee adaptee=<span class="keyword">new</span> <span class="title class_">Adaptee</span>();</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObejectAdapter</span>(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 对象适配器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObejectAdapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObejectAdapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基本知识点</title>
    <url>/2022/07/19/MySQL%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h4 id="什么是MySQL"><a href="#什么是MySQL" class="headerlink" title="什么是MySQL?"></a>什么是MySQL?</h4><p>MySQL 是一种<strong>关系型数据库</strong>，<strong>开源免费</strong>的</p>
<h4 id="MyISAM和InnoDB区别？"><a href="#MyISAM和InnoDB区别？" class="headerlink" title="MyISAM和InnoDB区别？"></a>MyISAM和InnoDB区别？</h4><h5 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a><strong>MyISAM</strong></h5><ul>
<li>MyISAM 是 <strong>MySQL 5.5.5 之前的默认引擎</strong></li>
<li><strong>不支持事务</strong></li>
<li><strong>不支持外键</strong></li>
<li><strong>只支持表级锁</strong>，select，update，delete，insert语句都会给表自动加锁</li>
<li><strong>每个MyISAM在磁盘上存储成三个文件</strong>，.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)</li>
<li><strong>保存有表的总行数</strong>，如果select count(*) from table;会直接取出出该值，不需要进行全表扫描</li>
<li>如果执行<strong>大量的SELECT</strong>，MyISAM是更好的选择,因为不支持事务，相比innodb不需要维护事务的东西</li>
<li>B+ 树索引的<strong>叶子节点</strong>并不存储数据，而是<strong>存储数据的文件地址</strong></li>
</ul>
<h5 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a><strong>InnoDB</strong></h5><ul>
<li>从<strong>MySQL 5.5之后</strong>的版本中，<strong>默认的搜索引擎</strong>变更为InnoDB</li>
<li><strong>支持事务</strong>，具有事务(commit)、回滚(rollback)和崩溃修复能力</li>
<li><strong>支持外键</strong></li>
<li><strong>支持行级锁和表级锁</strong>,<strong>默认为行级锁</strong>，适用于高并发的频繁表修改，高并发是性能优于 MyISAM</li>
<li>所有的表都保存在<strong>同一个数据文件中</strong></li>
<li>没有保存表的总行数</li>
<li><strong>执行大量的INSERT或UPDATE</strong></li>
<li>B+ 树索引的<strong>叶子节点存储数据</strong></li>
</ul>
<p>如何选择？</p>
<p><strong>MyISAM适合</strong>：(1)做<strong>很多count 的计算</strong>；(2)插入不频繁，<strong>查询非常频繁</strong>；(3)<strong>没有事务。</strong></p>
<p><strong>InnoDB适合</strong>：(1)可靠性要求比较高，或者<strong>要求事务</strong>；(2)<strong>表更新和查询都相当的频繁</strong>，并且表锁定的机会比较大的情况。</p>
<h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务?"></a>什么是事务?</h4><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行</strong></p>
<h5 id="事务的四大特性-ACID"><a href="#事务的四大特性-ACID" class="headerlink" title="事务的四大特性(ACID)"></a>事务的四大特性(<strong>ACID</strong>)</h5><p><img src="/2022/07/19/MySQL%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/clipboard.png"></p>
<ul>
<li><strong>原子性</strong>（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性</strong>（Consistency）： 执行事务后，数据库从一个<strong>正确的状态变化到另一个正确的状态；</strong></li>
<li><strong>隔离性</strong>（Isolation）： 并发访问数据库时，一个用户的<strong>事务不被其他事务所干扰</strong>，各并发事务之间数据库是独立的；</li>
<li><strong>持久性</strong>（Durability）： 一个<strong>事务被提交</strong>之后。它对数据库中<strong>数据的改变是持久的</strong>，即使数据库发生故障也不应该对其有任何影响</li>
</ul>
<h5 id="并发事务带来哪些问题"><a href="#并发事务带来哪些问题" class="headerlink" title="并发事务带来哪些问题?"></a><strong>并发事务</strong>带来哪些问题?</h5><p>多个用户对同一数据进行操作</p>
<ul>
<li><strong>脏读</strong>（dirty read）：<strong>一个事务可以读取另一个尚未提交事务的修改数据</strong>。事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据</li>
<li><strong>丢失修改</strong>（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的<strong>修改结果就被丢失</strong>，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>
<li><strong>不可重复读</strong>（nonrepeatable read）：<strong>指在一个事务内多次读同一数据</strong>。在这个事务还没有结束时，另一个事务也访问该数据。在第一个事务中的两次读数据之间，<strong>由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样</strong>。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</li>
<li><strong>幻读</strong>（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现<strong>多了一些原本不存在的记录</strong>，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p>不可重复读和幻读区别：</p>
<p><strong>不可重复读的重点是修改</strong>比如多次读取一条记录发现其中某些列的值被修改</p>
<p><strong>幻读的重点在于新增或者删除</strong>比如多次读取一条记录发现记录增多或减少了</p>
<h5 id="事务隔离级别有哪些"><a href="#事务隔离级别有哪些" class="headerlink" title="事务隔离级别有哪些?"></a>事务隔离级别有哪些?</h5><p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li><strong>未提交读</strong>(Read Uncommitted)：允许脏读，也就是<strong>可能读取到其他会话中未提交事务修改的数据</strong></li>
<li><strong>提交读</strong>(Read Committed)：<strong>只能读取到已经提交的数据</strong>。<strong>Oracle</strong>等多数数据库<strong>默认</strong>都是该级别 (不重复读)</li>
<li><strong>可重复读</strong>(Repeated Read)：可重复读，<strong>InnoDB默认的隔离级别</strong> 。<strong>对同一字段的多次读取结果都是一致的</strong>，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><strong>串行读</strong>(Serializable)：完全串行化的读，<strong>每次读都需要获得表级共享锁</strong>，读写相互都会阻塞</li>
</ul>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p><strong>表级锁和行级锁对比</strong></p>
<ul>
<li><p><strong>表级锁： MySQL中锁定 粒度最大 的一种锁，</strong>对<strong>当前操作的整张表加锁</strong>，<strong>实现简单，资源消耗也比较少，加锁快，不会出现死锁</strong>。其锁定粒度最大，<strong>触发锁冲突的概率最高</strong>，<strong>并发度最低，</strong>MyISAM和 InnoDB引擎都支持表级锁。</p>
</li>
<li><p>行级锁： MySQL中锁定 <strong>粒度最小 的一种锁</strong>，只针对<strong>当前操作的行进行加锁</strong>。 行级锁能大大<strong>减少数据库操作的冲突</strong>。其<strong>加锁粒度最小，并发度高</strong>，但<strong>加锁的开销也最大，加锁慢，会出现死锁</strong></p>
</li>
</ul>
<h5 id="共享锁-S-和排他锁-X-的区别"><a href="#共享锁-S-和排他锁-X-的区别" class="headerlink" title="共享锁(S)和排他锁(X)的区别"></a>共享锁(S)和排他锁(X)的区别</h5><ul>
<li><strong>共享锁</strong>（S锁）：如果事务T对数据A加上共享锁后，则<strong>其他事务只能对A再加共享锁</strong>，不能加排他锁。获取共享锁的事务只能读数据，不能修改数据。</li>
<li><strong>排他锁</strong>（X锁）：如果事务T对数据A加上排他锁后，则<strong>其他事务不能再对A加任任何类型的封</strong>锁。获取排他锁的事务既能读数据，又能修改数据。</li>
</ul>
<p>​    innodb会对update,insert,delete语句自动加上排他锁</p>
<h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a><strong>意向锁</strong></h5><ul>
<li><p>意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。</p>
</li>
<li><p>如果自己<strong>需要一个共享锁</strong>，那么就在表上面添加一个**意向共享锁(IS)**。</p>
</li>
<li><p>而如果自己需要的是某行（或者某些行）上面<strong>添加一个排他锁</strong>的话，则先在表上面添加一个<strong>意向排他锁(IX)。</strong></p>
</li>
<li><p>意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在</p>
</li>
</ul>
<h5 id="死锁和避免死锁"><a href="#死锁和避免死锁" class="headerlink" title="死锁和避免死锁"></a>死锁和避免死锁</h5><p>InnoDB的<strong>行级锁是基于索引实现的</strong>，如果查询语句<strong>未命中任何索引</strong>，那么InnoDB会使用<strong>表级锁</strong></p>
<p>死锁的产生：不同于MyISAM总是一次性获得所需的全部锁，<strong>InnoDB的锁是逐步获得的</strong>，当两个事务都需要获得对方持有的锁，导致双方都在等待，这就产生了死锁</p>
<p>发生死锁后，<strong>InnoDB一般都可以检测到，并使一个事务释放锁回退</strong>，另一个则可以获取锁完成事务</p>
<p>检测到死锁之后，<strong>选择插入更新或者删除的行数最少的事务回滚</strong>，基于 INFORMATION_SCHEMA.INNODB_TRX 表中的 trx_weight 字段来判断。<strong>如果插入更新或者删除的行数一样则回滚后面执行的那条事务</strong>。</p>
<h5 id="避免死锁的方式"><a href="#避免死锁的方式" class="headerlink" title="避免死锁的方式"></a><strong>避免死锁的方式</strong></h5><ul>
<li><strong>为表添加合理的索引</strong>。如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大</li>
<li><strong>降低隔离级别</strong>，如果业务允许</li>
<li><strong>按顺序申请锁</strong>，不会造成互相等待</li>
<li>在同一个事务中，<strong>尽可能做到一次锁定所需要的所有资源</strong>，减少死锁概率。</li>
</ul>
<h4 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a><strong>大表优化</strong></h4><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<p>①<strong>限定数据的范围</strong>：务必禁止不带任何限制数据范围条件的查询语句，如<strong>分页，一个月的范围内</strong></p>
<p>②<strong>读/写分离</strong>：经典的数据库拆分方案，<strong>主库负责写，从库负责读</strong></p>
<p>③<strong>垂直分区</strong>：根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p>简单来说<strong>垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表</strong>。如图：</p>
<p><img src="/2022/07/19/MySQL%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/clipboard2.png"></p>
<p><strong>垂直拆分的优点</strong>： 可以使得<strong>列数据变小，在查询时减少读取的Block数，减少I/O次数</strong>。此外，垂直分区可以简化表的结构，易于维护。</p>
<p><strong>垂直拆分的缺点</strong>： <strong>主键会出现冗余</strong>，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会<strong>让事务变得更加复杂</strong></p>
<p>④<strong>水平分区</strong>：保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量</p>
<p><strong>水平拆分是指数据表行的拆分，可以把一张的表的数据拆成多张表来存放</strong></p>
<p>举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p><img src="/2022/07/19/MySQL%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/clipboard3.png"></p>
<p>分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好<strong>分库</strong> 。</p>
<p>缺点：<strong>分片事务难以解决 ，跨节点Join性能较差，逻辑复杂</strong></p>
<p><strong>数据库分片</strong>的两种常见方案：</p>
<ul>
<li><p><strong>客户端代理</strong>： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。当当网的 Sharding-JDBC 、阿里的TDDL</p>
</li>
<li><p><strong>中间件代理</strong>：<strong>在应用和数据中间加了一个代理层</strong>。分片逻辑统一维护在中间件服务中。<strong>Mycat</strong></p>
</li>
</ul>
<h4 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a><strong>数据库连接池</strong></h4><p>连接池是<strong>将已经创建好的连接保存在池中</strong>，当有<strong>请求</strong>来时，<strong>直接使用</strong>已经<strong>创建好的连接</strong>对数据库进行<strong>访问</strong>。这样<strong>省略了创建连接和销毁连接的过程</strong>。这样<strong>性能</strong>上得到了提高</p>
<p>基本原理是这样的：</p>
<ul>
<li><strong>建立数据库连接池对象</strong>（服务器启动）。</li>
<li>按照事先指定的参数<strong>创建初始数量的数据库连接</strong>（即：空闲连接数）。</li>
<li><strong>对于一个数据库访问请求，直接从连接池中得到一个连接</strong>。如果数据库连接池对象中没有空闲的连接，且连接数没有达到最大（即：最大活跃连接数），创建一个新的数据库连接。</li>
<li>存取数据库。</li>
<li>关闭数据库，释放所有数据库连接（此时的关闭数据库连接，并非真正关闭，而是<strong>将其放入空闲队列中</strong>。如实际空闲连接数大于初始空闲连接数则释放连接）。</li>
<li>释放数据库连接池对象（服务器停止、维护期间，释放数据库连接池对象，并释放所有连</li>
</ul>
<h4 id="一条SQL语句在MySQL中如何执行的？"><a href="#一条SQL语句在MySQL中如何执行的？" class="headerlink" title="一条SQL语句在MySQL中如何执行的？"></a><strong>一条SQL语句在MySQL中如何执行的？</strong></h4><ul>
<li><p><strong>连接器</strong>，连接到数据库，<strong>身份认证和权限相关</strong>(登录 MySQL 的时候)</p>
</li>
<li><p><strong>查询缓存</strong>，当mysql拿到查询语句时会先到查询缓存查看，之前是不是执行过这条语句（MySQL 8.0 版本后移除，因为这个功能不太实用）</p>
</li>
<li><p><strong>分析器</strong>  ，如果<strong>没有命中查询缓存，开始执行语句</strong>。<strong>mysql需要知道你要做什么</strong>，需要对SQL语句做解析。分析器先会做<strong>“词法分析</strong>”，然后<strong>语法分析</strong>，是否满足mysql语法</p>
</li>
<li><p><strong>优化器</strong>，在开始执行之前还先经过优化器的处理，决定使用哪个索引，多表关联的时候决定各个表的连接顺序等，<strong>按照 MySQL 认为最优的方案去执行</strong></p>
</li>
<li><p><strong>执行器</strong>，mysql通过<strong>分析器知道了要做什么，通过优化器知道该怎么做</strong>，于是进入执行器阶段开始执行语句，然后从存储引擎返回数据</p>
<p><img src="/2022/07/19/MySQL%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/45d7b28b3b1d0278252faff9d05de521.jpg"></p>
</li>
</ul>
<p>sql更新语句的执行过程：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_student A <span class="keyword">set</span> A.age<span class="operator">=</span><span class="string">&#x27;19&#x27;</span> <span class="keyword">where</span> A.name<span class="operator">=</span><span class="string">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>执行更新的时候肯定要记录日志，这就会引入日志模块了，MySQL 自带的日志模块式 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 <strong>InnoDB 引擎</strong>还自带了一个日志模块 <strong>redo log（重做日志）</strong></p>
<ul>
<li><p><strong>先查询到张三这一条数据，如果有缓存，也是会用到缓存</strong>。</p>
</li>
<li><p>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，<strong>写入这一行数据</strong>，InnoDB 引擎把<strong>数据保存在内存</strong>中，<strong>同时记录 redo log</strong>，此时 <strong>redo log 进入 prepare 状态</strong>，然后告诉执行器，执行完成了，随时可以提交。</p>
</li>
<li><p><strong>执行器收到通知后记录 binlog</strong>，然后调用引擎接口，<strong>提交 redo log 为提交状态</strong>。</p>
</li>
<li><p>更新完成</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/19/MySQL%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/clipboard4.png"></p>
<p><strong>一个 SQL 执行的很慢的原因？</strong></p>
<p>当<strong>内存数据页</strong>跟<strong>磁盘数据页内容不一致</strong>的时候，我们称这个<strong>内存页为“脏页”</strong>。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“<strong>干净页</strong>”。</p>
<p>插入一条数据、或者要更新一条数据的时候，我们知道数据库会在内存中把对应字段的数据更新了，但是更新之后，这些<strong>更新的字段</strong>并<strong>不会马上同步持久化到磁盘</strong>中去，而是把这些<strong>更新的记录写入到 redo log 日记</strong>中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到磁盘中去</p>
<p>分两种情况讨论</p>
<p>①<strong>大多数情况下很正常，偶尔很慢</strong>，则有如下原因：</p>
<ul>
<li><strong>数据库在刷新脏页</strong>，例如 redo log 写满了需要同步到磁盘</li>
<li><strong>执行的时候，遇到锁，如表锁、行锁</strong></li>
</ul>
<p>②<strong>SQL 语句一直执行的很慢</strong></p>
<ul>
<li><strong>没有用上索引</strong>：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引</li>
<li><strong>数据库选错了索引</strong></li>
</ul>
<h4 id="MySQL-Explain命令"><a href="#MySQL-Explain命令" class="headerlink" title="MySQL Explain命令"></a>MySQL <strong>Explain命令</strong></h4><p>explain这个命令来<strong>查看SQL语句的执行计划，有没有使用上了索引，有没有做全表扫描</strong></p>
<p>EXPALIN<strong>只能解释SELECT操作</strong>，其他操作要重写为SELECT后查看执行计划</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看SQL是否使用索引，前面加上explain即可</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Jefabc&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h5 id="为什么不对表中的每一个列创建一个索引？"><a href="#为什么不对表中的每一个列创建一个索引？" class="headerlink" title="为什么不对表中的每一个列创建一个索引？"></a>为什么不对表中的每一个列创建一个索引？</h5><ul>
<li>当对表中的<strong>数据进行增加、删除和修改</strong>的时候，<strong>索引也要动态的维护</strong>，这样就降低了数据的维护速度。</li>
<li><strong>索引需要占物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li><strong>创建索引和维护索引要耗费时间</strong>，这种时间随着数据量的增加而增加</li>
</ul>
<p>不建议列上允许为空。最好限制not null，因为null需要更多的存储空间并且null值无法参与某些运算</p>
<h5 id="使用索引的注意事项"><a href="#使用索引的注意事项" class="headerlink" title="使用索引的注意事项"></a><strong>使用索引的注意事项</strong></h5><ul>
<li><p>在<strong>经常需要搜索的列</strong>上，可以加快搜索的速度；</p>
</li>
<li><p>在经常使用在<strong>WHERE子句中的列上面创建索引</strong>，加快条件的判断速度。</p>
</li>
<li><p>在经常需要<strong>排序的列</strong>上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p>
</li>
<li><p>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</p>
</li>
<li><p>在经常用在<strong>连接的列</strong>上，这些列主要是一些外键，可以加快连接的速度；</p>
</li>
<li><p>避免 where 子句中对字段施加函数，这会造成无法命中索引。</p>
</li>
<li><p>在使用InnoDB时<strong>使用与业务无关的自增主键作为主键</strong>，即使用逻辑主键，而不要使用业务主键。</p>
</li>
</ul>
<h5 id="不合适创建索引的字段"><a href="#不合适创建索引的字段" class="headerlink" title="不合适创建索引的字段"></a><strong>不合适创建索引的字段</strong></h5><ul>
<li><strong>被频繁更新的字段</strong>应该慎重建立索引</li>
<li><strong>不被经常查询的字段</strong>没有必要建立索引</li>
<li>尽可能的考虑<strong>建立联合索引</strong>而不是单列索引</li>
<li>注意<strong>避免冗余索引</strong></li>
</ul>
<h4 id="MySQL优化方法"><a href="#MySQL优化方法" class="headerlink" title="MySQL优化方法"></a>MySQL优化方法</h4><ul>
<li>EXPLAIN，<strong>善用EXPLAIN查看SQL执行计划</strong></li>
</ul>
<p><strong>type列，连接类型</strong>。一个好的SQL语句至少要达到range级别。杜绝出现all级别。</p>
<p>ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）</p>
<p><strong>key列</strong>，使用到的索引名。如果没有选择索引，值是NULL。可以采取强制索引方式。</p>
<p>key_len列，索引长度。</p>
<p><strong>rows列，扫描行数</strong>。该值是个预估值。</p>
<p>extra列，详细说明。注意，常见的不太友好的值，如下：Using filesort，Using temporary。</p>
<ul>
<li><p><strong>避免 SELECT *</strong> ，SELECT语句务必指明字段名称</p>
</li>
<li><p><strong>当只需要一条数据的时候，使用limit 1</strong>（为了使EXPLAIN中type列达到const类型）</p>
</li>
<li><p><strong>IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。</strong></p>
</li>
<li><p>替代not exists的SQL语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#原<span class="keyword">SQL</span>语句：</span><br><span class="line"><span class="keyword">select</span> colname … <span class="keyword">from</span> A表 <span class="keyword">where</span> a.id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> b.id <span class="keyword">from</span> B表)</span><br><span class="line">#高效的<span class="keyword">SQL</span>语句</span><br><span class="line"><span class="keyword">select</span> colname … <span class="keyword">from</span> A表 <span class="keyword">Left</span> <span class="keyword">join</span> B表 </span><br><span class="line"><span class="keyword">on</span> <span class="keyword">where</span> a.id <span class="operator">=</span> b.id <span class="keyword">where</span> b.id <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>避免使用 TEXT,BLOB 数据类型</strong>：<strong>建议把 BLOB 或是 TEXT 列分离到单独的扩展表中</strong></p>
</li>
<li><p><strong>尽可能把所有列定义为 NOT NUL</strong>L，索引 <strong>NULL 列需要额外的空间来保存</strong>，所以要占用更多的空间</p>
</li>
<li><p><strong>禁止在数据库中存储图片,文件等大的二进制数据</strong>，通常存储于文件服务器，数据库<strong>只存储文件地址信息</strong></p>
</li>
<li><p>对应同一列进行 or 判断时，使用 <strong>in 代替 or</strong>，in 操作可以<strong>更有效的利用索引</strong>，or 大多数情况下很少能利用到索引</p>
</li>
<li><p>很多时候用 <strong>exists 代替 in</strong> 是一个好的选择：</p>
</li>
<li><p>对于<strong>连续的数值，能用 between 就不要用 in</strong> 了</p>
</li>
<li><p><strong>WHERE 从句中禁止对列进行函数转换和计算</strong>，对列进行函数转换或计算时会<strong>导致无法使用索引</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">比如：</span><br><span class="line"><span class="keyword">select</span> user_id,user_project <span class="keyword">from</span> user_base <span class="keyword">where</span> age<span class="operator">*</span><span class="number">2</span><span class="operator">=</span><span class="number">36</span>;</span><br><span class="line">中对字段就行了算术运算，这会造成引擎放弃使用索引，建议改成：</span><br><span class="line"><span class="keyword">select</span> user_id,user_project <span class="keyword">from</span> user_base <span class="keyword">where</span> age<span class="operator">=</span><span class="number">36</span><span class="operator">/</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>在<strong>明显不会有重复值</strong>时使用 <strong>UNION ALL 而不是 UNION</strong>，<strong>UNION</strong> 会把两个结果集的所有数据放到<strong>临时表中后再进行去重操作</strong></p>
</li>
<li><p>联合索引来说，要遵守<strong>最左前缀法则</strong></p>
</li>
<li><p>尽量使用inner join，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表</p>
</li>
<li><p>利用<strong>小表去驱动大表</strong></p>
</li>
<li><p>应尽量避免在 <strong>where 子句中使用!=或&lt;&gt;操作符</strong>，否则将引擎放弃使用索引而进行全表扫描</p>
</li>
<li><p><strong>不建议使用%前缀模糊查询</strong>，例如LIKE“%name”或者LIKE“%name%”，这种查询会导致索引失效而进行全表扫描，  若要提高效率，可以考虑全文检索</p>
</li>
<li><p><strong>使用合理的分页方式</strong>以提高分页的效率</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> product limit <span class="number">866613</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>优化的方法如下：可以取前一页的最大行数的id，然后根据这个最大的id来限制下一页的起点。比如此列中，上一页最大的id是866612。SQL可以采用如下的写法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> product <span class="keyword">where</span> id<span class="operator">&gt;</span> <span class="number">866612</span> limit <span class="number">20</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>禁止使用 order by rand() 进行随机排序</strong>，order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，<strong>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</strong></p>
</li>
<li><p>必要时可以<strong>使用force index来强制查询走某个索引</strong>，系统是有可能走全表扫描而不走索引的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t force index(a) <span class="keyword">where</span> c <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">and</span> c <span class="operator">&lt;</span> <span class="number">100000</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用连接(JOIN)来代替子查询</strong></p>
</li>
<li><p>**不要用字符串存储日期:**字符串占用的空间更大！字符串存储的日期比较效率比较低（逐个字符进行比对）</p>
</li>
</ul>
<h4 id="Datetime-和-Timestamp-之间抉择"><a href="#Datetime-和-Timestamp-之间抉择" class="headerlink" title="Datetime 和 Timestamp 之间抉择"></a><strong>Datetime 和 Timestamp</strong> 之间抉择</h4><p>通常我们都会<strong>首选 Timestamp</strong></p>
<ul>
<li><strong>DateTime 类型是没有时区信息的（时区无关）</strong>：DateTime 类型保存的时间都是<strong>当前会话所设置的时区对应的时间</strong></li>
<li><strong>Timestamp 和时区有关</strong>：Timestamp 类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是在不同时区，查询到同一个条记录此字段的值会不一样。</li>
<li>Timestamp 只需要使用<strong>4 个字节</strong>的存储空间， DateTime 需要耗费 <strong>8 个字节</strong>的存储空间，所以<strong>Timestamp 表示的时间范围更小</strong></li>
<li><strong>时间戳：数据的可读性太差</strong></li>
</ul>
<p><img src="/2022/07/19/MySQL%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/clipboard5.png"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引</title>
    <url>/2022/07/12/MySQL%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>索引是一种<strong>数据结构</strong>，用于帮助我们<strong>在大量数据中快速定位到我们想要查找的数据</strong>。<br>索引最形象的比喻就是图书的目录了。注意这里的大量，数据量大了索引才显得有意义。</p>
<h4 id="InnoDB-存储引擎中的-B-树索引"><a href="#InnoDB-存储引擎中的-B-树索引" class="headerlink" title="InnoDB 存储引擎中的 B+ 树索引"></a>InnoDB 存储引擎中的 B+ 树索引</h4><p>要介绍 B+ 树索引，就不得不提<strong>二叉查找树，平衡二叉树和 B 树</strong>这三种数据结构。B+ 树就是从他们仨<strong>演化来的</strong>。</p>
<ul>
<li><h5 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a><strong>二叉查找树</strong></h5></li>
</ul>
<p><img src="/2022/07/12/MySQL%E7%B4%A2%E5%BC%95/clipboard.png"></p>
<p>图示：我们为 user 表（用户信息表）建立了一个二叉查找树的索引</p>
<p>图中的圆为二叉查找树的节点，<strong>节点中存储了键（key）和数据（data）</strong>。键对应 user 表中的 id，数据对应 user 表中的行数据。</p>
<p>二叉查找树的特点就是<strong>任何节点的左子节点的键值都小于当前节点的键值</strong>，<strong>右子节点的键值都大于当前节点的键值</strong>。<strong>顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点</strong>。</p>
<p>如果我们需要查找 id=12 的用户信息，利用我们创建的二叉查找树索引，查找流程如下：</p>
<p>将根节点作为当前节点，把 12 与当前节点的键值 10 比较，12 大于 10，接下来我们把当前节点&gt;的右子节点作为当前节点。</p>
<p>继续把 12 和当前节点的键值 13 比较，发现 12 小于 13，把当前节点的左子节点作为当前节点。</p>
<p>把 12 和当前节点的键值 12 对比，12 等于 12，满足条件，我们从当前节点中取出 data，即 id=12，name=xm。</p>
<p>利用二叉查找树我们只需要 3 次即可找到匹配的数据。如果在表中一条条的查找的话，我们需要 6 次才能找到</p>
<ul>
<li><h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><strong>平衡二叉树</strong></h5><p>假如二叉查找树是这样的构造的：</p>
<p><img src="/2022/07/12/MySQL%E7%B4%A2%E5%BC%95/clipboard2.png"></p>
</li>
</ul>
<p><strong>二叉查找树变成了一个链表</strong>。如果我们需要查找 id=17 的用户信息，我们需要查找 7 次，也就相当于<strong>全表扫描</strong>了。 </p>
<p>原因：二叉查找树变得不平衡了，也就是<strong>高度太高</strong>了，从而导致<strong>查找效率的不稳定</strong>。</p>
<p>解决：保证二叉查找树一直保持平衡，就需要用到<strong>平衡二叉树</strong>。平衡二叉树又称 <strong>AVL 树</strong>，<strong>在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过 1。</strong></p>
<p>平衡二叉树和非平衡二叉树的对比：</p>
<p><img src="/2022/07/12/MySQL%E7%B4%A2%E5%BC%95/clipboard3.png"></p>
<p>平衡二叉树保证了树的构造是平衡的，当我们<strong>插入或删除数据</strong>导致不满足平衡二叉树不平衡时，平衡二叉树会进行<strong>调整树上的节点来保持平衡</strong></p>
<p>平衡二叉树相比于二叉查找树来说，<strong>查找效率更稳定，总体的查找速度也更快</strong></p>
<ul>
<li><h5 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a><strong>B 树</strong></h5><p>因为<strong>内存的易失性</strong>，我们都会选择将 user 表中的<strong>数据和索引存储在磁盘</strong>这种外围设备中。</p>
<p>和内存相比，<strong>从磁盘中读取数据的速度会慢上百倍千倍甚至万倍</strong>，应当<strong>尽量减少从磁盘中读取数据的次数</strong></p>
<p>从磁盘中读取数据时，都是按照<strong>磁盘块来读取的</strong>，并不是一条一条的读</p>
<p>如果我们能<strong>把尽量多的数据放进磁盘块</strong>中，那<strong>一次磁盘读取操作就会读取更多数据</strong>，那我们<strong>查找数据的时间也会大幅度降低</strong>。</p>
<p>如果我们用树这种数据结构作为索引的数据结构，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块。</p>
<p>我们都知道<strong>平衡二叉树可是每个节点只存储一个键值和数据的</strong>。那说明什么？说明每个磁盘块仅仅存储一个键值和数据！那如果我们<strong>要存储海量的数据</strong>呢？</p>
<p>可以想象到二叉树的节点将会非常多，高度也会极其高，我们查找数据时也会进行很多次磁盘 IO，我们查找数据的效率将会极低！</p>
<p><img src="/2022/07/12/MySQL%E7%B4%A2%E5%BC%95/clipboard4.png"></p>
</li>
</ul>
<p>为了解决平衡二叉树的这个弊端，我们应该<strong>寻找一种单个节点可以存储多个键值和数据的平衡树</strong>。也就是我们接下来要说的 B 树。</p>
<p><strong>B 树（Balance Tree）即为平衡树的意思</strong>，下图即是一棵 B 树：</p>
<p><img src="/2022/07/12/MySQL%E7%B4%A2%E5%BC%95/clipboard5.png"></p>
<p>图中的 <strong>p 节点为指向子节点的指针</strong></p>
<p>图中的<strong>每个节点称为页</strong>，页就是我们上面说的<strong>磁盘块</strong>，在 MySQL 中数据读取的基本单位都是页，所以我们这里叫做页更符合 MySQL 中索引的底层数据结构。</p>
<p>从上图可以看出，B 树相对于平衡二叉树，<strong>每个节点存储了更多的键值（key）和数据（data）</strong>，并且<strong>每个节点拥有更多的子节点</strong>，子节点的个数一般称为阶，上述图中的 B 树为 3 阶 B 树，<strong>高度也会很低。</strong></p>
<p>基于这个特性，<strong>B 树查找数据读取磁盘的次数将会很少</strong>，<strong>数据的查找效率也会比平衡二叉树高很多</strong>。</p>
<p>假如我们要查找 id=28 的用户信息，那么我们在上图 B 树中查找的流程如下：</p>
<p>先找到根节点也就是页 1，判断 28 在键值 17 和 35 之间，那么根据页 1 中的指针 p2 找到页 3。</p>
<p>将 28 和页 3 中的键值相比较，28 在 26 和 30 之间，我们根据页 3 中的指针 p2 找到页 8。</p>
<p>将 28 和页 8 中的键值相比较，发现有匹配的键值 28，键值 28 对应的用户信息为（28，bv）。</p>
<ul>
<li><h5 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a><strong>B+ 树</strong></h5><p><strong>B+ 树是对 B 树的进一步优化</strong>。让我们先来看下 B+ 树的结构图：（<strong>聚集索引的实现方式</strong>）</p>
</li>
</ul>
<p><img src="/2022/07/12/MySQL%E7%B4%A2%E5%BC%95/clipboard6.png"></p>
<p>根据上图我们来看下 B+ 树和 B 树有什么不同：</p>
<ul>
<li><strong>B+ 树非叶子节点上是不存储数据的，仅存储键值</strong>，而 <strong>B 树节点中不仅存储键值，也会存储数据</strong>。</li>
</ul>
<p>之所以这么做是因为在<strong>数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB</strong>。</p>
<p>如果<strong>不存储数据</strong>，那么就会<strong>存储更多的键值</strong>，相应的<strong>树的阶数</strong>（节点的子节点树）就会<strong>更大</strong>，树就会<strong>更矮更胖</strong>，如此一来我们<strong>查找数据进行磁盘的 IO 次数又会再次减少</strong>，数据查询的效率也会更快。</p>
<p>另外，B+ 树的阶数是等于键值的数量的，如果我们的 B+ 树一个节点可以存储 1000 个键值，那么 3 层 B+ 树可以存储 1000×1000×1000=10 亿个数据。</p>
<p>一般<strong>根节点是常驻内存</strong>的，所以一般我们查找 10 亿数据，只需要 2 次磁盘 IO。</p>
<ul>
<li>因为 <strong>B+ 树索引的所有数据均存储在叶子节点</strong>，而且<strong>数据是按照顺序排列</strong>的。</li>
</ul>
<p>那么 B+ 树使得<strong>范围查找，排序查找，分组查找以及去重查找</strong>变得异常简单。而 B 树因为数据分散在各个节点，要实现这一点是很不容易的。</p>
<p>通过上图可以看到，在 InnoDB 中，我们通过<strong>数据页之间通过双向链表连接</strong>以及<strong>叶子节点中数据之间通过单向链表连接</strong>的方式可以找到表中所有的数据。</p>
<h4 id="MyISAM-中，B-树索引"><a href="#MyISAM-中，B-树索引" class="headerlink" title="MyISAM 中，B+ 树索引"></a>MyISAM 中，B+ 树索引</h4><p>MyISAM 中的 B+ 树索引实现与 InnoDB 中的略有不同。<strong>在 MyISAM 中，B+ 树索引的叶子节点并不存储数据，而是存储数据的文件地址。</strong></p>
<h4 id="聚集索引-VS-非聚集索引"><a href="#聚集索引-VS-非聚集索引" class="headerlink" title="聚集索引 VS 非聚集索引"></a><strong>聚集索引 VS 非聚集索引</strong></h4><p>在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引</p>
<p> InnoDB 中的聚集索引和非聚集索引：</p>
<ul>
<li><strong>聚集索引（聚簇索引）</strong>：以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，<strong>系统也会帮你创建一个隐式的主键</strong>。</li>
</ul>
<p>自增ID，防止页分裂</p>
<p>这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。</p>
<p>这种<strong>以主键作为 B+ 树索引的键值而构建的 B+ 树索引</strong>，我们称之为聚集索引。</p>
<ul>
<li><strong>非聚集索引（非聚簇索引）</strong>：<strong>以主键以外的列值作为键值构建的 B+ 树索引</strong>，我们称之为非聚集索引。</li>
</ul>
<p>非聚集索引与聚集索引的区别在于<strong>非聚集索引的叶子节点不存储表中的数据</strong>，而是<strong>存储该列对应的主键</strong>，想要查找数据我们<strong>还需要根据主键再去聚集索引中进行查找</strong>，这个再根据聚集索引查找数据的过程，我们称为<strong>回表</strong>。</p>
<p>利用聚集索引查找数据：</p>
<p><img src="/2022/07/12/MySQL%E7%B4%A2%E5%BC%95/clipboard7.png"></p>
<p>假设我们要查找 id&gt;=18 并且 id&lt;40 的用户数据。对应的 sql 语句为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where id&gt;=18 and id &lt;40</span><br></pre></td></tr></table></figure>

<p>其中 id 为主键，具体的查找过程如下：</p>
<p>①一般根节点都是常驻内存的，也就是说页 1 已经在内存中了，此时不需要到磁盘中读取数据，直接从内存中读取即可。</p>
<p>从内存中读取到页 1，要查找这个 id&gt;=18 and id &lt;40 或者范围值，我们首先需要找到 id=18 的键值。</p>
<p>从页 1 中我们可以找到键值 18，此时我们需要根据指针 p2，定位到页 3。</p>
<p>②要从页 3 中查找数据，我们就需要拿着 p2 指针去磁盘中进行读取页 3。</p>
<p>从磁盘中读取页 3 后将页 3 放入内存中，然后进行查找，我们可以找到键值 18，然后再拿到页 3 中的指针 p1，定位到页 8。</p>
<p>③同样的页 8 页不在内存中，我们需要再去磁盘中将页 8 读取到内存中。</p>
<p>将页 8 读取到内存中后。因为页中的数据是链表进行连接的，而且键值是按照顺序存放的，此时可以根据二分查找法定位到键值 18。</p>
<p>此时因为已经到数据页了，此时我们已经找到一条满足条件的数据了，就是键值 18 对应的数据。</p>
<p>因为是范围查找，而且此时所有的数据又都存在叶子节点，并且是有序排列的，那么我们就可以对页 8 中的键值依次进行遍历查找并匹配满足条件的数据。</p>
<p>我们可以一直找到键值为 22 的数据，然后页 8 中就没有数据了，此时我们需要拿着页 8 中的 p 指针去读取页 9 中的数据。</p>
<p>④因为页 9 不在内存中，就又会加载页 9 到内存中，并通过和页 8 中一样的方式进行数据的查找，直到将页 12 加载到内存中，发现 41 大于 40，此时不满足条件。那么查找到此终止。</p>
<p>最终我们找到满足条件的所有数据，总共 12 条记录：</p>
<p>(18,kl), (19,kl), (22,hj), (24,io), (25,vg) , (29,jk), (31,jk) , (33,rt) , (34,ty) , (35,yu) , (37,rt) , (39,rt) 。</p>
<p>下面看下具体的查找流程图：</p>
<p><img src="/2022/07/12/MySQL%E7%B4%A2%E5%BC%95/clipboard8.png"></p>
<p>利用非聚集索引查找数据:</p>
<p><img src="/2022/07/12/MySQL%E7%B4%A2%E5%BC%95/clipboard9.png"></p>
<p>首先，这个非聚集索引表示的是用户幸运数字的索引（为什么是幸运数字？一时兴起想起来的:-)），此时表结构是这样的。</p>
<p><img src="/2022/07/12/MySQL%E7%B4%A2%E5%BC%95/clipboard12.png"></p>
<p>在叶子节点中，不再存储所有的数据了，存储的是键值和主键。对于叶子节点中的 x-y，比如 1-1。左边的 1 表示的是索引的键值，右边的 1 表示的是主键值。</p>
<p>如果我们要找到幸运数字为 33 的用户信息，对应的 sql 语句为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where luckNum=33</span><br></pre></td></tr></table></figure>

<p>查找的流程跟聚集索引一样，这里就不详细介绍了。我们最终会找到主键值 47，找到主键后我们需要再到聚集索引中查找具体对应的数据信息，此时又回到了聚集索引的查找流程。</p>
<p>下面看下具体的查找流程图：</p>
<p><img src="/2022/07/12/MySQL%E7%B4%A2%E5%BC%95/clipboard10.png"></p>
<p><strong>数据即索引，索引即数据</strong></p>
<p><strong>聚集索引和非聚集索引区别：</strong></p>
<p>聚集索引和非聚集索引的根本区别是<strong>表记录的排列顺序和与索引的排列顺序是否一致</strong>。</p>
<p>聚集索引： <strong>聚集索引表记录的排列顺序和索引的排列顺序一致</strong>，所以查询效率快，<strong>只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放</strong>。聚集索引对应的<strong>缺点就是修改慢</strong>，因为<strong>为了保证表中记录的物理和索引顺序一致</strong>，在<strong>记录插入</strong>的时候，会对<strong>数据页重新排序</strong>。</p>
<p>非聚集索引：<strong>非聚集索引制定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致</strong>，两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而<strong>采用叶子层包含一个指向表中的记录在数据页中的指针方式</strong>。非聚集索引层次多，不会造成数据重排。</p>
<p>例子对比两种索引：</p>
<p>聚集索引就类似新华字典中的<strong>拼音排序索引</strong>，都是按<strong>顺序</strong>进行，<strong>例如找到字典中的“爱”，就里面顺序执行找到“癌”</strong>。而非聚集索引则类似于<strong>笔画排序</strong>，<strong>索引顺序和物理顺序并不是按顺序存放</strong>的。</p>
<h4 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a><strong>什么是覆盖索引？</strong></h4><p>如果一个<strong>索引包含（或者说覆盖）所有需要查询的字段的值</strong>，我们就称之为“覆盖索引”</p>
<p>InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“<strong>回表</strong>”，也就是要通过主键再查找一次。这样就会比较慢<strong>覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</strong></p>
<p>覆盖索引使用实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建了索引(username,age)</span><br><span class="line">select username , age from user where username = &#x27;Java&#x27; and age = 22</span><br></pre></td></tr></table></figure>

<p>在查询数据的时候：要<strong>查询出的列在叶子节点都存在</strong>！所以，就不用回表</p>
<p><img src="/2022/07/12/MySQL%E7%B4%A2%E5%BC%95/clipboard11.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT age FROM student WHERE name = &#x27;小李&#x27;；</span><br><span class="line">流程为：</span><br><span class="line">在name,age联合索引树上找到名称为小李的节点</span><br><span class="line">此时节点索引里包含信息age 直接返回 12</span><br></pre></td></tr></table></figure>

<h4 id="最左前缀原则-最左优先"><a href="#最左前缀原则-最左优先" class="headerlink" title="最左前缀原则  最左优先"></a><strong>最左前缀原则  最左优先</strong></h4><p>MySQL中的索<strong>引可以以一定顺序引用多列</strong>，这种索引叫作<strong>联合索引</strong></p>
<p>如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where name=xx and city=xx ; //可以命中索引</span><br><span class="line">select * from user where name=xx ; // 可以命中索引</span><br><span class="line">select * from user where city=xx ; // 无法命中索引</span><br></pre></td></tr></table></figure>

<p>查询的时候如果两个条件都用上了，但是顺序不同，如 city= xx and name ＝xx，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。</p>
<p>注：在创建多列索引时，要根据业务需求，<strong>where子句中使用最频繁的一列放在最左边</strong>。</p>
<p>如果表中只有id,a,b,c四个字段</p>
<p><strong>主键id,组合索引(a,b,c)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table where b=1 and c=1;</span><br><span class="line">select * from table where  c=1;</span><br></pre></td></tr></table></figure>

<p>都会用到索引，因为索引(a,b,c)包含除了主键的所有字段，会用到覆盖索引</p>
<h4 id="Mysql如何为表字段添加索引"><a href="#Mysql如何为表字段添加索引" class="headerlink" title="Mysql如何为表字段添加索引?"></a><strong>Mysql如何为表字段添加索引?</strong></h4><p>添加PRIMARY KEY（主键索引）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) </span><br></pre></td></tr></table></figure>

<p>添加UNIQUE(唯一索引)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD UNIQUE ( `column` ) </span><br></pre></td></tr></table></figure>

<p>添加INDEX(普通索引)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD INDEX index_name ( `column` )</span><br></pre></td></tr></table></figure>

<p>添加FULLTEXT(全文索引)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD FULLTEXT ( `column`) </span><br></pre></td></tr></table></figure>

<p>添加多列索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )</span><br></pre></td></tr></table></figure>

<p>CREATE 创建索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX indexName ON table_name (column_name)</span><br></pre></td></tr></table></figure>

<h4 id="Hash索引和-B-树索引优劣分析"><a href="#Hash索引和-B-树索引优劣分析" class="headerlink" title="Hash索引和 B+树索引优劣分析"></a><strong>Hash索引和 B+树索引优劣分析</strong></h4><ul>
<li><p><strong>Hash索引定位快</strong>：Hash索引指的就是<strong>Hash表</strong>，最大的优点就是能够在很短的时间内，<strong>根据Hash函数定位到数据所在的位置</strong>，这是B+树所不能比的</p>
</li>
<li><p><strong>Hash冲突问题</strong></p>
</li>
<li><p><strong>Hash索引不支持顺序和范围查询</strong>(Hash索引不支持顺序和范围查询是它最大的缺点)。</p>
</li>
</ul>
<h4 id="Mysql的覆盖索引和联合索引的区别"><a href="#Mysql的覆盖索引和联合索引的区别" class="headerlink" title="Mysql的覆盖索引和联合索引的区别"></a>Mysql的<strong>覆盖索引和联合索引</strong>的区别</h4><p><strong>覆盖索引</strong>指的是<strong>索引中已包含需要查询的数据，执行查询时无需回表</strong>，扫描一次B+数索引即可</p>
<p><strong>联合索引，在多个属性，建立为一个索引，加快多条件查询</strong></p>
<p><strong>索引覆盖是联合索引查询时的最优情况，不要回表</strong></p>
<h4 id="索引最为常见的扫描方式"><a href="#索引最为常见的扫描方式" class="headerlink" title="索引最为常见的扫描方式"></a>索引最为常见的扫描方式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system：系统表，少量数据，往往不需要进行磁盘IO；</span><br><span class="line">const：常量连接；命中主键(primary key)或者唯一(unique)索引</span><br><span class="line">eq_ref：主键索引(primary key)或者非空唯一索引(unique not null)等值扫描；</span><br><span class="line">ref：非主键非唯一索引等值扫描；</span><br><span class="line">range：范围扫描；</span><br><span class="line">index：索引树扫描；</span><br><span class="line">ALL：全表扫描(full table scan)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>执行一条select语句，期间发生了什么</title>
    <url>/2023/02/22/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h1 id="执行一条-select-语句，期间发生了什么？"><a href="#执行一条-select-语句，期间发生了什么？" class="headerlink" title="执行一条 select 语句，期间发生了什么？"></a>执行一条 select 语句，期间发生了什么？</h1><p>学习 SQL 的时候，大家肯定第一个先学到的就是 select 查询语句了，比如下面这句查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 在 product 表中，查询 id <span class="operator">=</span> <span class="number">1</span> 的记录</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>但是有没有想过，<strong>MySQL 执行一条 select 查询语句，在 MySQL 中期间发生了什么？</strong></p>
<p>带着这个问题，我们可以很好的了解 MySQL 内部的架构，所以这次就带大家拆解一下 MySQL 内部的结构，看看内部里的每一个“零件”具体是负责做什么的。</p>
<h2 id="MySQL-执行流程是怎样的？"><a href="#MySQL-执行流程是怎样的？" class="headerlink" title="MySQL 执行流程是怎样的？"></a>MySQL 执行流程是怎样的？</h2><p>先来一个上帝视角图，下面就是 MySQL 执行一条 SQL 查询语句的流程，也从图中可以看到 MySQL 内部架构里的各个功能模块。</p>
<p><img src="/2023/02/22/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p>
<p>可以看到， MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong>，</p>
<ul>
<li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li>
<li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</li>
</ul>
<p>好了，现在我们对 Server 层和存储引擎层有了一个简单认识，接下来，就详细说一条 SQL 查询语句的执行流程，依次看看每一个功能模块的作用。</p>
<h2 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h2><p>如果你在 Linux 操作系统里要使用 MySQL，那你第一步肯定是要先连接 MySQL 服务，然后才能执行 SQL 语句，普遍我们都是使用下面这条命令进行连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-u 指定用户名，管理员角色名为 root；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码</span></span><br><span class="line">mysql -h$ip -u$user -p</span><br></pre></td></tr></table></figure>

<p>连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的，如果 MySQL 服务并没有启动，则会收到如下的报错：</p>
<p><img src="/2023/02/22/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/mysql%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF.png" alt="img"></p>
<p>如果 MySQL 服务正常运行，完成 TCP 连接的建立后，连接器就要开始验证你的用户名和密码，如果用户名或密码不对，就收到一个”Access denied for user”的错误，然后客户端程序结束执行。</p>
<p><img src="/2023/02/22/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF.png" alt="img"></p>
<p>如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。</p>
<p>所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p>
<blockquote>
<p>如何查看 MySQL 服务被多少个客户端连接了？</p>
</blockquote>
<p>如果你想知道当前 MySQL 服务被多少个客户端连接了，你可以执行 <code>show processlist</code> 命令进行查看。</p>
<p><img src="/2023/02/22/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/%E6%9F%A5%E7%9C%8B%E8%BF%9E%E6%8E%A5.png" alt="img"></p>
<p>比如上图的显示结果，共有两个用户名为 root 的用户连接了 MySQL 服务，其中 id 为 6 的用户的 Command 列的状态为 <code>Sleep</code> ，这意味着该用户连接完 MySQL 服务就没有再执行过任何命令，也就是说这是一个空闲的连接，并且空闲的时长是 736 秒（ Time 列）。</p>
<blockquote>
<p>空闲连接会一直占用着吗？</p>
</blockquote>
<p>当然不是了，MySQL 定义了空闲连接的最大空闲时长，由 <code>wait_timeout</code> 参数控制的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;wait_timeout&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> wait_timeout  <span class="operator">|</span> <span class="number">28800</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>当然，我们自己也可以手动断开空闲的连接，使用的是 kill connection + id 的命令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> kill connection <span class="operator">+</span><span class="number">6</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”</p>
<blockquote>
<p>MySQL 的连接数有限制吗？</p>
</blockquote>
<p>MySQL 服务支持的最大连接数由 max_connections 参数控制，比如我的 MySQL 服务默认是 151 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;max_connections&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-------+</span></span><br><span class="line"><span class="operator">|</span> max_connections <span class="operator">|</span> <span class="number">151</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念，它们的区别如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 短连接</span></span><br><span class="line">连接 mysql 服务（TCP 三次握手）</span><br><span class="line">执行sql</span><br><span class="line">断开 mysql 服务（TCP 四次挥手）</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长连接</span></span><br><span class="line">连接 mysql 服务（TCP 三次握手）</span><br><span class="line">执行sql</span><br><span class="line">执行sql</span><br><span class="line">执行sql</span><br><span class="line">....</span><br><span class="line">断开 mysql 服务（TCP 四次挥手）</span><br></pre></td></tr></table></figure>

<p>可以看到，使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。</p>
<p>但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。</p>
<blockquote>
<p>怎么解决长连接占用内存的问题？</p>
</blockquote>
<p>有两种解决方式。</p>
<p>第一种，<strong>定期断开长连接</strong>。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。</p>
<p>第二种，<strong>客户端主动重置连接</strong>。MySQL 5.7 版本实现了 <code>mysql_reset_connection()</code> 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p>
<p>至此，连接器的工作做完了，简单总结一下：</p>
<ul>
<li>与客户端进行 TCP 三次握手建立连接；</li>
<li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li>
<li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li>
</ul>
<h2 id="第二步：查询缓存"><a href="#第二步：查询缓存" class="headerlink" title="第二步：查询缓存"></a>第二步：查询缓存</h2><p>连接器得工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。</p>
<p>如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</p>
<p>如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。</p>
<p>这么看，查询缓存还挺有用，但是其实<strong>查询缓存挺鸡肋</strong>的。</p>
<p>对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。</p>
<p>所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。</p>
<p>对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND。</p>
<p>TIP</p>
<p>这里说的查询缓存是 server 层的，也就是 MySQL 8.0 版本移除的是 server 层的查询缓存，并不是 Innodb 存储引擎中的 buffer pool。</p>
<h2 id="第三步：解析-SQL"><a href="#第三步：解析-SQL" class="headerlink" title="第三步：解析 SQL"></a>第三步：解析 SQL</h2><p>在正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析，这个工作交由「解析器」来完成。</p>
<h3 id="解析器"><a href="#解析器" class="headerlink" title="#解析器"></a><a href="https://www.xiaolincoding.com/mysql/base/how_select.html#%E8%A7%A3%E6%9E%90%E5%99%A8">#</a>解析器</h3><p>解析器会做如下两件事情。</p>
<p>第一件事情，<strong>词法分析</strong>。MySQL 会根据你输入的字符串识别出关键字出来，例如，SQL语句 select username from userinfo，在分析之后，会得到4个Token，其中有2个Keyword，分别为select和from：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>非关键字</th>
<th>关键字</th>
<th>非关键字</th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>username</td>
<td>from</td>
<td>userinfo</td>
</tr>
</tbody></table>
<p>第二件事情，<strong>语法分析</strong>。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</p>
<p><img src="/2023/02/22/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/db-mysql-sql-parser-2.png" alt="img"></p>
<p>如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错。比如，我下面这条查询语句，把 from 写成了 form，这时 MySQL 解析器就会给报错。</p>
<p><img src="/2023/02/22/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF.png" alt="img"></p>
<p>但是注意，表不存在或者字段不存在，并不是在解析器里做的，《MySQL 45 讲》说是在解析器做的，但是经过我和朋友看 MySQL 源码（5.7和8.0）得出结论是解析器只负责检查语法和构建语法树，但是不会去查表或者字段存不存在。</p>
<p>那到底谁来做检测表和字段是否存在的工作呢？别急，接下来就是了</p>
<h2 id="第四步：执行-SQL"><a href="#第四步：执行-SQL" class="headerlink" title="第四步：执行 SQL"></a>第四步：执行 SQL</h2><p>经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条<code>SELECT</code> 查询语句流程主要可以分为下面这三个阶段：</p>
<ul>
<li>prepare 阶段，也就是预处理阶段；</li>
<li>optimize 阶段，也就是优化阶段；</li>
<li>execute 阶段，也就是执行阶段；</li>
</ul>
<h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>我们先来说说预处理阶段做了什么事情。</p>
<ul>
<li>检查 SQL 查询语句中的表或者字段是否存在；</li>
<li>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</li>
</ul>
<p>我下面这条查询语句，test 这张表是不存在的，这时 MySQL 就会在执行 SQL 查询语句的 prepare 阶段中报错。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test;</span><br><span class="line">ERROR <span class="number">1146</span> (<span class="number">42</span>S02): <span class="keyword">Table</span> <span class="string">&#x27;mysql.test&#x27;</span> doesn<span class="string">&#x27;t exist</span></span><br></pre></td></tr></table></figure>

<p>这里贴个 MySQL 8.0 源码来证明表或字段是否存在的判断，不是在解析器里做的，而是在 prepare 阶段。（<em>PS：下图是公众号「一树一溪」老哥帮我分析的，这位老哥专门写 MySQL 源码文章，感兴趣的朋友，可以微信搜索关注</em>）</p>
<p><img src="/2023/02/22/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/%E8%A1%A8%E4%B8%8D%E5%AD%98%E5%9C%A8.jpeg" alt="img"></p>
<p>上面的中间部分是 MySQL 报错表不存在时的函数调用栈，可以看到表不存在的错误是在get_table_share() 函数里报错的，而这个函数是在 prepare 阶段调用的。</p>
<p>不过，对于 MySQL 5.7 判断表或字段是否存在的工作，是在词法分析&amp;语法分析之后，prepare 阶段之前做的。结论都一样，不是在解析器里做的。代码我就不放了，正因为 MySQL 5.7 代码结构不好，所以 MySQL 8.0 代码结构变化很大，后来判断表或字段是否存在的工作就被放入到 prepare 阶段做了。</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>经过预处理阶段后，还需要为 SQL 查询语句先制定一个执行计划，这个工作交由「优化器」来完成的。</p>
<p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p>
<p>当然，我们本次的查询语句（select * from product where id = 1）很简单，就是选择使用主键索引。</p>
<p>要想知道优化器选择了哪个索引，我们可以在查询语句最前面加个 <code>explain</code> 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引，比如下图的 key 为 <code>PRIMARY</code> 就是使用了主键索引。</p>
<p><img src="/2023/02/22/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png" alt="img"></p>
<p>如果查询语句的执行计划里的 key 为 null 说明没有使用索引，那就会全表扫描（type = ALL），这种查询扫描的方式是效率最低档次的，如下图：</p>
<p><img src="/2023/02/22/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F.png" alt="img"></p>
<p>这张 product 表只有一个索引就是主键，现在我在表中将 name 设置为普通索引（二级索引）。</p>
<p><img src="/2023/02/22/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/%E4%BA%A7%E5%93%81%E8%A1%A8.png" alt="img"></p>
<p>这时 product 表就有主键索引（id）和普通索引（name）。假设执行了这条查询语句：</p>
<p><code>select id from product where id &gt; 1  and name like &#39;i%&#39;;</code></p>
<p>这条查询语句的结果既可以使用主键索引，也可以使用普通索引，但是执行的效率会不同。这时，就需要优化器来决定使用哪个索引了。</p>
<p>很显然这条查询语句是<strong>覆盖索引</strong>，直接在二级索引就能查找到结果（因为二级索引的 B+ 树的叶子节点的数据存储的是主键值），就没必要在主键索引查找了，因为查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本大，优化器基于查询成本的考虑，会选择查询代价小的普通索引。</p>
<p>在下图中执行计划，我们可以看到，执行过程中使用了普通索引（name），Exta 为 Using index，这就是表明使用了覆盖索引优化。</p>
<p><img src="/2023/02/22/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/%E9%80%89%E6%8B%A9%E7%B4%A2%E5%BC%95.png" alt="img"></p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。</p>
<p>接下来，用三种方式执行过程，跟大家说一下执行器和存储引擎的交互过程（PS ：为了写好这一部分，特地去看 MySQL 源码，也是第一次看哈哈）。</p>
<ul>
<li>主键索引查询</li>
<li>全表扫描</li>
<li>索引下推</li>
</ul>
<h4 id="主键索引查询"><a href="#主键索引查询" class="headerlink" title="#主键索引查询"></a><a href="https://www.xiaolincoding.com/mysql/base/how_select.html#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2">#</a>主键索引查询</h4><p>以本文开头查询语句为例，看看执行器是怎么工作的。</p>
<p><code>select * from product where id = 1;</code></p>
<p>这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：</p>
<ul>
<li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 <code>id = 1</code> 交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong>。</li>
<li>存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；</li>
<li>执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。</li>
<li>执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。</li>
</ul>
<p>至此，这个语句就执行完成了。</p>
<h4 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h4><p>举个全表扫描的例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;iphone&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：</p>
<ul>
<li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong>；</li>
<li>执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户的（是的没错，Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。</li>
<li>执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；</li>
<li>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；</li>
<li>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</li>
</ul>
<p>至此，这个语句就执行完成了。</p>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>在这部分非常适合讲索引下推（MySQL 5.6 推出的查询优化策略），这样大家能清楚的知道，「下推」这个动作，下推到了哪里。</p>
<p>索引下推能够减少<strong>二级索引</strong>在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。</p>
<p>举一个具体的例子，方便大家理解，这里一张用户表如下，我对 age 和 reward 字段建立了联合索引（age，reward）：</p>
<p><img src="/2023/02/22/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/%E8%B7%AF%E9%A3%9E%E8%A1%A8.png" alt="img"></p>
<p>现在有下面这条查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user  <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">and</span> reward <span class="operator">=</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure>

<p>联合索引当遇到范围查询 (&gt;、&lt;) 就会停止匹配，也就是 <strong>age 字段能用到联合索引，但是 reward 字段则无法利用到索引</strong>。具体原因这里可以看这篇：<a href="https://xiaolincoding.com/mysql/index/index_interview.html#%E6%8C%89%E5%AD%97%E6%AE%B5%E4%B8%AA%E6%95%B0%E5%88%86%E7%B1%BB">索引常见面试题(opens new window)</a></p>
<p>那么，不使用索引下推（MySQL 5.6 之前的版本）时，执行器与存储引擎的执行流程是这样的：</p>
<ul>
<li><p>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age &gt; 20 的第一条记录；</p>
</li>
<li><p>存储引擎根据二级索引的 B+ 树快速定位到这条记录后，获取主键值，然后<strong>进行回表操作</strong>，将完整的记录返回给 Server 层；</p>
</li>
<li><p>Server 层在判断该记录的 reward 是否等于 100000，如果成立则将其发送给客户端；否则跳过该记录；</p>
</li>
<li><p>接着，继续向存储引擎索要下一条记录，存储引擎在二级索引定位到记录后，获取主键值，然后回表操作，将完整的记录返回给 Server 层；</p>
</li>
<li><p>如此往复，直到存储引擎把表中的所有记录读完。</p>
<p>可以看到，没有索引下推的时候，每查询到一条二级索引记录，都要进行回表操作，然后将记录返回给 Server，接着 Server 再判断该记录的 reward 是否等于 100000。</p>
<p>而使用索引下推后，判断记录的 reward 是否等于 100000 的工作交给了存储引擎层，过程如下 ：</p>
<ul>
<li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age &gt; 20 的第一条记录；</li>
<li>存储引擎定位到二级索引后，<strong>先不执行回表</strong>操作，而是先判断一下该索引中包含的列（reward列）的条件（reward 是否等于 100000）是否成立。如果<strong>条件不成立</strong>，则直接<strong>跳过该二级索引</strong>。如果<strong>成立</strong>，则<strong>执行回表</strong>操作，将完成记录返回给 Server 层。</li>
<li>Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。</li>
<li>如此往复，直到存储引擎把表中的所有记录读完。</li>
</ul>
<p>可以看到，使用了索引下推后，虽然 reward 列无法使用到联合索引，但是因为它包含在联合索引（age，reward）里，所以直接在存储引擎过滤出满足 reward = 100000 的记录后，才去执行回表操作获取整个记录。相比于没有使用索引下推，节省了很多回表操作。</p>
<p>当你发现执行计划里的 Extr 部分显示了 “Using index condition”，说明使用了索引下推。</p>
<p><img src="/2023/02/22/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png" alt="img"></p>
</li>
</ul>
<p>总结</p>
<p>执行一条 SQL 查询语句，期间发生了什么？</p>
<ul>
<li>连接器：建立连接，管理连接、校验用户身份；</li>
<li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li>
<li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li>
<li>执行 SQL：执行 SQL 共有三个阶段：<ul>
<li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li>
<li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li>
<li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
</li>
</ul>
<p>怎么样？现在再看这张图，是不是很清晰了。</p>
<p><img src="/2023/02/22/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B2" alt="查询语句执行流程"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
