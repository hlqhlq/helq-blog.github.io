<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 迷途小书童</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/" style="font-size:4rem">迷途小书童</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
        <img
          src="/images/ayer.svg"
          class="cover-logo"
          alt="迷途小书童"
        />
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['最值得欣赏的风景，是自己奋斗的足迹', '比别人多一点执着，你就会创造奇迹', '因为有悔，所以披星戴月；因为有梦，所以奋不顾身'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-JVM运行时数据区"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/25/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"
    >JVM运行时数据区</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/25/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/" class="article-date">
  <time datetime="2022-07-25T05:12:39.000Z" itemprop="datePublished">2022-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>VM(Java Virtual Machine/Java 虚拟机)在执行 Java 程序的过程中会把它所管理的<strong>内存划分为若干个不同的数据区域</strong>。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/94b7c2ab84ac">进程</a>的启动而一直存在，有的区域则是依赖用户线程的启动和结束而建立和销毁</p>
<p><img src="/2022/07/25/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/CA1BB924A33442FC9CFC3BC482E62ABB.jpg"></p>
<h4 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a><strong>运行时数据区</strong></h4><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h5><p>保存当前线程所正在执行的字节码指令的地址(行号)<strong>，为了</strong>线程切换后能恢复到正确的执行位置**，每条线程都有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储</p>
<p><strong>为什么要线程计数器？因为线程是不具备记忆功能</strong></p>
<h5 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a><strong>虚拟机栈</strong></h5><p><strong>线程私有</strong>的，它的<strong>生命周期和线程相同</strong></p>
<p>虚拟机栈描述的是Java方法执行的内存模型： 每个方法在执行的同时 都会创建一个<strong>栈帧</strong>（StackFrame）用于<strong>存储局部变量表、操作数栈、动态链接、方法出口</strong>等信息。</p>
<p>虚拟机栈中是有单位的，单位就是栈帧，<strong>一个方法一个栈帧</strong>。一个栈帧中他又要存储，局部变量，操作数栈，动态链接，出口等。</p>
<p><img src="/2022/07/25/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/0F361B626063436CA773F219E67AC2AC.jpg"></p>
<p>解析栈帧：</p>
<ul>
<li> <strong>局部变量表</strong>：是用来<strong>存储我们临时8个基本数据类型、对象引用地址、returnAddress类型</strong>。</li>
</ul>
<p>  （returnAddress中保存的是return后要执行的字节码的指令地址。）</p>
<ul>
<li> <strong>操作数栈</strong>：操作数栈就是用来操作的，例如代码中有个 i = 6*6，他在一开始的时候就会进行操</li>
</ul>
<p>  作，读取我们的代码，<strong>进行计算后再放入局部变量表</strong>中去</p>
<ul>
<li><p><strong>动态链接</strong>：假如我方法中，有个 service.add()方法，要链接到别的方法中去，这就是动态链接，</p>
<p>存储链接的地方。</p>
</li>
<li><p><strong>出口</strong>：出口是什呢，出口正常的话就是return 不正常的话就是抛出异常落</p>
</li>
</ul>
<h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a><strong>堆</strong></h5><p>被<strong>所有线程共享的一块内存区</strong>，<strong>存放对象实例</strong>，所有的对象实例以及数组都要在堆上分配</p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><strong>本地方法栈</strong></h5><p>栈很像，只不过方法上带了 <strong>native 关键字的栈字</strong>，且native关键字修饰的大部分源码都是C和C++的代码</p>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><strong>方法区</strong></h5><p>所有<strong>线程共享的内存区域</strong>，它用于存储已<strong>被Java虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据，别命叫Non-Heap（非堆）</p>
<h4 id="JVM运行流程"><a href="#JVM运行流程" class="headerlink" title="JVM运行流程"></a>JVM运行流程</h4><p><img src="/2022/07/25/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/D3E84FA2772A4286B75ED4870D0CFB1D.jpg"></p>
<p>JVM包含两个子系统和两个组件: 两个子系统为Class loader(类装载)、Execution engine(执行引擎)； 两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。</p>
<ul>
<li><p>Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。</p>
</li>
<li><p>Execution engine（执行引擎）：执行classes中的指令。</p>
</li>
<li><p>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</p>
</li>
<li><p>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</p>
</li>
</ul>
<p>流程 ：首先通过<strong>编译器把 Java 代码转换成字节码</strong>，<strong>类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内</strong>，而<strong>字节码文件</strong>只是 JVM 的一套指令集规范，<strong>并不能直接交给底层操作系统去执行</strong>，因此<strong>需要特定的命令解析器执行引擎</strong>（Execution Engine），<strong>将字节码翻译成底层系统指令，</strong>再交由 CPU 去执行，而这个过程中需要<strong>调用其他语言的本地库接口</strong>（Native Interface）来实现整个程序的功能。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Redis-value过大问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/22/Redis-value%E8%BF%87%E5%A4%A7%E9%97%AE%E9%A2%98/"
    >Redis value过大问题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/22/Redis-value%E8%BF%87%E5%A4%A7%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2022-07-22T05:11:54.000Z" itemprop="datePublished">2022-07-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/">Redis</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="多大的-key-算大？"><a href="#多大的-key-算大？" class="headerlink" title="多大的 key 算大？"></a><strong>多大的 key 算大？</strong></h4><p>阿里云Redis 最佳实践中提到 合理的 <strong>Key 中 Value 的字节大小，推荐小于10 KB</strong>。过大的 Value 会引发<strong>数据倾斜、热点Key、实例流量或 CPU 性能被占满</strong>等问题，应从设计源头上避免此类问题带来的性能影响。那么 value Bytes &gt;10kb 可以作为判断 大 key 的一个参考值</p>
<h4 id="怎么发现大-Key-？"><a href="#怎么发现大-Key-？" class="headerlink" title="怎么发现大 Key ？"></a><strong>怎么发现大 Key ？</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--bigkeys 命令</span><br></pre></td></tr></table></figure>

<p>–bigkeys 是 redis 自带的命令，<strong>对整个 Key 进行扫描</strong>，统计 string，list，set，zset，hash 这几个常见数据类型中每种类型里的 最大的 key。<strong>string 类型统计的是 value 的字节数</strong>；<strong>另外 4 种复杂结构的类型统计的是 元素个数，不能直观的看出 value 占用字节数</strong>，所以 –bigkeys 对分析 string 类型的大 key 是有用的，而复杂结构的类型还需要一些第三方工具。（ 元素个数少，不一定 value 不大；元素个数多，也不一定 value 就大）</p>
<p>root@vm1:~# redis-cli -h 127.0.0.1 -p 6379 -a “password” –bigkeys #　<strong>–bigkeys　是以 scan 延迟计算的方式扫描所有 key，因此执行过程中不会阻塞 redis，但实例存在 大量的 keys 时，命令执行的时间会很长</strong>，这种情况建议在 slave 上扫描。</p>
<p>–-bigkeys 统计能直观的看出 string 类型 value 的大小，非 string 类型通常有以下两种方式统计：</p>
<ul>
<li>Redis 4.0 以后的版本：支持 了 <strong>memory 命令查看 key 的大小</strong></li>
<li><strong>Rdbtools 工具包</strong>： Rdbtools 是 python写的 一个第三方开源工具，用来<strong>解析 Redis 快照文件</strong>。除了解析 rdb 文件，还提供了 <strong>统计单个 key 大小的工具</strong>。</li>
</ul>
<h4 id="如何优雅的删除-大-key-？"><a href="#如何优雅的删除-大-key-？" class="headerlink" title="如何优雅的删除 大 key ？"></a><strong>如何优雅的删除 大 key ？</strong></h4><h5 id="del-命令"><a href="#del-命令" class="headerlink" title="del 命令"></a>del 命令</h5><p>del 命令删除单个很大的 key 和 del 批量删除 大 key。</p>
<p><strong>直接 del 命令 粗暴的 删大 key 容易造成 redis 线程阻塞</strong>。<strong>4.0 以前要优雅的删除就是针对不同的类型 写脚本，拆分链表，hash 表，分批删除</strong>。</p>
<h5 id="UNLINK-命令"><a href="#UNLINK-命令" class="headerlink" title="UNLINK 命令"></a><strong>UNLINK</strong> 命令</h5><p><strong>4.0 版本以后</strong>官方对 删 大key 有了特别优化，<strong>支持了 lazy free 功能</strong>， 通常不需要开发脚本就可以删    </p>
<p><strong>UNLINK mykey</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; UNLINK mykey </span><br><span class="line">unlink 命令是  del 的异步版本，由 Lazyfree 机制实现。</span><br><span class="line">Lazyfree 机制的原理是在删除的时候只进行逻辑删除，</span><br><span class="line">把 key 释放操作放在 bio (Background I/O)单独的子线程中惰性处理，</span><br><span class="line">减少删除大 key 对 redis 主线程的阻塞，有效地避免因删除大key带来的性能问题。</span><br><span class="line">unlink 即使在批量删除 大 key 时，也不会对阻塞造成阻塞。</span><br></pre></td></tr></table></figure>



<h5 id="被动删除大-key"><a href="#被动删除大-key" class="headerlink" title="被动删除大 key"></a><strong>被动删除大 key</strong></h5><p>被动删除是指 Redis 自身的 key 清除策略</p>
<ul>
<li>Redis 内存不够时 key 的淘汰策略 ，即超过了 maxmemory 的配置</li>
<li>惰性删除：（建议开启惰性清除策略 ）</li>
<li>定时删除：( redis 默认策略 )</li>
</ul>
<h4 id="Redis的-bigkey-有哪些影响"><a href="#Redis的-bigkey-有哪些影响" class="headerlink" title="Redis的 bigkey 有哪些影响"></a><strong>Redis的 bigkey 有哪些影响</strong></h4><ul>
<li><strong>影响性能</strong></li>
</ul>
<p>因为 Redis <strong>单线程</strong>的工作机制，主线程处理所有key的增删改查。<strong>对bigkey的操作耗时增加将阻塞主线程处理其他业务请求，进而影响整体吞吐量</strong>。</p>
<ul>
<li><strong>影响带宽</strong></li>
</ul>
<p>前面的案例即是一个例子，单个key 7MB ，如果每秒100次查询，则带来700MB 的带宽，虽然现在大部分是万兆网卡<strong>，业务请求量再大一些，网卡也有被打满的风险</strong>。</p>
<ul>
<li><strong>数据倾斜</strong></li>
</ul>
<p><strong>对于分片的redis集群，存在bigkey 会导致单个分片数据量远大于其他节点，整体不均衡</strong>。<strong>如果一个分片空间容量满了，对系统造成不可访问</strong>，而且也不能随意扩容，因为不拆分key的情况下扩容，单个分片还是存在数据倾斜。更惨的是，<strong>数据量比较大，那么访问就增加，容易形成热点</strong>。热点不都是因为数据倾斜导致，数据倾斜会大概率导致热点。</p>
<ul>
<li><strong>影响主从同步</strong></li>
</ul>
<p>Redis Server 的输出大小通常是不可控制的。存在bigkey的时候，就会产生体积庞大的返回数据。另外也有可能因为执行了太多命令，导致产生返回数据的速率超过了往客户端发送的速率，导致服务器堆积大量消息，从而<strong>导致输出缓冲区越来越大，占用过多内存，甚至导致系统崩溃</strong>。Redis 通过设置client-output-buffer-limit 来保护系统安全。</p>
<h4 id="如何解决大key？"><a href="#如何解决大key？" class="headerlink" title="如何解决大key？"></a><strong>如何解决大key？</strong></h4><p>其实就是一个字 “拆”。</p>
<ul>
<li><p>对于字符串类型的key，我们通常要在业务层面将value的大小控制在10KB左右，如果value确实很大，可以考虑<strong>采用序列化算法和压缩算法来处理</strong>，推荐常用的几种序列化算法:Protostuff、Kryo或者Fst。</p>
</li>
<li><p>对于集合类型的key，我们通常要通过控制集合内元素数量来避免bigKey，通常的做法是将<strong>一个大的集合类型的key拆分成若干小集合类型的key来达到目的</strong>。</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-SpringMVC-Controller并发安全问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/21/SpringMVC-Controller%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"
    >SpringMVC Controller并发安全问题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/21/SpringMVC-Controller%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2022-07-21T06:09:01.000Z" itemprop="datePublished">2022-07-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a> / <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/SprigMVC/">SprigMVC</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h4><p>根据Tomcat官网中的介绍，<strong>对于一个浏览器请求，tomcat会指定一个处理线程</strong>，或是在线程池中选取空闲的，或者新建一个线程。</p>
<p>在Tomcat容器中，每个servlet是单例的。<strong>在SpringMVC中，Controller 默认也是单例</strong>。 采用单例模式的最大好处，就是可以<strong>在高并发场景下极大地节省内存资源，提高服务抗压能力</strong>。</p>
<p>单例模式容易出现的问题是：在Controller中定义的<strong>实例变量</strong>，在多个请求并发时会出现竞争访问，<strong>Controller中的实例变量不是线程安全的</strong>。</p>
<h4 id="Controller不是线程安全的"><a href="#Controller不是线程安全的" class="headerlink" title="Controller不是线程安全的"></a><strong>Controller不是线程安全的</strong></h4><p>正因为Controller默认是单例，所以不是线程安全的。如果用SpringMVC 的 Controller时，尽量不在 Controller中使用实例变量，否则会出现线程不安全性的情况，导致数据逻辑混乱。</p>
<p>举一个简单的例子，在一个Controller中定义一个非静态成员变量 num 。通过Controller成员方法来对 num 增加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/addNum&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(++num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">首先访问 http:<span class="comment">// localhost:8080 / addNum，得到的答案是1</span></span><br><span class="line">再次访问 http:<span class="comment">// localhost:8080 / addNum，得到的答案是 2。</span></span><br><span class="line">两次访问得到的结果不同，num已经被修改，并不是我们希望的结果，接口的幂等性被破坏。</span><br></pre></td></tr></table></figure>

<p>所有的请求访问同一个Controller实例，<strong>Controller的私有成员变量就是线程共用的</strong>。某个请求对应的线程如果修改了这个变量，那么在别的请求中也可以读到这个变量修改后的的值。</p>
<h4 id="Controller并发安全的解决办法"><a href="#Controller并发安全的解决办法" class="headerlink" title="Controller并发安全的解决办法"></a><strong>Controller并发安全的解决办法</strong></h4><ul>
<li><p>尽量不要在 Controller 中定义成员变量 ；</p>
</li>
<li><p>如果必须要定义一个非静态成员变量，那么可以通过注解 @Scope(“prototype”) ，将Controller设置为多例模式，容器在接受到该类型对象的请求时，每次都会重新生成一个新的对象给请求方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Scope(value=&quot;prototype&quot;)</span><span class="comment">// 多例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/addNum&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(++num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Controller 中使用 ThreadLocal 变量。 每一个线程都有一个变量的副本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal &lt;Integer&gt; uniqueNum =</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">ThreadLocal</span> &lt;Integer&gt; () &#123;</span><br><span class="line">                 <span class="meta">@Override</span> <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">                     <span class="keyword">return</span> num;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/addNum&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">unum</span> <span class="operator">=</span> uniqueNum.get();</span><br><span class="line">       uniqueNum.set(++unum);</span><br><span class="line">       System.out.println(uniqueNum.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">以上代码运行以后，每次请求 http:<span class="comment">// localhost:8080 / addNum , 得到的结果都是1。</span></span><br><span class="line">更严格的做法是用AtomicInteger类型定义成员变量，对于成员变量的操作使用AtomicInteger的自增方法完成。</span><br></pre></td></tr></table></figure>



</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SprigMVC/" rel="tag">SprigMVC</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-数据库范式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/"
    >数据库范式</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/" class="article-date">
  <time datetime="2022-07-21T05:00:01.000Z" itemprop="datePublished">2022-07-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">MySQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>范式是关系数据库理论的基础，也是我们在设计数据库结构过程中所要遵循的规则和指导方法</p>
<h4 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h4><p>数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保<strong>每一列的原子性   (值不可再分)</strong></p>
<h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><p>满足1NF后，要求表中的<strong>所有列，都必须依赖于主键</strong>，而不能有任何一列与主键没有关系，也就是说<strong>一个表只描述一件事情</strong>；(<strong>消除了部份依赖</strong>)</p>
<p>例如：订单表只描述订单相关的信息，所以所有字段都必须与订单id相关 产品表只描述产品相关的信息，所以所有字段都必须与产品id相 关；因此不能在一张表中同时出现订单信息与产品信息</p>
<h4 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h4><p>必须先满足第二范式（2NF），要求：表中的<strong>每一列只与主键直接相关而不是间接相关</strong>，（表中的每一列只能依赖于主键）；(<strong>消除了传递依赖</strong>)</p>
<p>订单表中需要有客户相关信息，在分离出客户表之后，订单表中只需要有一个用户id即可，而不能有其他的客户信息。因为其他的客户信息直接关联于用户id，而不是直接与订单id直接相关</p>
<h4 id="数据库五大约束"><a href="#数据库五大约束" class="headerlink" title="数据库五大约束"></a>数据库五大约束</h4><ul>
<li><strong>primary KEY</strong>:设置主键约束；</li>
<li><strong>UNIQUE</strong>：设置唯一性约束，不能有重复值；</li>
<li><strong>DEFAULT</strong> 默认值约束，height DOUBLE(3,2)DEFAULT 1.2 height不输入是默认为1,2</li>
<li><strong>NOT NULL</strong>：设置非空约束，该字段不能为空；</li>
<li><strong>FOREIGN key</strong> :设置外键约束</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-MySQL基本知识点"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/19/MySQL%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/"
    >MySQL基本知识点</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/19/MySQL%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time datetime="2022-07-19T09:16:59.000Z" itemprop="datePublished">2022-07-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">MySQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="什么是MySQL"><a href="#什么是MySQL" class="headerlink" title="什么是MySQL?"></a>什么是MySQL?</h4><p>MySQL 是一种<strong>关系型数据库</strong>，<strong>开源免费</strong>的</p>
<h4 id="MyISAM和InnoDB区别？"><a href="#MyISAM和InnoDB区别？" class="headerlink" title="MyISAM和InnoDB区别？"></a>MyISAM和InnoDB区别？</h4><h5 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a><strong>MyISAM</strong></h5><ul>
<li>MyISAM 是 <strong>MySQL 5.5.5 之前的默认引擎</strong></li>
<li><strong>不支持事务</strong></li>
<li><strong>不支持外键</strong></li>
<li><strong>只支持表级锁</strong>，select，update，delete，insert语句都会给表自动加锁</li>
<li><strong>每个MyISAM在磁盘上存储成三个文件</strong>，.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)</li>
<li><strong>保存有表的总行数</strong>，如果select count(*) from table;会直接取出出该值，不需要进行全表扫描</li>
<li>如果执行<strong>大量的SELECT</strong>，MyISAM是更好的选择,因为不支持事务，相比innodb不需要维护事务的东西</li>
<li>B+ 树索引的<strong>叶子节点</strong>并不存储数据，而是<strong>存储数据的文件地址</strong></li>
</ul>
<h5 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a><strong>InnoDB</strong></h5><ul>
<li>从<strong>MySQL 5.5之后</strong>的版本中，<strong>默认的搜索引擎</strong>变更为InnoDB</li>
<li><strong>支持事务</strong>，具有事务(commit)、回滚(rollback)和崩溃修复能力</li>
<li><strong>支持外键</strong></li>
<li><strong>支持行级锁和表级锁</strong>,<strong>默认为行级锁</strong>，适用于高并发的频繁表修改，高并发是性能优于 MyISAM</li>
<li>所有的表都保存在<strong>同一个数据文件中</strong></li>
<li>没有保存表的总行数</li>
<li><strong>执行大量的INSERT或UPDATE</strong></li>
<li>B+ 树索引的<strong>叶子节点存储数据</strong></li>
</ul>
<p>如何选择？</p>
<p><strong>MyISAM适合</strong>：(1)做<strong>很多count 的计算</strong>；(2)插入不频繁，<strong>查询非常频繁</strong>；(3)<strong>没有事务。</strong></p>
<p><strong>InnoDB适合</strong>：(1)可靠性要求比较高，或者<strong>要求事务</strong>；(2)<strong>表更新和查询都相当的频繁</strong>，并且表锁定的机会比较大的情况。</p>
<h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务?"></a>什么是事务?</h4><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行</strong></p>
<h5 id="事务的四大特性-ACID"><a href="#事务的四大特性-ACID" class="headerlink" title="事务的四大特性(ACID)"></a>事务的四大特性(<strong>ACID</strong>)</h5><p><img src="/2022/07/19/MySQL%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/clipboard.png"></p>
<ul>
<li><strong>原子性</strong>（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性</strong>（Consistency）： 执行事务后，数据库从一个<strong>正确的状态变化到另一个正确的状态；</strong></li>
<li><strong>隔离性</strong>（Isolation）： 并发访问数据库时，一个用户的<strong>事务不被其他事务所干扰</strong>，各并发事务之间数据库是独立的；</li>
<li><strong>持久性</strong>（Durability）： 一个<strong>事务被提交</strong>之后。它对数据库中<strong>数据的改变是持久的</strong>，即使数据库发生故障也不应该对其有任何影响</li>
</ul>
<h5 id="并发事务带来哪些问题"><a href="#并发事务带来哪些问题" class="headerlink" title="并发事务带来哪些问题?"></a><strong>并发事务</strong>带来哪些问题?</h5><p>多个用户对同一数据进行操作</p>
<ul>
<li><strong>脏读</strong>（dirty read）：<strong>一个事务可以读取另一个尚未提交事务的修改数据</strong>。事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据</li>
<li><strong>丢失修改</strong>（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的<strong>修改结果就被丢失</strong>，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>
<li><strong>不可重复读</strong>（nonrepeatable read）：<strong>指在一个事务内多次读同一数据</strong>。在这个事务还没有结束时，另一个事务也访问该数据。在第一个事务中的两次读数据之间，<strong>由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样</strong>。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</li>
<li><strong>幻读</strong>（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现<strong>多了一些原本不存在的记录</strong>，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p>不可重复读和幻读区别：</p>
<p><strong>不可重复读的重点是修改</strong>比如多次读取一条记录发现其中某些列的值被修改</p>
<p><strong>幻读的重点在于新增或者删除</strong>比如多次读取一条记录发现记录增多或减少了</p>
<h5 id="事务隔离级别有哪些"><a href="#事务隔离级别有哪些" class="headerlink" title="事务隔离级别有哪些?"></a>事务隔离级别有哪些?</h5><p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li><strong>未提交读</strong>(Read Uncommitted)：允许脏读，也就是<strong>可能读取到其他会话中未提交事务修改的数据</strong></li>
<li><strong>提交读</strong>(Read Committed)：<strong>只能读取到已经提交的数据</strong>。<strong>Oracle</strong>等多数数据库<strong>默认</strong>都是该级别 (不重复读)</li>
<li><strong>可重复读</strong>(Repeated Read)：可重复读，<strong>InnoDB默认的隔离级别</strong> 。<strong>对同一字段的多次读取结果都是一致的</strong>，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><strong>串行读</strong>(Serializable)：完全串行化的读，<strong>每次读都需要获得表级共享锁</strong>，读写相互都会阻塞</li>
</ul>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p><strong>表级锁和行级锁对比</strong></p>
<ul>
<li><p><strong>表级锁： MySQL中锁定 粒度最大 的一种锁，</strong>对<strong>当前操作的整张表加锁</strong>，<strong>实现简单，资源消耗也比较少，加锁快，不会出现死锁</strong>。其锁定粒度最大，<strong>触发锁冲突的概率最高</strong>，<strong>并发度最低，</strong>MyISAM和 InnoDB引擎都支持表级锁。</p>
</li>
<li><p>行级锁： MySQL中锁定 <strong>粒度最小 的一种锁</strong>，只针对<strong>当前操作的行进行加锁</strong>。 行级锁能大大<strong>减少数据库操作的冲突</strong>。其<strong>加锁粒度最小，并发度高</strong>，但<strong>加锁的开销也最大，加锁慢，会出现死锁</strong></p>
</li>
</ul>
<h5 id="共享锁-S-和排他锁-X-的区别"><a href="#共享锁-S-和排他锁-X-的区别" class="headerlink" title="共享锁(S)和排他锁(X)的区别"></a>共享锁(S)和排他锁(X)的区别</h5><ul>
<li><strong>共享锁</strong>（S锁）：如果事务T对数据A加上共享锁后，则<strong>其他事务只能对A再加共享锁</strong>，不能加排他锁。获取共享锁的事务只能读数据，不能修改数据。</li>
<li><strong>排他锁</strong>（X锁）：如果事务T对数据A加上排他锁后，则<strong>其他事务不能再对A加任任何类型的封</strong>锁。获取排他锁的事务既能读数据，又能修改数据。</li>
</ul>
<p>​    innodb会对update,insert,delete语句自动加上排他锁</p>
<h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a><strong>意向锁</strong></h5><ul>
<li><p>意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。</p>
</li>
<li><p>如果自己<strong>需要一个共享锁</strong>，那么就在表上面添加一个**意向共享锁(IS)**。</p>
</li>
<li><p>而如果自己需要的是某行（或者某些行）上面<strong>添加一个排他锁</strong>的话，则先在表上面添加一个<strong>意向排他锁(IX)。</strong></p>
</li>
<li><p>意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在</p>
</li>
</ul>
<h5 id="死锁和避免死锁"><a href="#死锁和避免死锁" class="headerlink" title="死锁和避免死锁"></a>死锁和避免死锁</h5><p>InnoDB的<strong>行级锁是基于索引实现的</strong>，如果查询语句<strong>未命中任何索引</strong>，那么InnoDB会使用<strong>表级锁</strong></p>
<p>死锁的产生：不同于MyISAM总是一次性获得所需的全部锁，<strong>InnoDB的锁是逐步获得的</strong>，当两个事务都需要获得对方持有的锁，导致双方都在等待，这就产生了死锁</p>
<p>发生死锁后，<strong>InnoDB一般都可以检测到，并使一个事务释放锁回退</strong>，另一个则可以获取锁完成事务</p>
<p>检测到死锁之后，<strong>选择插入更新或者删除的行数最少的事务回滚</strong>，基于 INFORMATION_SCHEMA.INNODB_TRX 表中的 trx_weight 字段来判断。<strong>如果插入更新或者删除的行数一样则回滚后面执行的那条事务</strong>。</p>
<h5 id="避免死锁的方式"><a href="#避免死锁的方式" class="headerlink" title="避免死锁的方式"></a><strong>避免死锁的方式</strong></h5><ul>
<li><strong>为表添加合理的索引</strong>。如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大</li>
<li><strong>降低隔离级别</strong>，如果业务允许</li>
<li><strong>按顺序申请锁</strong>，不会造成互相等待</li>
<li>在同一个事务中，<strong>尽可能做到一次锁定所需要的所有资源</strong>，减少死锁概率。</li>
</ul>
<h4 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a><strong>大表优化</strong></h4><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<p>①<strong>限定数据的范围</strong>：务必禁止不带任何限制数据范围条件的查询语句，如<strong>分页，一个月的范围内</strong></p>
<p>②<strong>读/写分离</strong>：经典的数据库拆分方案，<strong>主库负责写，从库负责读</strong></p>
<p>③<strong>垂直分区</strong>：根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p>简单来说<strong>垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表</strong>。如图：</p>
<p><img src="/2022/07/19/MySQL%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/clipboard2.png"></p>
<p><strong>垂直拆分的优点</strong>： 可以使得<strong>列数据变小，在查询时减少读取的Block数，减少I/O次数</strong>。此外，垂直分区可以简化表的结构，易于维护。</p>
<p><strong>垂直拆分的缺点</strong>： <strong>主键会出现冗余</strong>，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会<strong>让事务变得更加复杂</strong></p>
<p>④<strong>水平分区</strong>：保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量</p>
<p><strong>水平拆分是指数据表行的拆分，可以把一张的表的数据拆成多张表来存放</strong></p>
<p>举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p><img src="/2022/07/19/MySQL%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/clipboard3.png"></p>
<p>分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好<strong>分库</strong> 。</p>
<p>缺点：<strong>分片事务难以解决 ，跨节点Join性能较差，逻辑复杂</strong></p>
<p><strong>数据库分片</strong>的两种常见方案：</p>
<ul>
<li><p><strong>客户端代理</strong>： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。当当网的 Sharding-JDBC 、阿里的TDDL</p>
</li>
<li><p><strong>中间件代理</strong>：<strong>在应用和数据中间加了一个代理层</strong>。分片逻辑统一维护在中间件服务中。<strong>Mycat</strong></p>
</li>
</ul>
<h4 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a><strong>数据库连接池</strong></h4><p>连接池是<strong>将已经创建好的连接保存在池中</strong>，当有<strong>请求</strong>来时，<strong>直接使用</strong>已经<strong>创建好的连接</strong>对数据库进行<strong>访问</strong>。这样<strong>省略了创建连接和销毁连接的过程</strong>。这样<strong>性能</strong>上得到了提高</p>
<p>基本原理是这样的：</p>
<ul>
<li><strong>建立数据库连接池对象</strong>（服务器启动）。</li>
<li>按照事先指定的参数<strong>创建初始数量的数据库连接</strong>（即：空闲连接数）。</li>
<li><strong>对于一个数据库访问请求，直接从连接池中得到一个连接</strong>。如果数据库连接池对象中没有空闲的连接，且连接数没有达到最大（即：最大活跃连接数），创建一个新的数据库连接。</li>
<li>存取数据库。</li>
<li>关闭数据库，释放所有数据库连接（此时的关闭数据库连接，并非真正关闭，而是<strong>将其放入空闲队列中</strong>。如实际空闲连接数大于初始空闲连接数则释放连接）。</li>
<li>释放数据库连接池对象（服务器停止、维护期间，释放数据库连接池对象，并释放所有连</li>
</ul>
<h4 id="一条SQL语句在MySQL中如何执行的？"><a href="#一条SQL语句在MySQL中如何执行的？" class="headerlink" title="一条SQL语句在MySQL中如何执行的？"></a><strong>一条SQL语句在MySQL中如何执行的？</strong></h4><ul>
<li><p><strong>连接器</strong>，连接到数据库，<strong>身份认证和权限相关</strong>(登录 MySQL 的时候)</p>
</li>
<li><p><strong>查询缓存</strong>，当mysql拿到查询语句时会先到查询缓存查看，之前是不是执行过这条语句（MySQL 8.0 版本后移除，因为这个功能不太实用）</p>
</li>
<li><p><strong>分析器</strong>  ，如果<strong>没有命中查询缓存，开始执行语句</strong>。<strong>mysql需要知道你要做什么</strong>，需要对SQL语句做解析。分析器先会做<strong>“词法分析</strong>”，然后<strong>语法分析</strong>，是否满足mysql语法</p>
</li>
<li><p><strong>优化器</strong>，在开始执行之前还先经过优化器的处理，决定使用哪个索引，多表关联的时候决定各个表的连接顺序等，<strong>按照 MySQL 认为最优的方案去执行</strong></p>
</li>
<li><p><strong>执行器</strong>，mysql通过<strong>分析器知道了要做什么，通过优化器知道该怎么做</strong>，于是进入执行器阶段开始执行语句，然后从存储引擎返回数据</p>
<p><img src="/2022/07/19/MySQL%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/45d7b28b3b1d0278252faff9d05de521.jpg"></p>
</li>
</ul>
<p>sql更新语句的执行过程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_student A <span class="keyword">set</span> A.age<span class="operator">=</span><span class="string">&#x27;19&#x27;</span> <span class="keyword">where</span> A.name<span class="operator">=</span><span class="string">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>执行更新的时候肯定要记录日志，这就会引入日志模块了，MySQL 自带的日志模块式 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 <strong>InnoDB 引擎</strong>还自带了一个日志模块 <strong>redo log（重做日志）</strong></p>
<ul>
<li><p><strong>先查询到张三这一条数据，如果有缓存，也是会用到缓存</strong>。</p>
</li>
<li><p>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，<strong>写入这一行数据</strong>，InnoDB 引擎把<strong>数据保存在内存</strong>中，<strong>同时记录 redo log</strong>，此时 <strong>redo log 进入 prepare 状态</strong>，然后告诉执行器，执行完成了，随时可以提交。</p>
</li>
<li><p><strong>执行器收到通知后记录 binlog</strong>，然后调用引擎接口，<strong>提交 redo log 为提交状态</strong>。</p>
</li>
<li><p>更新完成</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/19/MySQL%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/clipboard4.png"></p>
<p><strong>一个 SQL 执行的很慢的原因？</strong></p>
<p>当<strong>内存数据页</strong>跟<strong>磁盘数据页内容不一致</strong>的时候，我们称这个<strong>内存页为“脏页”</strong>。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“<strong>干净页</strong>”。</p>
<p>插入一条数据、或者要更新一条数据的时候，我们知道数据库会在内存中把对应字段的数据更新了，但是更新之后，这些<strong>更新的字段</strong>并<strong>不会马上同步持久化到磁盘</strong>中去，而是把这些<strong>更新的记录写入到 redo log 日记</strong>中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到磁盘中去</p>
<p>分两种情况讨论</p>
<p>①<strong>大多数情况下很正常，偶尔很慢</strong>，则有如下原因：</p>
<ul>
<li><strong>数据库在刷新脏页</strong>，例如 redo log 写满了需要同步到磁盘</li>
<li><strong>执行的时候，遇到锁，如表锁、行锁</strong></li>
</ul>
<p>②<strong>SQL 语句一直执行的很慢</strong></p>
<ul>
<li><strong>没有用上索引</strong>：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引</li>
<li><strong>数据库选错了索引</strong></li>
</ul>
<h4 id="MySQL-Explain命令"><a href="#MySQL-Explain命令" class="headerlink" title="MySQL Explain命令"></a>MySQL <strong>Explain命令</strong></h4><p>explain这个命令来<strong>查看SQL语句的执行计划，有没有使用上了索引，有没有做全表扫描</strong></p>
<p>EXPALIN<strong>只能解释SELECT操作</strong>，其他操作要重写为SELECT后查看执行计划</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看SQL是否使用索引，前面加上explain即可</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Jefabc&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h5 id="为什么不对表中的每一个列创建一个索引？"><a href="#为什么不对表中的每一个列创建一个索引？" class="headerlink" title="为什么不对表中的每一个列创建一个索引？"></a>为什么不对表中的每一个列创建一个索引？</h5><ul>
<li>当对表中的<strong>数据进行增加、删除和修改</strong>的时候，<strong>索引也要动态的维护</strong>，这样就降低了数据的维护速度。</li>
<li><strong>索引需要占物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li><strong>创建索引和维护索引要耗费时间</strong>，这种时间随着数据量的增加而增加</li>
</ul>
<p>不建议列上允许为空。最好限制not null，因为null需要更多的存储空间并且null值无法参与某些运算</p>
<h5 id="使用索引的注意事项"><a href="#使用索引的注意事项" class="headerlink" title="使用索引的注意事项"></a><strong>使用索引的注意事项</strong></h5><ul>
<li><p>在<strong>经常需要搜索的列</strong>上，可以加快搜索的速度；</p>
</li>
<li><p>在经常使用在<strong>WHERE子句中的列上面创建索引</strong>，加快条件的判断速度。</p>
</li>
<li><p>在经常需要<strong>排序的列</strong>上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p>
</li>
<li><p>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</p>
</li>
<li><p>在经常用在<strong>连接的列</strong>上，这些列主要是一些外键，可以加快连接的速度；</p>
</li>
<li><p>避免 where 子句中对字段施加函数，这会造成无法命中索引。</p>
</li>
<li><p>在使用InnoDB时<strong>使用与业务无关的自增主键作为主键</strong>，即使用逻辑主键，而不要使用业务主键。</p>
</li>
</ul>
<h5 id="不合适创建索引的字段"><a href="#不合适创建索引的字段" class="headerlink" title="不合适创建索引的字段"></a><strong>不合适创建索引的字段</strong></h5><ul>
<li><strong>被频繁更新的字段</strong>应该慎重建立索引</li>
<li><strong>不被经常查询的字段</strong>没有必要建立索引</li>
<li>尽可能的考虑<strong>建立联合索引</strong>而不是单列索引</li>
<li>注意<strong>避免冗余索引</strong></li>
</ul>
<h4 id="MySQL优化方法"><a href="#MySQL优化方法" class="headerlink" title="MySQL优化方法"></a>MySQL优化方法</h4><ul>
<li>EXPLAIN，<strong>善用EXPLAIN查看SQL执行计划</strong></li>
</ul>
<p><strong>type列，连接类型</strong>。一个好的SQL语句至少要达到range级别。杜绝出现all级别。</p>
<p>ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）</p>
<p><strong>key列</strong>，使用到的索引名。如果没有选择索引，值是NULL。可以采取强制索引方式。</p>
<p>key_len列，索引长度。</p>
<p><strong>rows列，扫描行数</strong>。该值是个预估值。</p>
<p>extra列，详细说明。注意，常见的不太友好的值，如下：Using filesort，Using temporary。</p>
<ul>
<li><p><strong>避免 SELECT *</strong> ，SELECT语句务必指明字段名称</p>
</li>
<li><p><strong>当只需要一条数据的时候，使用limit 1</strong>（为了使EXPLAIN中type列达到const类型）</p>
</li>
<li><p><strong>IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。</strong></p>
</li>
<li><p>替代not exists的SQL语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#原<span class="keyword">SQL</span>语句：</span><br><span class="line"><span class="keyword">select</span> colname … <span class="keyword">from</span> A表 <span class="keyword">where</span> a.id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> b.id <span class="keyword">from</span> B表)</span><br><span class="line">#高效的<span class="keyword">SQL</span>语句</span><br><span class="line"><span class="keyword">select</span> colname … <span class="keyword">from</span> A表 <span class="keyword">Left</span> <span class="keyword">join</span> B表 </span><br><span class="line"><span class="keyword">on</span> <span class="keyword">where</span> a.id <span class="operator">=</span> b.id <span class="keyword">where</span> b.id <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>避免使用 TEXT,BLOB 数据类型</strong>：<strong>建议把 BLOB 或是 TEXT 列分离到单独的扩展表中</strong></p>
</li>
<li><p><strong>尽可能把所有列定义为 NOT NUL</strong>L，索引 <strong>NULL 列需要额外的空间来保存</strong>，所以要占用更多的空间</p>
</li>
<li><p><strong>禁止在数据库中存储图片,文件等大的二进制数据</strong>，通常存储于文件服务器，数据库<strong>只存储文件地址信息</strong></p>
</li>
<li><p>对应同一列进行 or 判断时，使用 <strong>in 代替 or</strong>，in 操作可以<strong>更有效的利用索引</strong>，or 大多数情况下很少能利用到索引</p>
</li>
<li><p>很多时候用 <strong>exists 代替 in</strong> 是一个好的选择：</p>
</li>
<li><p>对于<strong>连续的数值，能用 between 就不要用 in</strong> 了</p>
</li>
<li><p><strong>WHERE 从句中禁止对列进行函数转换和计算</strong>，对列进行函数转换或计算时会<strong>导致无法使用索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">比如：</span><br><span class="line"><span class="keyword">select</span> user_id,user_project <span class="keyword">from</span> user_base <span class="keyword">where</span> age<span class="operator">*</span><span class="number">2</span><span class="operator">=</span><span class="number">36</span>;</span><br><span class="line">中对字段就行了算术运算，这会造成引擎放弃使用索引，建议改成：</span><br><span class="line"><span class="keyword">select</span> user_id,user_project <span class="keyword">from</span> user_base <span class="keyword">where</span> age<span class="operator">=</span><span class="number">36</span><span class="operator">/</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>在<strong>明显不会有重复值</strong>时使用 <strong>UNION ALL 而不是 UNION</strong>，<strong>UNION</strong> 会把两个结果集的所有数据放到<strong>临时表中后再进行去重操作</strong></p>
</li>
<li><p>联合索引来说，要遵守<strong>最左前缀法则</strong></p>
</li>
<li><p>尽量使用inner join，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表</p>
</li>
<li><p>利用<strong>小表去驱动大表</strong></p>
</li>
<li><p>应尽量避免在 <strong>where 子句中使用!=或&lt;&gt;操作符</strong>，否则将引擎放弃使用索引而进行全表扫描</p>
</li>
<li><p><strong>不建议使用%前缀模糊查询</strong>，例如LIKE“%name”或者LIKE“%name%”，这种查询会导致索引失效而进行全表扫描，  若要提高效率，可以考虑全文检索</p>
</li>
<li><p><strong>使用合理的分页方式</strong>以提高分页的效率</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> product limit <span class="number">866613</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>优化的方法如下：可以取前一页的最大行数的id，然后根据这个最大的id来限制下一页的起点。比如此列中，上一页最大的id是866612。SQL可以采用如下的写法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> product <span class="keyword">where</span> id<span class="operator">&gt;</span> <span class="number">866612</span> limit <span class="number">20</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>禁止使用 order by rand() 进行随机排序</strong>，order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，<strong>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</strong></p>
</li>
<li><p>必要时可以<strong>使用force index来强制查询走某个索引</strong>，系统是有可能走全表扫描而不走索引的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t force index(a) <span class="keyword">where</span> c <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">and</span> c <span class="operator">&lt;</span> <span class="number">100000</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用连接(JOIN)来代替子查询</strong></p>
</li>
<li><p>**不要用字符串存储日期:**字符串占用的空间更大！字符串存储的日期比较效率比较低（逐个字符进行比对）</p>
</li>
</ul>
<h4 id="Datetime-和-Timestamp-之间抉择"><a href="#Datetime-和-Timestamp-之间抉择" class="headerlink" title="Datetime 和 Timestamp 之间抉择"></a><strong>Datetime 和 Timestamp</strong> 之间抉择</h4><p>通常我们都会<strong>首选 Timestamp</strong></p>
<ul>
<li><strong>DateTime 类型是没有时区信息的（时区无关）</strong>：DateTime 类型保存的时间都是<strong>当前会话所设置的时区对应的时间</strong></li>
<li><strong>Timestamp 和时区有关</strong>：Timestamp 类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是在不同时区，查询到同一个条记录此字段的值会不一样。</li>
<li>Timestamp 只需要使用<strong>4 个字节</strong>的存储空间， DateTime 需要耗费 <strong>8 个字节</strong>的存储空间，所以<strong>Timestamp 表示的时间范围更小</strong></li>
<li><strong>时间戳：数据的可读性太差</strong></li>
</ul>
<p><img src="/2022/07/19/MySQL%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/clipboard5.png"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-分布式定时器解决方案"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/19/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E5%99%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"
    >分布式定时器解决方案</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/19/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E5%99%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="article-date">
  <time datetime="2022-07-19T07:29:51.000Z" itemprop="datePublished">2022-07-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a> / <a class="article-category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%9A%E6%97%B6%E5%99%A8/">定时器</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="背景问题"><a href="#背景问题" class="headerlink" title="背景问题"></a>背景问题</h4><p>项目同时部署在多台集群机器上，因此到达指定的定时时间时，<strong>多台机器上的定时器可能会同时启动，造成重复数据或者程序异常等问题</strong></p>
<h4 id="一般的解决方案"><a href="#一般的解决方案" class="headerlink" title="一般的解决方案"></a>一般的解决方案</h4><h5 id="固定执行定时任务的机器"><a href="#固定执行定时任务的机器" class="headerlink" title="固定执行定时任务的机器"></a><strong>固定执行定时任务的机器</strong></h5><p>在多台机器中选择一台执行定时任务，<strong>每次执行的时候回判断当前机器和指定的机器是否一致</strong>或者启动时就指定好执行机器</p>
<p>优缺点：这种方法是可以有效避免多次执行的情况，，但是最明显的缺点就是<strong>单点故障问题</strong>，如果你指定的机器出现了宕机，，任务就不会执行了，业务逻辑就会奔溃</p>
<h5 id="ShedLock"><a href="#ShedLock" class="headerlink" title="ShedLock"></a><strong>ShedLock</strong></h5><p><strong>通过对公用的数据库中的某个表进行记录和加锁，使得同一时间点只有第一个执行定时任务并成功在数据库表中写入相应记录的节点能够成功执行而其他节点直接跳过该任务。</strong></p>
<p><strong>ShedLock</strong>：分布式环境中使用的定时任务框架，用于解决在分布式环境中的多个实例的相同定时任务在同一时间点重复执行的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;net.javacrumbs.shedlock&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;shedlock-spring&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">0.18</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"><span class="keyword">import</span> net.javacrumbs.shedlock.core.SchedulerLock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0/10 0 * * ?&quot;)</span></span><br><span class="line"><span class="meta">@SchedulerLock(name = &quot;scheduledTaskName&quot;, lockAtMostFor = 60 * 1000, lockAtLeastFor = 60 * 1000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduledTask</span><span class="params">()</span> &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;scheduledTask&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shedlockd的优点：<strong>通过注解的方式</strong>，把所有的一切都交给框架处理，使得<strong>代码不会受到影响</strong>，更加符合<strong>非侵入式</strong>编程的思想，使得代码更加简洁明了。</p>
<p>详细参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/RenshenLi/article/details/121643790">https://blog.csdn.net/RenshenLi/article/details/121643790</a></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> shedlock (</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8mb4_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  lock_until <span class="type">timestamp</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  locked_at <span class="type">timestamp</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>(<span class="number">3</span>),</span><br><span class="line">  locked_by <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (name)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_bin;</span><br></pre></td></tr></table></figure>

<p>尝试向shedlock表插入一条记录，而name作为主键，如果不存在相同名称的锁，则插入记录，并成功占用该锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shedlock(name, lock_until, locked_at, locked_by) </span><br><span class="line"><span class="keyword">VALUES</span>(:name, :lockUntil, :now, :lockedBy)</span><br></pre></td></tr></table></figure>

<p>如果已经存在同名的锁，则将违反主键唯一约束，插入失败，此时会尝试筛选出shedlock表中锁名称相同并且已经释放（lock_until&lt;当前时间）的记录，如果有符合条件的，则更新该记录，并成功占用该锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> shedlock <span class="keyword">SET</span> lock_until <span class="operator">=</span> :lockUntil, locked_at <span class="operator">=</span> :now, </span><br><span class="line">locked_by <span class="operator">=</span> :lockedBy <span class="keyword">WHERE</span> name <span class="operator">=</span> :name <span class="keyword">AND</span> lock_until <span class="operator">&lt;=</span> :now</span><br></pre></td></tr></table></figure>

<p>释放锁lock.get().unlock()</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> shedlock <span class="keyword">SET</span> lock_until <span class="operator">=</span> :unlockTime <span class="keyword">WHERE</span> name <span class="operator">=</span> :name</span><br></pre></td></tr></table></figure>

<h5 id="Redis-过期时间和分布式锁"><a href="#Redis-过期时间和分布式锁" class="headerlink" title="Redis 过期时间和分布式锁"></a>Redis 过期时间和分布式锁</h5><h6 id="setnx"><a href="#setnx" class="headerlink" title="setnx"></a>setnx</h6><p>为你的定时器在<strong>Redis中定义一个键值对，可以用项目名称和服务器ip</strong>，<strong>执行任务前先从Redis中读取键，若没有值代表任务未被执行，同样的该台机器先更新redis，再触发定时任务。由于Redis存在过期机制，因此可以设置过期时间保证下次判断正常</strong></p>
<p>优缺点：该方法个人比较推荐，简单，对业务逻辑的改变也会少很多，只需要在原来的定时器上加上简单判断即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoInsertVuserToGroupBuying</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 */10 * * * ?&quot;)</span>  <span class="comment">//定时器10分钟一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先判断redis中是否有锁记录,如果能设值成功,代表拿到锁，不能设值成功就是锁还没释放</span></span><br><span class="line">        <span class="keyword">if</span>(redisTemplate.opsForValue().setIfAbsent(key, value))&#123;</span><br><span class="line">            <span class="comment">//设值成功后,设置锁超时时间 (我这里是9分钟)</span></span><br><span class="line">            redisTemplate.expire(key, <span class="number">9</span>, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            dojob();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="ZSet-实现方式"><a href="#ZSet-实现方式" class="headerlink" title="ZSet 实现方式"></a><strong>ZSet 实现方式</strong></h6><p>将<strong>定时任务存放到 ZSet 集合</strong>中，并且<strong>将过期时间存储到 ZSet 的 Score 字段中</strong>，然后通过一个无线循环来判断当前时间内是否有需要执行的定时任务，如果有则进行执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrange zs1 <span class="number">0</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h6 id="键空间通知"><a href="#键空间通知" class="headerlink" title="键空间通知"></a><strong>键空间通知</strong></h6><p>给所有的定时任务设置一个过期时间，等到了过期之后，我们<strong>通过订阅过期消息就能感知到定时任务需要被执行了</strong>，此时我们执行定时任务即可。</p>
<p>默认情况下 Redis 是不开启<strong>键空间通知</strong>的，需要我们通过 <strong>config set notify-keyspace-events Ex 的命令手动开启</strong>，开启之后定时任务的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPubSub;</span><br><span class="line"><span class="keyword">import</span> utils.JedisUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">_TOPIC</span> <span class="operator">=</span> <span class="string">&quot;__keyevent@0__:expired&quot;</span>; <span class="comment">// 订阅频道名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">// 执行定时任务</span></span><br><span class="line">        doTask(jedis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅过期消息，执行定时任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doTask</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">        <span class="comment">// 订阅过期消息</span></span><br><span class="line">        jedis.psubscribe(<span class="keyword">new</span> <span class="title class_">JedisPubSub</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPMessage</span><span class="params">(String pattern, String channel, String message)</span> &#123;</span><br><span class="line">                <span class="comment">// 接收到消息，执行定时任务</span></span><br><span class="line">                System.out.println(<span class="string">&quot;收到消息：&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, _TOPIC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="分布式任务的开源框架"><a href="#分布式任务的开源框架" class="headerlink" title="分布式任务的开源框架"></a><strong>分布式任务的开源框架</strong></h5><p><strong>Quartz</strong></p>
<p>方法：如果你的项目使用的是Spring自带有Task定时任务机制，quartz框架本身就是支持集群环境，可以搭建集群环境下的定时器，也能解决上述问题 不过需要配置11张数据库表</p>
<p>优缺点：该解决方案最大的问题是需要配置11张左右的数据库表，工作量非常大</p>
<p><strong>Elastic-job、XXL-JOB</strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/" rel="tag">定时器</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java定时器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/19/Java%E5%AE%9A%E6%97%B6%E5%99%A8/"
    >Java定时器</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/19/Java%E5%AE%9A%E6%97%B6%E5%99%A8/" class="article-date">
  <time datetime="2022-07-19T05:17:41.000Z" itemprop="datePublished">2022-07-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a> / <a class="article-category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%9A%E6%97%B6%E5%99%A8/">定时器</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="Java定时器任务"><a href="#Java定时器任务" class="headerlink" title="Java定时器任务"></a>Java定时器任务</h4><h5 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a><strong>Timer</strong></h5><p><strong>JDK 自带的定时任务执行类</strong>，无论任何项目都可以直接使用 Timer 来实现定时任务，所以 Timer 的优点就是使用方便</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTimerTask</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义一个任务</span></span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">timerTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Run timerTask：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 计时器</span></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="comment">// 添加执行任务（延迟 1s 执行，每 3s 执行一次）</span></span><br><span class="line">        timer.schedule(timerTask, <span class="number">1000</span>, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点分析</p>
<p><strong>①任务执行时间长影响其他任务</strong></p>
<p>当一个任务的执行时间过长时，会影响其他任务的调度，如下代码所示：</p>
<p>当任务 1 运行时间超过设定的间隔时间时，任务 2 也会延迟执行。 原本任务 1 和任务 2 的执行时间间隔都是 3s，但因为任务 1 执行了 5s，因此任务 2 的执行时间间隔也变成了 10s（和原定时间不符）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTimerTask</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义任务 1</span></span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">timerTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;进入 timerTask 1：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 休眠 5 秒</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Run timerTask 1：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 定义任务 2</span></span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">timerTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Run timerTask 2：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 计时器</span></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="comment">// 添加执行任务（延迟 1s 执行，每 3s 执行一次）</span></span><br><span class="line">        timer.schedule(timerTask, <span class="number">1000</span>, <span class="number">3000</span>);</span><br><span class="line">        timer.schedule(timerTask2, <span class="number">1000</span>, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">进入 timerTask <span class="number">1</span>：Mon Aug <span class="number">17</span> <span class="number">21</span>:<span class="number">44</span>:08 CST <span class="number">2020</span></span><br><span class="line">Run timerTask <span class="number">1</span>：Mon Aug <span class="number">17</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">13</span> CST <span class="number">2020</span>  Run timerTask <span class="number">2</span>：Mon Aug <span class="number">17</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">13</span> CST <span class="number">2020</span></span><br><span class="line">进入 timerTask <span class="number">1</span>：Mon Aug <span class="number">17</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">13</span> CST <span class="number">2020</span></span><br><span class="line">Run timerTask <span class="number">1</span>：Mon Aug <span class="number">17</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">18</span> CST <span class="number">2020</span></span><br><span class="line">进入 timerTask <span class="number">1</span>：Mon Aug <span class="number">17</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">18</span> CST <span class="number">2020</span></span><br><span class="line">Run timerTask <span class="number">1</span>：Mon Aug <span class="number">17</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">23</span> CST <span class="number">2020</span>  Run timerTask <span class="number">2</span>：Mon Aug <span class="number">17</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">23</span> CST <span class="number">2020</span></span><br><span class="line">进入 timerTask <span class="number">1</span>：Mon Aug <span class="number">17</span> <span class="number">21</span>:<span class="number">44</span>:<span class="number">23</span> CST <span class="number">2020</span></span><br></pre></td></tr></table></figure>

<p><strong>②任务异常影响其他任务</strong></p>
<p>使用 Timer 类实现定时任务时，当一个任务抛出异常，其他任务也会终止运行，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTimerTask</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义任务 1</span></span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">timerTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;进入 timerTask 1：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                <span class="comment">// 模拟异常</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">8</span> / <span class="number">0</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;Run timerTask 1：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 定义任务 2</span></span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">timerTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Run timerTask 2：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 计时器</span></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="comment">// 添加执行任务（延迟 1s 执行，每 3s 执行一次）</span></span><br><span class="line">        timer.schedule(timerTask, <span class="number">1000</span>, <span class="number">3000</span>);</span><br><span class="line">        timer.schedule(timerTask2, <span class="number">1000</span>, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Timer 小结</p>
<p><strong>Timer 类实现定时任务的优点是方便，因为它是 JDK 自定的定时任务，但缺点是任务如果执行时间太长或者是任务执行异常，会影响其他任务调度</strong>，所以在生产环境下建议谨慎使用</p>
<h5 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a><strong>ScheduledExecutorService</strong></h5><p><strong>ScheduledExecutorService 也是 JDK 1.5 自带的 API</strong>，我们可以使用它来实现定时任务的功能，也就是说 ScheduledExecutorService <strong>可以实现 Timer 类具备的所有功能，并且它可以解决了 Timer 类存在的所有问题。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyScheduledExecutorService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建任务队列</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span></span><br><span class="line">                Executors.newScheduledThreadPool(<span class="number">10</span>); <span class="comment">// 10 为线程数量</span></span><br><span class="line">  		<span class="comment">// 执行任务</span></span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Run Schedule：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS); <span class="comment">// 1s 后开始执行，每 3s 执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ScheduledExecutorService 小结</p>
<p><strong>在单机生产环境下建议使用 ScheduledExecutorService 来执行定时任务</strong>，它是 JDK 1.5 之后自带的 API，因此使用起来也比较方便，并且使用 ScheduledExecutorService 来执行任务，不会造成任务间的相互影响。</p>
<h5 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring Task"></a><strong>Spring Task</strong></h5><p>如果使用的是 <strong>Spring 或 Spring Boot 框架</strong>，可以直接使用 Spring Framework 自带的定时任务，使用上面两种定时任务的实现方式，很难实现设定了<strong>具体时间的定时任务</strong>，比如当我们需要每周五来执行某项任务时，但如果使用 Spring Task 就可轻松的实现此需求。</p>
<p>以 Spring Boot 为例，实现定时任务只需两步：</p>
<ul>
<li>开启定时任务</li>
<li>添加定时任务</li>
</ul>
<p>① 开启定时任务</p>
<p>开启定时任务只需要在 Spring Boot 的启动类上声明 <strong>@EnableScheduling</strong> 即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 开启定时任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">    <span class="comment">// do someing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② 添加定时任务</p>
<p>定时任务的添加只需要使用 <strong>@Scheduled 注解标注</strong>即可，如果有多个定时任务可以创建多个 @Scheduled 注解标注的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 把此类托管给 Spring，不能省略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskUtils</span> &#123;</span><br><span class="line">    <span class="comment">// 添加定时任务</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;59 59 23 0 0 5&quot;)</span> <span class="comment">// cron 表达式，每周五 23:59:59 执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTask</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是定时任务~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Task 的实现需要使用 cron 表达式来声明执行的频率和规则</p>
<p><img src="/2022/07/19/Java%E5%AE%9A%E6%97%B6%E5%99%A8/42E5476AD7944654AD48B290D4FE0629.jpg"></p>
<ul>
<li><p>缺点：<strong>jvm启动之后会记录系统时间，然后jvm根据CPU ticks自己来算时间</strong>，此时<strong>获取的是定时任务的基准时间</strong>。如果此时将<strong>系统时间进行了修改</strong>，当Spring将之前获取的基准时间与当下获取的系统时间进行比对时，就会造成<strong>Spring内部定时任务失效</strong>。因为此时系统时间发生变化了，不会触发定时任务。</p>
</li>
<li><p>方案：为了避免使用@Scheduled注解，在修改服务器时间导致定时任务不执行情况的发生。在项目中需要使用定时任务场景的情况下，使<strong>ScheduledThreadPoolExecutor进行替代</strong>，它任务的调度是<strong>基于相对时间的</strong>，原因是它在任务的内部 存储了该任务距离下次调度还需要的时间（使用的是基于 System.nanoTime实现的相对时间 ，不会因为系统时间改变而改变，如距离下次执行还有10秒，不会因为将系统时间调前6秒而变成4秒后执行）</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/" rel="tag">定时器</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-redisson获取锁失败"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/17/redisson%E8%8E%B7%E5%8F%96%E9%94%81%E5%A4%B1%E8%B4%A5/"
    >redisson获取锁失败</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/17/redisson%E8%8E%B7%E5%8F%96%E9%94%81%E5%A4%B1%E8%B4%A5/" class="article-date">
  <time datetime="2022-07-17T08:31:06.000Z" itemprop="datePublished">2022-07-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/">Redis</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redisson/">Redisson</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h5 id="lock-lock-方法"><a href="#lock-lock-方法" class="headerlink" title="lock.lock()方法"></a>lock.lock()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// do sth.</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lock()源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lockInterruptibly();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">lockInterruptibly(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看lockInterruptibly方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">(<span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123; <span class="comment">// 获取成功</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 异步订阅redis chennel</span></span><br><span class="line">RFuture&lt;RedissonLockEntry&gt; future = subscribe(threadId);</span><br><span class="line">commandExecutor.syncSubscription(future); <span class="comment">// 阻塞获取订阅结果</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">// 循环判断知道获取锁</span></span><br><span class="line">        ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">        <span class="comment">// lock acquired</span></span><br><span class="line">        <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// waiting for message</span></span><br><span class="line">    <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    	getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	getEntry(threadId).getLatch().acquire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	unsubscribe(future, threadId);<span class="comment">// 取消订阅</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结lockInterruptibly：</p>
<p>获取锁，<strong>不成功则订阅释放锁的消息，获得消息前阻塞</strong>。</p>
<p><strong>得到释放通知后再去循环获取锁</strong>。</p>
<h5 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h5><p>tryLock()方法是有返回值的，它表示用来尝试获取锁<br>如果获取成功，则返回true<br><strong>如果获取失败（即锁已被其他线程获取），则返回false</strong><br>这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待</p>
<h5 id="tryLock-long-waitTime-long-leaseTime-TimeUnit-unit"><a href="#tryLock-long-waitTime-long-leaseTime-TimeUnit-unit" class="headerlink" title="tryLock(long waitTime, long leaseTime, TimeUnit unit)"></a>tryLock(long waitTime, long leaseTime, TimeUnit unit)</h5><p><strong>没获取到锁时，在指定的重试时间内，会尝试重新获取锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 尝试获取锁</span></span><br><span class="line"><span class="comment">* waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span></span><br><span class="line"><span class="comment">* leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> rLock.tryLock(waitTimeout, leaseTime, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>举例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String lockKey, <span class="type">long</span> lockWaitTime, <span class="type">long</span> lockTime)</span> &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个参数lockWaitTime是等待时间，n毫秒内获取不到锁，则直接返回</span></span><br><span class="line">        <span class="comment">// 第二个参数lockTime是锁超时时间，m毫秒后强制释放锁</span></span><br><span class="line">        <span class="keyword">return</span> lock.tryLock(lockWaitTime, lockTime, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;LOCK FAILED: key=%s||tryLockTime=%s||lockExpiredTime=%s&quot;</span>, lockKey, lockWaitTime, lockTime);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解锁:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String lockKey)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line">        <span class="keyword">if</span> (lock != <span class="literal">null</span>) &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;UNLOCK FAILED: key=%s&quot;</span>, lockKey);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行解锁代码后，有时会出现以下报错，这是什么原因呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread</span><br></pre></td></tr></table></figure>

<p>比如下面这段代码，在获取锁成功之后，持有的时间是8秒，而<strong>如果你的锁内业务执行时间超过8秒后，锁会自动释放，锁自动释放后，而在你的finally里面又手动去释放锁，就导致了这个错误</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取锁，持有8秒后，自动释放</span></span><br><span class="line">        tryLock(key, <span class="number">1000L</span>, <span class="number">8000L</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String lockKey)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line">        <span class="keyword">if</span> (lock != <span class="literal">null</span> &amp;&amp; lock.isHeldByCurrentThread()) &#123; </span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;UNLOCK FAILED: key=%s&quot;</span>, lockKey);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解锁时，<strong>增加lock.isHeldByCurrentThread()判断</strong>，意思是<strong>查询当前线程是否持有该锁</strong>，如果还持有，则释放，未持有，说明已释放</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redisson/" rel="tag">Redisson</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-IntelliJ-IDEA常用快捷键"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/15/IntelliJ-IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"
    >IntelliJ IDEA常用快捷键</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/15/IntelliJ-IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" class="article-date">
  <time datetime="2022-07-15T05:04:57.000Z" itemprop="datePublished">2022-07-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a> / <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/IDEA/">IDEA</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">双击Shift：查找所有</span><br><span class="line">Ctrl+Shift+R：全局搜索</span><br><span class="line">ALT+INSERT: 生成代码(如GET,SET方法,构造函数等)</span><br><span class="line">Ctrl + Shift + v: 自动补全对象返回类型</span><br><span class="line">Ctrl+I: 实现方法</span><br><span class="line">Ctrl+O: 重写方法    </span><br><span class="line">Ctrl + Alt + B：跳转到实现方法  </span><br><span class="line">Ctrl + G: 跳至指定行、列</span><br><span class="line">Ctrl + Shift + U：大小写转换</span><br><span class="line">    </span><br><span class="line">Alt + Enter：显示建议操作</span><br><span class="line">Ctrl + Alt + L：格式化代码</span><br><span class="line">Ctrl + P：参数信息提醒</span><br><span class="line">Alt + <span class="number">7</span>：显示结构窗口</span><br><span class="line">Ctrl + Alt + l: 自动对齐代码    </span><br><span class="line">Ctrl + Tab：切换活动文件</span><br><span class="line">Ctrl + E：最近的文件</span><br><span class="line">Ctrl + Shift + Backspace：返回上次编辑位置    </span><br><span class="line">Ctrl + Alt + Left：后退</span><br><span class="line">Ctrl + Alt + Right：前进</span><br><span class="line">    </span><br><span class="line">Ctrl + /：添加行注释</span><br><span class="line">Ctrl + Shift + /：添加块注释</span><br><span class="line"></span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Vue的生命周期"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/12/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"
    >Vue的生命周期</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/12/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="article-date">
  <time datetime="2022-07-12T11:45:44.000Z" itemprop="datePublished">2022-07-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/Vue/">Vue</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="Vue的优点"><a href="#Vue的优点" class="headerlink" title="Vue的优点"></a>Vue的优点</h4><ul>
<li><strong>轻量级框架</strong>：只<strong>关注视图层</strong></li>
<li><strong>双向数据绑定</strong>：保留了 angular 的特点，在数据操作方面更为简单</li>
<li><strong>组件化</strong>：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势</li>
<li><strong>虚拟DOM</strong>：dom 操作是非常耗费性能的， 不再使用原生的 dom 操作节点。而是预先通过JavaScript进行各种计算，把最终的DOM操作计算出来并优化。由于这个DOM操作属于预处理操作，并没有真实的操作DOM，所以叫做虚拟DOM。只有最后在计算完毕才真正将DOM操作提交，将DOM操作变化反映到DOM树上</li>
</ul>
<h4 id="对MVVM的理解？"><a href="#对MVVM的理解？" class="headerlink" title="对MVVM的理解？"></a>对MVVM的理解？</h4><p>MVVM 由 <strong>Model、View、ViewModel</strong> 三部分构成，<strong>Model 层代表数据模型</strong>，也可以在Model中定义数据修改和操作的业务逻辑；<strong>View 代表UI 组件</strong>，它负责将数据模型转化成UI 展现出来；<strong>ViewModel 是一个同步View 和 Model的对象</strong>。</p>
<p>在MVVM架构下，<strong>View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互</strong>，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p>
<p><strong>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的</strong>，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理</p>
<h4 id="Vue数据双向绑定原理"><a href="#Vue数据双向绑定原理" class="headerlink" title="Vue数据双向绑定原理"></a>Vue数据双向绑定原理</h4><p>实现mvvm的数据双向绑定，是采用<strong>数据劫持结合发布者-订阅者模式的方式</strong>，通过<strong>Object.defineProperty()来给各个属性添加setter，getter并劫持监听</strong>，在<strong>数据变动时发布消息给订阅者，触发相应的监听回调</strong>。就必须要实现以下几点：</p>
<ol>
<li>实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者</li>
<li>实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</li>
<li>实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</li>
</ol>
<p><img src="/2022/07/12/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/clipboard.png"></p>
<h4 id="生命周期简介"><a href="#生命周期简介" class="headerlink" title="生命周期简介"></a>生命周期简介</h4><p><strong>每个Vue实例在被创建时都要经过一系列的初始化过程</strong>，例如：需要设置<strong>数据的监听</strong>，编译模板，将<strong>实例挂载</strong>到DOM上，并且在<strong>数据变化时更新DOM</strong>等，这些过程统称为Vue实例的生命周期。</p>
<p>这个过程中也会运行一些叫做<strong>生命周期钩子的函数</strong>，这给了用户在不同阶段添加自己的代码的机会</p>
<p>Vue实例的生命周期，主要分为三个阶段，每个阶段都会执行不同的钩子函数</p>
<h5 id="挂载-初始化相关属性-例如watch属性，method属性"><a href="#挂载-初始化相关属性-例如watch属性，method属性" class="headerlink" title="挂载(初始化相关属性,例如watch属性，method属性)"></a><strong>挂载</strong>(初始化相关属性,例如watch属性，method属性)</h5><ul>
<li>beforeCreate</li>
<li>created</li>
<li>beforeMount</li>
<li>mounted</li>
</ul>
<h5 id="更新-元素或组件的变更操作"><a href="#更新-元素或组件的变更操作" class="headerlink" title="**更新(**元素或组件的变更操作)"></a>**更新(**元素或组件的变更操作)</h5><ul>
<li>beforeUpdate</li>
<li>updated</li>
</ul>
<h5 id="销毁（销毁相关属性）"><a href="#销毁（销毁相关属性）" class="headerlink" title="销毁（销毁相关属性）"></a><strong>销毁</strong>（销毁相关属性）</h5><ul>
<li>beforeDestroy</li>
<li>destroyed</li>
</ul>
<p><img src="/2022/07/12/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/clipboard2.png"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeCreate</span>( )<span class="comment">// 该钩子函数执行时，组件实例还未创建.</span></span><br><span class="line"><span class="title function_">created</span>()<span class="comment">//组件初始化完毕，各种数据可以使用，可以使用ajax发送异步请求获取数据</span></span><br><span class="line"><span class="title function_">beforeMounted</span>()<span class="comment">// 未执行渲染，更新，虚拟DOM完成，真实DOM未创建</span></span><br><span class="line"><span class="title function_">mounted</span>()<span class="comment">// 初始化阶段结束，真实DOM已经创建，可以发送异步请求获取数据,也可以访问dom元素</span></span><br><span class="line"><span class="title function_">beforeUpdate</span>()<span class="comment">//更新前，可用于获取更新前各种状态数据</span></span><br><span class="line"><span class="title function_">updated</span>()<span class="comment">//更新后执行该钩子函数，所有的状态数据是最新的。</span></span><br><span class="line"><span class="title function_">beforeDestroy</span>() <span class="comment">// 销毁前执行，可以用于一些定时器的清除。</span></span><br><span class="line"><span class="title function_">destroyed</span>()<span class="comment">//组件已经销毁，事件监听器被移除，所有的子实例也会被销毁。</span></span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <!--<ul>
      <li>
        Copyrights &copy;
        2019-2024
        <i class="ri-heart-fill heart_icon"></i> heliqing
      </li>
    </ul> -->
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <!--<ul>
      
    </ul> 
    <ul>
      
      <li>
          <img src="/images/beian.png"></img>
          <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=01234567890123" target="_black" rel="nofollow">浙公网安备01234567890123号</a>
      </li>
        
    </ul> -->
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src=''></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="迷途小书童"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>