<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 迷途小书童</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/" style="font-size:4rem">迷途小书童</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
        <img
          src="/images/ayer.svg"
          class="cover-logo"
          alt="迷途小书童"
        />
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['最值得欣赏的风景，是自己奋斗的足迹', '比别人多一点执着，你就会创造奇迹', '因为有悔，所以披星戴月；因为有梦，所以奋不顾身'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-适配器模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/04/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"
    >适配器模式</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/04/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2022-08-04T07:05:09.000Z" itemprop="datePublished">2022-08-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得<strong>原本由于接口不兼容而不能一起工作的那些类能一起工作</strong></p>
<p>例如，</p>
<p>1、<strong>讲中文的人同讲英文的人对话时需要一个翻译</strong></p>
<p>2、系统需要使用现有的类，而此类的接口不符合系统的需要</p>
<p>适配器模式（Adapter）包含以下主要角色。</p>
<p><strong>目标（Target）接口</strong>：当前系统业务所期待的接口，它可以是抽象类或接口。</p>
<p><strong>适配者（Adaptee）类</strong>：它是被访问和适配的现存组件库中的组件接口。</p>
<p><strong>适配器（Adapter）类</strong>：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</p>
<h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a><strong>类适配器</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainRun</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Target target=<span class="keyword">new</span> <span class="title class_">ClassAdapter</span>();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *功能描述 目标接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 将被适配的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;适配者中的业务代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 类适配器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassAdapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a><strong>对象适配器模式</strong></h4><p>对象适配器与类适配器不同之处在于，<strong>类适配器通过继承来完成适配</strong>，<strong>对象适配器则是通过关联</strong>来完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 对象适配器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainRun</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Adaptee adaptee=<span class="keyword">new</span> <span class="title class_">Adaptee</span>();</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObejectAdapter</span>(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 对象适配器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObejectAdapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObejectAdapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-单例模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"
    >单例模式</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2022-08-03T11:19:44.000Z" itemprop="datePublished">2022-08-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li><p><strong>保证一个类只有一个实例</strong>，并且提供一个访问该全局访问点</p>
</li>
<li><p>对于 Java 来说，<strong>单例模式可以保证在一个 JVM 中只存在单一实例</strong>。单例模式的应用场景主要有以下几个方面。</p>
</li>
<li><p><strong>需要频繁创建的一些类</strong>，使用单例可以<strong>降低系统的内存压力，减少 GC</strong>。</p>
</li>
<li><p>某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</p>
</li>
<li><p><strong>某些类创建实例时占用资源较多，或实例化耗时较长</strong>，且经常使用。</p>
</li>
<li><p><strong>某类需要频繁实例化，而创建的对象又频繁被销毁的时候</strong>，如<strong>多线程的线程池、网络连接池</strong>等。</p>
</li>
<li><p>频繁访问数据库或文件的对象。</p>
</li>
<li><p>对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。</p>
</li>
<li><p><strong>当对象需要被共享的场合</strong>。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等</p>
</li>
</ul>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>构造方法私有化，</li>
<li>获取方法公开化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// private私有 避免类在外部被实例化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="单例防止反射漏洞攻击"><a href="#单例防止反射漏洞攻击" class="headerlink" title="单例防止反射漏洞攻击"></a><strong>单例防止反射漏洞攻击</strong></h5>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123; </span><br><span class="line">         flag = !flag; </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;单例模式被侵犯！&quot;</span>); </span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>​                </p>
<h5 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a><strong>懒汉式单例</strong></h5><p><strong>类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能</strong></p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 懒汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="comment">// 保证 instance 在所有线程中同步 防止指令重排序</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton();</span></span><br><span class="line"><span class="comment">     * 这段代码其实是分为三步执行：</span></span><br><span class="line"><span class="comment">     * 1. 为 uniqueInstance 分配内存空间</span></span><br><span class="line"><span class="comment">     * 2. 初始化 uniqueInstance</span></span><br><span class="line"><span class="comment">     * 3. 将 uniqueInstance 指向分配的内存地址</span></span><br><span class="line"><span class="comment">     * 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。、</span></span><br><span class="line"><span class="comment">        指令重排在单线程环境下不会出现问题，</span></span><br><span class="line"><span class="comment">     * 但是在多线程环境下会导致一个线程获得还没有初始化的实例。</span></span><br><span class="line"><span class="comment">       例如，线程 T1 执行了 1 和 3，此时 T2 调用</span></span><br><span class="line"><span class="comment">     * getUniqueInstance() 后发现 uniqueInstance 不为空，</span></span><br><span class="line"><span class="comment">       因此返回 uniqueInstance，但此时</span></span><br><span class="line"><span class="comment">     * uniqueInstance 还未被初始化。</span></span><br><span class="line"><span class="comment">     * 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// private私有 避免类在外部被实例化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                      </p>
<h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a><strong>饿汉式</strong></h5><p><strong>类加载阶段完成实例的初始化</strong>   类加载机制保证线程安全</p>
<p>类初始化时,会立即加载该对象，线程天生安全,调用效率高</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungrySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton instance=<span class="keyword">new</span> <span class="title class_">HungrySingleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungrySingleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                       </p>
<h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a><strong>静态内部类</strong></h5><p><strong>类加载机制保证线程安全</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 静态内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInnerSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StaticInnerSingleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">StaticInnerSingleton</span> <span class="variable">staticInnerSingleton</span></span><br><span class="line">            <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StaticInnerSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StaticInnerSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.staticInnerSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​         </p>
<h5 id="枚举单例式"><a href="#枚举单例式" class="headerlink" title="枚举单例式"></a><strong>枚举单例式</strong></h5><p>使用枚举实现单例模式 优点:实现简单、调用效率高，<strong>枚举本身就是单例，由jvm从根本</strong></p>
<p><strong>上提供保障</strong>!<strong>避免通过反射和反序列化的漏洞， 缺点没有延迟加载</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 枚举单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumSingleton</span> &#123;</span><br><span class="line">    <span class="comment">//定义枚举</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">        INSTANCE;<span class="comment">// 枚举元素为单例</span></span><br><span class="line">        <span class="keyword">private</span> EnumSingleton enumSingleton;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Demo</span><span class="params">()</span>&#123;</span><br><span class="line">            enumSingleton=<span class="keyword">new</span> <span class="title class_">EnumSingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> EnumSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> enumSingleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Demo.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EnumSingleton</span> <span class="variable">s1</span> <span class="operator">=</span> EnumSingleton.getInstance();</span><br><span class="line">        <span class="type">EnumSingleton</span> <span class="variable">s2</span> <span class="operator">=</span> EnumSingleton.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="双重检测锁方式"><a href="#双重检测锁方式" class="headerlink" title="双重检测锁方式"></a><strong>双重检测锁方式</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检测锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleCheckLock</span> &#123;</span><br><span class="line">    <span class="comment">// volatile 防止指令重排序优化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckLock doubleCheckLock;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DoubleCheckLock</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此处检测doubleCheckLock == null,是为了防止当singletonMode已经初始化后，</span></span><br><span class="line"><span class="comment">     * 还会继续调用同步锁，造成不必要的损耗</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckLock <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="comment">// 加锁目的，防止多线程同时进入造成对象多次实例化</span></span><br><span class="line">        <span class="keyword">if</span>(doubleCheckLock == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 为了在null的情况下创建实例，防止不必要的损耗</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLock.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(doubleCheckLock == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DoubleCheckLock</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> doubleCheckLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-设计模式是什么"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88/"
    >设计模式是什么</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88/" class="article-date">
  <time datetime="2022-08-01T10:01:20.000Z" itemprop="datePublished">2022-08-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="设计模式是什么"><a href="#设计模式是什么" class="headerlink" title="设计模式是什么"></a>设计模式是什么</h4><p>​        代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。<strong>设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案</strong>。这些解决方案是众多软件开发人员经过相当长的一段时间的<strong>试验和错误总结出来的</strong>。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-TCP-UDP协议"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/27/TCP-UDP%E5%8D%8F%E8%AE%AE/"
    >TCP/UDP协议</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/27/TCP-UDP%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2022-07-27T02:07:57.000Z" itemprop="datePublished">2022-07-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> / <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-UDP/">TCP/UDP</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h4><ul>
<li><p><strong>TCP是面向连接的协议</strong>，发送数据前要先建立连接，<strong>TCP提供可靠的服务</strong>，也就是说，通过TCP连接<strong>传输的数据不会丢失</strong>，没有重复，并且按顺序到达；</p>
</li>
<li><p><strong>UDP是无连接的协议</strong>，发送数据前<strong>不需要建立连接</strong>，是<strong>没有可靠性</strong>；</p>
</li>
<li><p><strong>UDP传输速度快，TCP相对慢一些</strong></p>
</li>
<li><p>TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；</p>
</li>
<li><p>UDP通信类似于学校广播，靠着广播播报直接进行通信。</p>
</li>
<li><p>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</p>
</li>
<li><p><strong>TCP是面向字节流的</strong>，<strong>UDP是面向报文的</strong>； <strong>面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送</strong>，而<strong>UDP一个报文只能一次发完</strong>。</p>
</li>
<li><p>TCP首部开销（20字节）比UDP首部开销（8字节）要大</p>
</li>
<li><p>UDP 的主机不需要维持复杂的连接状态表</p>
</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>UDP应用场景：某些<strong>实时性要求比较高</strong>的情况，比如<strong>游戏，媒体通信，实时直播</strong>，即使出现传输错误 也可以容忍</p>
<p>TCP应用场景: <strong>HTTP</strong>都是用TCP，因为要求<strong>传输的内容可靠，不出现丢失</strong>的情况</p>
<p><strong>TCP协议</strong>：http(超文本传输协议)、https、FTP(文件传输协议)、POP3(邮局协议,收邮件)、SMTP(简单邮件传输协议,发邮件)</p>
<p><strong>UDP协议</strong>：DHCP(动态主机配置协议,动态主机配置协议)、NTP(网络时间协议,用于网络同步)</p>
<h4 id="用现实理解三次握手的具体细节"><a href="#用现实理解三次握手的具体细节" class="headerlink" title="用现实理解三次握手的具体细节"></a><strong>用现实理解三次握手的具体细节</strong></h4><p>三次握手的目的是建立可靠的通信信道，主要的目的就是<strong>双方确认自己与对方的发送与接收机能正常</strong></p>
<p><img src="/2022/07/27/TCP-UDP%E5%8D%8F%E8%AE%AE/B263ECD21A60439BA729B9B3311B7B27.jpg"></p>
<ul>
<li>第一次握手：客户什么都不能确认；服务器确认了对方发送正常</li>
<li>第二次握手：客户确认了：自己发送、接收正常，对方发送、接收正常；服务器确认 了：自己接收正常，对方发送正常</li>
<li>第三次握手：客户确认了：自己发送、接收正常，对方发送、接收正常；服务器确认 了：自己发送、接收正常，对方发送接收正常 所以三次握手就能确认双发收发功能都正常，缺一不可</li>
</ul>
<h5 id="建立连接可以两次握手吗？为什么"><a href="#建立连接可以两次握手吗？为什么" class="headerlink" title="建立连接可以两次握手吗？为什么?"></a><strong>建立连接可以两次握手吗？为什么?</strong></h5><p>因为可能会出现<strong>已失效的连接请求</strong>报文段又传到了服务器端</p>
<p>server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。<strong>假设不采用 “三次握手</strong>”，那么<strong>只要 server 发出确认，新的连接就建立了</strong>。由于现在 <strong>client 并没有发出建立连接的请求，因此不会理睬 server 的确认</strong>，也不会向 server 发送数据。但 <strong>server 却以为新的运输连接已经建立，并一直等待 client 发来数据</strong>。这样，server 的很多<strong>资源就白白浪费</strong>掉了</p>
<p>采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，<strong>client 不会向 server 的确认发出确认server 由于收不到确认，就知道 client 并没有要求建立连接</strong></p>
<h4 id="什么是TCP的四次挥手"><a href="#什么是TCP的四次挥手" class="headerlink" title="什么是TCP的四次挥手?"></a><strong>什么是TCP的四次挥手?</strong></h4><p>在网络数据传输中，传输层协议断开连接的过程我们称为四次挥手</p>
<p><img src="/2022/07/27/TCP-UDP%E5%8D%8F%E8%AE%AE/9E02A1D33F3D4A09AF4C04B25FD91F33.jpg"></p>
<p>TCP的四次挥手</p>
<p><strong>四次挥手断开连接</strong>是因为<strong>要确定数据全部传输完</strong>了</p>
<ul>
<li>客户与服务器交谈结束之后，客户要结束此次会话，就会对服务器说：我要关闭连接了（第一 次挥手）</li>
<li>服务器收到客户的消息后说：好的，你要关闭连接了。（第二次挥手）</li>
<li> 然后服务器确定了没有话要和客户说了，服务器就会对客户说，我要关闭连接了。(第三次挥 手)</li>
<li>客户收到服务器要结束连接的消息后说：已收到你要关闭连接的消息。(第四次挥手)，才关闭</li>
</ul>
<h5 id="CLOSE-WAIT状态意义是什么"><a href="#CLOSE-WAIT状态意义是什么" class="headerlink" title="CLOSE_WAIT状态意义是什么"></a><strong>CLOSE_WAIT状态意义是什么</strong></h5><p>为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（<strong>CLOSE_WAIT状态意义是什么</strong>）？</p>
<p>因为<strong>服务器收到客户端断开连接的请求时，可能还有一些数据没有发完</strong>，这时先回复ACK，表示接</p>
<p>收到了断开连接的请求。<strong>等到数据发完之后再发FIN</strong>，断开服务器到客户端的数据传送</p>
<h5 id="客户端TIME-WAIT状态的意义是什么？"><a href="#客户端TIME-WAIT状态的意义是什么？" class="headerlink" title="客户端TIME_WAIT状态的意义是什么？"></a><strong>客户端TIME_WAIT状态的意义是什么</strong>？</h5><p><strong>第四次挥手时，客户端发送给服务器的ACK有可能丢失</strong>，<strong>TIME_WAIT状态就是用来重发可能丢失的ACK报文</strong>。如</p>
<p>果Server没有收到ACK，就会<strong>重发FIN</strong>，如果<strong>Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待</strong></p>
<p><strong>2MSL</strong>，<strong>防止Server没有收到ACK而不断重发FIN</strong>。 MSL(MaximumSegment Lifetime)，指一个片段在网络中最</p>
<p>大的存活时间，<strong>2MSL就是一个发送和一个回复所需的最大时间</strong>。<strong>如果直到2MSL，Client都没有再次收到FIN，那</strong></p>
<p><strong>么Client推断ACK已经被成功接收，则结束TCP连接。</strong></p>
<h4 id="从输入址到获得页面的过程"><a href="#从输入址到获得页面的过程" class="headerlink" title="从输入址到获得页面的过程"></a><strong>从输入址到获得页面的过程</strong></h4><ul>
<li><p>浏览器查询 DNS，获取域名对应的IP地址</p>
</li>
<li><p>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求</p>
</li>
<li><p>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器</p>
</li>
<li><p>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源</p>
</li>
<li><p>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面</p>
</li>
</ul>
<h4 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a><strong>Http协议</strong></h4><p><strong>Http协议</strong>是对客户端和服务器端之间数据之间实现<strong>可靠性的传输文字、图片、音频、视频</strong>等超文本数据的规范，格式简称为“<strong>超文本传输协议</strong>”</p>
<h5 id="http和https的区别？"><a href="#http和https的区别？" class="headerlink" title="http和https的区别？"></a>http和https的区别？</h5><p>其实HTTPS就是从HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护</p>
<ul>
<li><strong>端口不一样，http是80，https443</strong></li>
<li>http是超文本传输协议，信息是<strong>明文传输</strong>，https则是具有安全性的<strong>ssl加密传输协议</strong>。</li>
</ul>
<h5 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h5><p><img src="/2022/07/27/TCP-UDP%E5%8D%8F%E8%AE%AE/A5310E2F789945829BB4F8552F135745.jpg"></p>
<h5 id="GET方法与POST方法的区别"><a href="#GET方法与POST方法的区别" class="headerlink" title="GET方法与POST方法的区别"></a>GET方法与POST方法的区别</h5><ul>
<li><p>get重点在从服务器上<strong>获取资源</strong>，post重点在向服务器<strong>发送数据</strong></p>
</li>
<li><p><strong>Get传输的数据量小</strong>，因为<strong>受URL长度限制</strong>，但效率较高； <strong>Post可以传输大量数据</strong>，所以上传文件时只能用Post方式</p>
</li>
<li><p><strong>get是不安全</strong>的，因为get请求<strong>发送数据是在URL上，是可见的</strong>，可能会泄露私密信息，如密码等； <strong>post是放在请求头部的，是安全的</strong></p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-UDP/" rel="tag">TCP/UDP</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-类加载机制"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"
    >类加载机制</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2022-07-27T01:46:37.000Z" itemprop="datePublished">2022-07-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="类加载的机制及过程"><a href="#类加载的机制及过程" class="headerlink" title="类加载的机制及过程"></a>类加载的机制及过程</h4><p>程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过<strong>加载、连接、初始化</strong>3个步骤来对该类进行初始化</p>
<p><img src="/2022/07/27/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/EE841B01A90E4862827B1F2ACBE90643.jpg"></p>
<h5 id="类装载的执行过程"><a href="#类装载的执行过程" class="headerlink" title="类装载的执行过程"></a>类装载的执行过程</h5><p>类装载分为以下 5 个步骤： </p>
<ul>
<li><strong>加载</strong>：根据查找路径找到相应的 <strong>class 文件然后读入到内存</strong>；</li>
<li><strong>验证</strong>：检查加载的 class 文件,确保<strong>加载的类信息符合JVM规范</strong>； </li>
<li><strong>准备</strong>：给类中的<strong>静态变量分配内存空间</strong>； 类变量（static变量）分配内存并设置类变量初始值的阶段</li>
<li><strong>解析</strong>：虚拟机将<strong>常量池中的符号引用替换成直接引用的过程</strong>。符号引用就理解为一个标示， 而在直接引用直接指向内存中的地址； </li>
<li><strong>初始化</strong>：<strong>对静态变量和静态代码块执行初始化工作</strong></li>
</ul>
<h5 id="类装载方式"><a href="#类装载方式" class="headerlink" title="类装载方式"></a><strong>类装载方式</strong></h5><ul>
<li><strong>隐式装载</strong>：程序在运行过程中当碰到<strong>通过new 等方式生成对象</strong>时，隐式调用类装载器加载对应的类到jvm中</li>
<li><strong>显式装载</strong>： 通过<strong>class.forname()等方法</strong>，显式加载需要的类</li>
</ul>
<h4 id="什么是类加载器？"><a href="#什么是类加载器？" class="headerlink" title="什么是类加载器？"></a>什么是类加载器？</h4><p><strong>类加载器就是把java类文件加载到虚拟机</strong>中，也就是说通过一个类的全限定名来获取描述该类的二进制字节流。Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。<strong>类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例</strong></p>
<h4 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h4><p>如果一个<strong>类加载器收到了类加载的请求</strong>，它首先<strong>不会自己去加载这个类</strong>，而是把这个请求<strong>委派给父类加载器</strong>去完成，每一层的类加载器都是如此，这样<strong>所有的加载请求都会被传送到顶层的启动类加载器</strong>中，只有当<strong>父加载无法完成加载请求</strong>（它的搜索范围中没找到所需的类）时，<strong>子加载器才会尝试去加载类</strong></p>
<h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ul>
<li>双亲委派模型保证了Java程序的稳定运行，可以<strong>避免类的重复加载</strong>（<strong>JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类</strong>）</li>
<li><strong>保证了 Java 的核心 API 不被篡改</strong>。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p><strong>父级加载器无法加载子级类加载器路径中的类</strong></p>
<p>有时候比较局限，<strong>有时候必须打破双亲委派机制</strong>，例如：<strong>SPI机制</strong></p>
<h4 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h4><ul>
<li><strong>启动类加载器(引导类加载器)（Bootstrap ClassLoader）</strong>，是虚拟机自身的一部分，用来加载<strong>Java_HOME/lib/目录</strong>中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库</li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong>：负责加载<strong>\lib\ext目录</strong>或Java. ext. dirs系统变量指定的路径中的所有类库</li>
<li><strong>应用程序类加载器(系统类加载器)（Application ClassLoader）</strong>：<strong>负责加载用户类路径（classpath）上的指定类库</strong>，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器</li>
<li><strong>用户自定义类加载器（程序员自己写的）：</strong>继承ClassLoader，继承ClassLoader</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java垃圾回收机制"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/25/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"
    >Java垃圾回收机制</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/25/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2022-07-25T06:20:35.000Z" itemprop="datePublished">2022-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>在java中，程序员是<strong>不需要显示的去释放一个对象的内存的</strong>，而是<strong>由虚拟机自行执行</strong>。在JVM中，<br>有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有<strong>在虚拟机空闲或者当前</strong><br><strong>堆内存不足时，才会触发执行</strong>，<strong>扫面那些没有被任何引用的对象</strong>，并将它们添加到要回收的集合<br>中，进行回收<br>程序员可以**手动执行System.gc()**，通知GC运行，但是Java语言规范并不保证GC一定会执行</p>
<h4 id="怎么判断对象是否可以被回收"><a href="#怎么判断对象是否可以被回收" class="headerlink" title="怎么判断对象是否可以被回收"></a>怎么判断对象是否可以被回收</h4><h5 id="引用计数器法"><a href="#引用计数器法" class="headerlink" title="引用计数器法"></a>引用计数器法</h5><p>为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数-1，当计数器为 0 时就可以被回收。它有一个<strong>缺点不能解决循环引用</strong>的问题。</p>
<p>循环引用的问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;-- 背景 --&gt;</span><br><span class="line"><span class="comment">// 对象objA 和 objB 都有字段 name</span></span><br><span class="line"><span class="comment">// 两个对象相互进行引用，除此之外这两个人对象没有任何引用</span></span><br><span class="line">objA.name = objB；</span><br><span class="line">objB.name = objA；</span><br><span class="line"></span><br><span class="line">&lt;-- 问题 --&gt;</span><br><span class="line"><span class="comment">// 实际上这两个对象已经不可能再被访问，应该要被垃圾收集器进行回收</span></span><br><span class="line"><span class="comment">// 但因为他们相互引用，所以导致计数器不为0，这导致引用计数算法无法通知垃圾收集器回收该两个对象</span></span><br></pre></td></tr></table></figure>

<h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a><strong>可达性分析算法</strong></h5><p>从 <strong>GC Roots 开始向下搜索，搜索所走过的路径称为引用链</strong>。<strong>当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的</strong>。（市场上用的非常非常广泛）</p>
<p>上面例子中两个循环引用的对象，虽然都存在一个强引用，但是不被任何GC root对象直接或者间接引用到</p>
<h4 id="什么是GC-Root对象"><a href="#什么是GC-Root对象" class="headerlink" title="什么是GC Root对象"></a><strong>什么是GC Root对象</strong></h4><h5 id="虚拟机栈中引用的对象"><a href="#虚拟机栈中引用的对象" class="headerlink" title="虚拟机栈中引用的对象"></a><strong>虚拟机栈中引用的对象</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rumenz</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	     <span class="type">Rumenz</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rumenz</span>();</span><br><span class="line">	     a = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">a是栈帧中的本地变量,a就是GC Root,</span><br><span class="line">由于a=<span class="literal">null</span>,a与<span class="keyword">new</span> <span class="title class_">Rumenz</span>()对象断开了链接,所以对象会被回收</span><br></pre></td></tr></table></figure>

<h5 id="方法区类的静态成员引用的对象"><a href="#方法区类的静态成员引用的对象" class="headerlink" title="方法区类的静态成员引用的对象"></a><strong>方法区类的静态成员引用的对象</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rumenz</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Rumenz=r;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       Rumenz a=<span class="keyword">new</span> <span class="title class_">Rumenz</span>();</span><br><span class="line">       a.r=<span class="keyword">new</span> <span class="title class_">Rumenz</span>();</span><br><span class="line">       a=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">栈帧中的本地变量a=<span class="literal">null</span>,由于a断开了与GC Root对象(a对象)的联系,所以a对象会被回收。</span><br><span class="line">由于给Rumenz的成员变量r赋值了变量的引用,</span><br><span class="line">并且r成员变量是静态的,所以r就是一个GC Root对象,所以r指向的对象不会被回收。</span><br></pre></td></tr></table></figure>

<h5 id="方法区常量引用的对象"><a href="#方法区常量引用的对象" class="headerlink" title="方法区常量引用的对象"></a><strong>方法区常量引用的对象</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rumenz</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Rumenz=r;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       Rumenz a=<span class="keyword">new</span> <span class="title class_">Rumenz</span>();</span><br><span class="line">       a.r=<span class="keyword">new</span> <span class="title class_">Rumenz</span>();</span><br><span class="line">       a=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">栈帧中的本地变量a=<span class="literal">null</span>,由于a断开了与GC Root对象(a对象)的联系,所以a对象会被回收。</span><br><span class="line">由于给Rumenz的成员变量r赋值了变量的引用,</span><br><span class="line">并且r成员变量是静态的,所以r就是一个GC Root对象,所以r指向的对象不会被回收。</span><br></pre></td></tr></table></figure>

<h5 id="方法区常量引用的对象-1"><a href="#方法区常量引用的对象-1" class="headerlink" title="方法区常量引用的对象"></a><strong>方法区常量引用的对象</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rumenz</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Rumenz r=<span class="keyword">new</span> <span class="title class_">Rumenz</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       Rumenz a=<span class="keyword">new</span> <span class="title class_">Rumenz</span>();</span><br><span class="line">       a=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">常量r引用的对象不会因为a引用的对象的回收而被回收</span><br></pre></td></tr></table></figure>

<h4 id="JVM-中都有哪些引用类型？"><a href="#JVM-中都有哪些引用类型？" class="headerlink" title="JVM 中都有哪些引用类型？"></a>JVM 中都有哪些引用类型？</h4><ul>
<li><strong>强引用</strong>：发生 gc 的时候不会被回收。比如new创建对象，反射获得一个对象等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>软引用</strong>：有用但不是必须的对象，在发生内存溢出之前会被回收。</li>
</ul>
<p> 通过SoftReference引用对象时，这个引用就是软引用。<strong>使用场景： 适用于网页缓存、图片缓存</strong>，防止内存溢出，在内存充足的时候，缓存对象会一直存在，在内存不足的时候，缓存对象占用的内存会被垃圾收集器回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>弱引用</strong>：有用但不是必须的对象，在下一次GC时会被回收。通过WeakReference引用对象，这种引用方式为弱引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;WeakReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>虚引用</strong>（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，必须和引用队列一起使用，虚引用的用途是在 gc 时返回一个通知</li>
</ul>
<p>使用PlantomReference引用对象时，这种引用方式就是虚引用,一般用来跟踪垃圾回收过程。使用虚引用的目的就是为了得知对象被GC的时机，所以可以利用虚引用来进行销毁前的一些操作，比如说资源释放等</p>
<h4 id="JVM-垃圾回收算法有哪些？"><a href="#JVM-垃圾回收算法有哪些？" class="headerlink" title="JVM 垃圾回收算法有哪些？"></a>JVM 垃圾回收算法有哪些？</h4><ul>
<li><strong>标记-清除</strong>算法：<strong>标记无用对象，然后进行清除回收</strong>。缺点：效率不高，无法清除垃圾碎片。</li>
<li><strong>复制</strong>算法：按照容量划分<strong>二个大小相等的内存区域</strong>，当一块用完的时候将<strong>活着的对象复制到另一块上</strong>，然后再把<strong>已使用的内存空间一次清理掉</strong>。缺点：内存使用率不高，只有原来的一半。</li>
<li><strong>标记-整理</strong>算法<strong>：标记无用对象</strong>，让所有<strong>存活的对象都向一端移动</strong>，然后直接<strong>清除掉端边界以外的内存</strong>。需要进行局部对象移动，一定程度上降低了效率</li>
<li><strong>分代算法</strong>：根据<strong>对象存活周期</strong>的不同将内存划分为几块，一般是<strong>新生代和老年代</strong>，新生代基本采用<strong>复制</strong>算法，老年代采用<strong>标记整理</strong>算法。</li>
</ul>
<h4 id="JVM-有哪些垃圾回收器"><a href="#JVM-有哪些垃圾回收器" class="headerlink" title="JVM 有哪些垃圾回收器"></a>JVM 有哪些垃圾回收器</h4><p><img src="/2022/07/25/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/19A0DA8B897D45D48C9F002444AC33AF.jpg"></p>
<ul>
<li><strong>Parallel Scavenge收集器</strong> (复制算法): 新生代并行收集器，<strong>追求高吞吐量</strong>，高效利用 CPU。<strong>吞吐量</strong></li>
</ul>
<p><strong>= 用户线程时间/(用户线程时间+GC线程时间)</strong></p>
<ul>
<li><strong>CMS</strong>(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收</li>
</ul>
<p>停顿时间为目标的收集器，具有高并发、低停顿的特点，<strong>追求最短GC回收停顿时间</strong></p>
<h4 id="分代垃圾回收器是怎么工作的？"><a href="#分代垃圾回收器是怎么工作的？" class="headerlink" title="分代垃圾回收器是怎么工作的？"></a>分代垃圾回收器是怎么工作的？</h4><ul>
<li>分代回收器有两个分区：老生代和新生代，<strong>新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</strong>参数 <strong>–XX:NewRatio</strong> 来指定</li>
<li>新生代使用的是<strong>复制算法</strong>，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 <strong>8:1:1</strong>，参数 <strong>-XX:SurvivorRatio</strong> 来指定，它的执行流程如下： </li>
<li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li>
<li>清空 Eden 和 From Survivor 分区；</li>
<li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变From Survivor。</li>
<li>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，<strong>当年龄到达 15（默认配置是 15，</strong>-XX:MaxTenuringThreshold<strong>）时，升级为老生代</strong>。大对象也会直接进入老生代。</li>
<li><strong>老生代当空间占用到达某个值之后就会触发全局垃圾收回</strong>，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</li>
</ul>
<h4 id="新生代、老年代、永久代的区别"><a href="#新生代、老年代、永久代的区别" class="headerlink" title="新生代、老年代、永久代的区别"></a>新生代、老年代、永久代的区别</h4><p><img src="/2022/07/25/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/C7DFF5C6F06648809B579D49754CAB08.jpg"></p>
<p>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。而新生代 ( Young )又被划分为三个区域：<strong>Eden、From Survivor、To Survivor</strong>。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。</p>
<p><strong>新生代</strong>中一般保存新出现的对象，所以<strong>每次垃圾收集时都发现大批对象死去</strong>，只有少量对象存活，便采用了 <strong>复制算法</strong> ，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p><strong>老年代</strong>中一般保存存活了很久的对象，他们<strong>存活率高</strong>、没有额外空间对它进行分配担保，就必须采用 <strong>“标记-清理”或者“标记-整理” 算法</strong>。</p>
<p><strong>永久代就是JVM的方法区</strong>。在这里都是放着一些<strong>被虚拟机加载的类信息，静态变量，常量</strong>等数据。这个区中的东西比老年代和新生代更不容易回收</p>
<h4 id="为什么新生代要分Eden和两个-Survivor-区域？"><a href="#为什么新生代要分Eden和两个-Survivor-区域？" class="headerlink" title="为什么新生代要分Eden和两个 Survivor 区域？"></a>为什么新生代要分Eden和两个 Survivor 区域？</h4><p><strong>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代</strong>。<strong>老年代很快被填满</strong>，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。</p>
<p>Survivor的存在意义，就是<strong>减少被送到老年代的对象</strong>，<strong>进而减少Full GC的发生</strong>，Survivor的预筛选保证，只有经历<strong>15次Minor GC还能在新生代中存活的对象，才会被送到老年代</strong>。</p>
<p><strong>设置两个Survivor区最大的好处就是解决了碎片化</strong>，<strong>刚刚新建的对象在Eden中，经历一次MinorGC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1</strong>（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象<strong>占用连续的内存空间</strong>，<strong>避免了碎片化的发生</strong>）</p>
<h4 id="Minor-GC、Major-GC、Full-GC区别及触发条件"><a href="#Minor-GC、Major-GC、Full-GC区别及触发条件" class="headerlink" title="Minor GC、Major GC、Full GC区别及触发条件"></a>Minor GC、Major GC、Full GC区别及触发条件</h4><h5 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h5><p>新生代GC，指的是<strong>发生在新生代的垃圾收集动作</strong>。由于java对象大都是朝生夕死的， 所以<strong>Minor GC非常频繁，一般回收速度也比较快</strong>。（一般采用<strong>复制算法回收垃圾</strong>） </p>
<p>Minor GC 触发条件一般为： </p>
<ol>
<li><strong>eden区满时，触发MinorGC</strong>。即申请一个对象时，发现eden区不够用，则触发一次 MinorGC。 </li>
<li>新创建的对象大小 &gt; Eden所剩空间时</li>
</ol>
<h5 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h5><p>老年代GC，指的是发生在<strong>老年代的GC</strong>，通常执行Major GC会连着Minor GC一起执 行。Major GC的速度要比Minor GC慢的多。（可采用<strong>标记清楚法和标记整理法</strong>）</p>
<h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>清理整个堆空间，包括年轻代和老年代</p>
<p>触发Minor GC Major GC和Full GC 触发条件一般为：<br><strong>Major GC通常是跟full GC是等价的</strong> </p>
<ol>
<li>每次<strong>晋升到老年代的对象平均大小&gt;老年代剩余空间</strong></li>
<li><strong>MinorGC后存活的对象超过了老年代剩余空间</strong></li>
<li>永久代空间不足 </li>
<li>执行<strong>System.gc()</strong> </li>
<li>CMS GC异常</li>
<li><strong>堆内存分配很大的对象</strong>（指需要大量连续内存空间的java对象）</li>
</ol>
<h4 id="常用的-JVM-调优的参数"><a href="#常用的-JVM-调优的参数" class="headerlink" title="常用的 JVM 调优的参数"></a><strong>常用的 JVM 调优的参数</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-Xms：初始堆大小，JVM 启动的时候，给定堆空间大小。</span><br><span class="line"></span><br><span class="line">-Xmx：最大堆大小，JVM 运行过程中，如果初始堆空间不足的时候，最大可以扩展到多少。</span><br><span class="line"></span><br><span class="line">-Xmn：设置堆中年轻代大小**。整个堆大小=年轻代大小+年老代大小+持久代大小。</span><br><span class="line"></span><br><span class="line">-XX:NewSize=n 设置年轻代初始化大小大小</span><br><span class="line"></span><br><span class="line">-XX:MaxNewSize=n 设置年轻代最大值</span><br><span class="line"></span><br><span class="line">-XX:NewRatio=n 设置年轻代和年老代的比值</span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio=n 年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。<span class="number">8</span></span><br><span class="line"></span><br><span class="line">表示两个Survivor :eden=<span class="number">2</span>:<span class="number">8</span> ,即一个Survivor占年轻代的<span class="number">1</span>/<span class="number">10</span>，默认就为<span class="number">8</span></span><br><span class="line"></span><br><span class="line">-Xss：设置每个线程的堆栈大小。JDK5后每个线程 Java 栈大小为 1M，以前每个线程堆栈大小为 256K。</span><br><span class="line"></span><br><span class="line">-XX:ThreadStackSize=n 线程堆栈大小</span><br><span class="line"></span><br><span class="line">-XX:PermSize=n 设置持久代初始值</span><br><span class="line"></span><br><span class="line">-XX:MaxPermSize=n 设置持久代大小</span><br><span class="line"></span><br><span class="line">-XX:MaxTenuringThreshold=n 设置年轻带垃圾对象最大年龄</span><br></pre></td></tr></table></figure>



<h4 id="JVM的GC收集器设置"><a href="#JVM的GC收集器设置" class="headerlink" title="JVM的GC收集器设置"></a>JVM的GC收集器设置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-xx:+Use xxx GC     xxx 代表垃圾收集器名称</span><br><span class="line"></span><br><span class="line">-XX:ParallelGCThreads=<span class="number">8</span>：表示JVM在进行并行GC的时候，用于GC的线程数。</span><br><span class="line"></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError：可以让JVM在出现内存溢出时候Dump出当前的内存转储快照</span><br><span class="line"></span><br><span class="line">-XX:HeapDumpPath：生成DUMP文件的路径，如不设置，默认存储在jvm 运行环境目录</span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDetails：打印GC详细信息</span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDateStamps：记录GC日志并不会特别地影响Java程序性能，推荐你尽可能记录日志</span><br><span class="line"></span><br><span class="line">-Xloggc：指定GC log的位置，以文件输出。帮助开发人员分析问题</span><br><span class="line"></span><br><span class="line">-XX:+DisableExplicitGC：这个将会忽略手动调用 GC 的代码使得 System.gc() 的调用就会变成一个空调用，完全不会触发任何 GC</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-JVM运行时数据区"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/25/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"
    >JVM运行时数据区</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/25/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/" class="article-date">
  <time datetime="2022-07-25T05:12:39.000Z" itemprop="datePublished">2022-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>VM(Java Virtual Machine/Java 虚拟机)在执行 Java 程序的过程中会把它所管理的<strong>内存划分为若干个不同的数据区域</strong>。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/94b7c2ab84ac">进程</a>的启动而一直存在，有的区域则是依赖用户线程的启动和结束而建立和销毁</p>
<p><img src="/2022/07/25/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/CA1BB924A33442FC9CFC3BC482E62ABB.jpg"></p>
<h4 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a><strong>运行时数据区</strong></h4><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h5><p>保存当前线程所正在执行的字节码指令的地址(行号)<strong>，为了</strong>线程切换后能恢复到正确的执行位置**，每条线程都有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储</p>
<p><strong>为什么要线程计数器？因为线程是不具备记忆功能</strong></p>
<h5 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a><strong>虚拟机栈</strong></h5><p><strong>线程私有</strong>的，它的<strong>生命周期和线程相同</strong></p>
<p>虚拟机栈描述的是Java方法执行的内存模型： 每个方法在执行的同时 都会创建一个<strong>栈帧</strong>（StackFrame）用于<strong>存储局部变量表、操作数栈、动态链接、方法出口</strong>等信息。</p>
<p>虚拟机栈中是有单位的，单位就是栈帧，<strong>一个方法一个栈帧</strong>。一个栈帧中他又要存储，局部变量，操作数栈，动态链接，出口等。</p>
<p><img src="/2022/07/25/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/0F361B626063436CA773F219E67AC2AC.jpg"></p>
<p>解析栈帧：</p>
<ul>
<li> <strong>局部变量表</strong>：是用来<strong>存储我们临时8个基本数据类型、对象引用地址、returnAddress类型</strong>。</li>
</ul>
<p>  （returnAddress中保存的是return后要执行的字节码的指令地址。）</p>
<ul>
<li> <strong>操作数栈</strong>：操作数栈就是用来操作的，例如代码中有个 i = 6*6，他在一开始的时候就会进行操</li>
</ul>
<p>  作，读取我们的代码，<strong>进行计算后再放入局部变量表</strong>中去</p>
<ul>
<li><p><strong>动态链接</strong>：假如我方法中，有个 service.add()方法，要链接到别的方法中去，这就是动态链接，</p>
<p>存储链接的地方。</p>
</li>
<li><p><strong>出口</strong>：出口是什呢，出口正常的话就是return 不正常的话就是抛出异常落</p>
</li>
</ul>
<h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a><strong>堆</strong></h5><p>被<strong>所有线程共享的一块内存区</strong>，<strong>存放对象实例</strong>，所有的对象实例以及数组都要在堆上分配</p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><strong>本地方法栈</strong></h5><p>栈很像，只不过方法上带了 <strong>native 关键字的栈字</strong>，且native关键字修饰的大部分源码都是C和C++的代码</p>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><strong>方法区</strong></h5><p>所有<strong>线程共享的内存区域</strong>，它用于存储已<strong>被Java虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据，别命叫Non-Heap（非堆）</p>
<h4 id="JVM运行流程"><a href="#JVM运行流程" class="headerlink" title="JVM运行流程"></a>JVM运行流程</h4><p><img src="/2022/07/25/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/D3E84FA2772A4286B75ED4870D0CFB1D.jpg"></p>
<p>JVM包含两个子系统和两个组件: 两个子系统为Class loader(类装载)、Execution engine(执行引擎)； 两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。</p>
<ul>
<li><p>Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。</p>
</li>
<li><p>Execution engine（执行引擎）：执行classes中的指令。</p>
</li>
<li><p>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</p>
</li>
<li><p>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</p>
</li>
</ul>
<p>流程 ：首先通过<strong>编译器把 Java 代码转换成字节码</strong>，<strong>类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内</strong>，而<strong>字节码文件</strong>只是 JVM 的一套指令集规范，<strong>并不能直接交给底层操作系统去执行</strong>，因此<strong>需要特定的命令解析器执行引擎</strong>（Execution Engine），<strong>将字节码翻译成底层系统指令，</strong>再交由 CPU 去执行，而这个过程中需要<strong>调用其他语言的本地库接口</strong>（Native Interface）来实现整个程序的功能。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Redis-value过大问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/22/Redis-value%E8%BF%87%E5%A4%A7%E9%97%AE%E9%A2%98/"
    >Redis value过大问题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/22/Redis-value%E8%BF%87%E5%A4%A7%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2022-07-22T05:11:54.000Z" itemprop="datePublished">2022-07-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/">Redis</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="多大的-key-算大？"><a href="#多大的-key-算大？" class="headerlink" title="多大的 key 算大？"></a><strong>多大的 key 算大？</strong></h4><p>阿里云Redis 最佳实践中提到 合理的 <strong>Key 中 Value 的字节大小，推荐小于10 KB</strong>。过大的 Value 会引发<strong>数据倾斜、热点Key、实例流量或 CPU 性能被占满</strong>等问题，应从设计源头上避免此类问题带来的性能影响。那么 value Bytes &gt;10kb 可以作为判断 大 key 的一个参考值</p>
<h4 id="怎么发现大-Key-？"><a href="#怎么发现大-Key-？" class="headerlink" title="怎么发现大 Key ？"></a><strong>怎么发现大 Key ？</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--bigkeys 命令</span><br></pre></td></tr></table></figure>

<p>–bigkeys 是 redis 自带的命令，<strong>对整个 Key 进行扫描</strong>，统计 string，list，set，zset，hash 这几个常见数据类型中每种类型里的 最大的 key。<strong>string 类型统计的是 value 的字节数</strong>；<strong>另外 4 种复杂结构的类型统计的是 元素个数，不能直观的看出 value 占用字节数</strong>，所以 –bigkeys 对分析 string 类型的大 key 是有用的，而复杂结构的类型还需要一些第三方工具。（ 元素个数少，不一定 value 不大；元素个数多，也不一定 value 就大）</p>
<p>root@vm1:~# redis-cli -h 127.0.0.1 -p 6379 -a “password” –bigkeys #　<strong>–bigkeys　是以 scan 延迟计算的方式扫描所有 key，因此执行过程中不会阻塞 redis，但实例存在 大量的 keys 时，命令执行的时间会很长</strong>，这种情况建议在 slave 上扫描。</p>
<p>–-bigkeys 统计能直观的看出 string 类型 value 的大小，非 string 类型通常有以下两种方式统计：</p>
<ul>
<li>Redis 4.0 以后的版本：支持 了 <strong>memory 命令查看 key 的大小</strong></li>
<li><strong>Rdbtools 工具包</strong>： Rdbtools 是 python写的 一个第三方开源工具，用来<strong>解析 Redis 快照文件</strong>。除了解析 rdb 文件，还提供了 <strong>统计单个 key 大小的工具</strong>。</li>
</ul>
<h4 id="如何优雅的删除-大-key-？"><a href="#如何优雅的删除-大-key-？" class="headerlink" title="如何优雅的删除 大 key ？"></a><strong>如何优雅的删除 大 key ？</strong></h4><h5 id="del-命令"><a href="#del-命令" class="headerlink" title="del 命令"></a>del 命令</h5><p>del 命令删除单个很大的 key 和 del 批量删除 大 key。</p>
<p><strong>直接 del 命令 粗暴的 删大 key 容易造成 redis 线程阻塞</strong>。<strong>4.0 以前要优雅的删除就是针对不同的类型 写脚本，拆分链表，hash 表，分批删除</strong>。</p>
<h5 id="UNLINK-命令"><a href="#UNLINK-命令" class="headerlink" title="UNLINK 命令"></a><strong>UNLINK</strong> 命令</h5><p><strong>4.0 版本以后</strong>官方对 删 大key 有了特别优化，<strong>支持了 lazy free 功能</strong>， 通常不需要开发脚本就可以删    </p>
<p><strong>UNLINK mykey</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; UNLINK mykey </span><br><span class="line">unlink 命令是  del 的异步版本，由 Lazyfree 机制实现。</span><br><span class="line">Lazyfree 机制的原理是在删除的时候只进行逻辑删除，</span><br><span class="line">把 key 释放操作放在 bio (Background I/O)单独的子线程中惰性处理，</span><br><span class="line">减少删除大 key 对 redis 主线程的阻塞，有效地避免因删除大key带来的性能问题。</span><br><span class="line">unlink 即使在批量删除 大 key 时，也不会对阻塞造成阻塞。</span><br></pre></td></tr></table></figure>



<h5 id="被动删除大-key"><a href="#被动删除大-key" class="headerlink" title="被动删除大 key"></a><strong>被动删除大 key</strong></h5><p>被动删除是指 Redis 自身的 key 清除策略</p>
<ul>
<li>Redis 内存不够时 key 的淘汰策略 ，即超过了 maxmemory 的配置</li>
<li>惰性删除：（建议开启惰性清除策略 ）</li>
<li>定时删除：( redis 默认策略 )</li>
</ul>
<h4 id="Redis的-bigkey-有哪些影响"><a href="#Redis的-bigkey-有哪些影响" class="headerlink" title="Redis的 bigkey 有哪些影响"></a><strong>Redis的 bigkey 有哪些影响</strong></h4><ul>
<li><strong>影响性能</strong></li>
</ul>
<p>因为 Redis <strong>单线程</strong>的工作机制，主线程处理所有key的增删改查。<strong>对bigkey的操作耗时增加将阻塞主线程处理其他业务请求，进而影响整体吞吐量</strong>。</p>
<ul>
<li><strong>影响带宽</strong></li>
</ul>
<p>前面的案例即是一个例子，单个key 7MB ，如果每秒100次查询，则带来700MB 的带宽，虽然现在大部分是万兆网卡<strong>，业务请求量再大一些，网卡也有被打满的风险</strong>。</p>
<ul>
<li><strong>数据倾斜</strong></li>
</ul>
<p><strong>对于分片的redis集群，存在bigkey 会导致单个分片数据量远大于其他节点，整体不均衡</strong>。<strong>如果一个分片空间容量满了，对系统造成不可访问</strong>，而且也不能随意扩容，因为不拆分key的情况下扩容，单个分片还是存在数据倾斜。更惨的是，<strong>数据量比较大，那么访问就增加，容易形成热点</strong>。热点不都是因为数据倾斜导致，数据倾斜会大概率导致热点。</p>
<ul>
<li><strong>影响主从同步</strong></li>
</ul>
<p>Redis Server 的输出大小通常是不可控制的。存在bigkey的时候，就会产生体积庞大的返回数据。另外也有可能因为执行了太多命令，导致产生返回数据的速率超过了往客户端发送的速率，导致服务器堆积大量消息，从而<strong>导致输出缓冲区越来越大，占用过多内存，甚至导致系统崩溃</strong>。Redis 通过设置client-output-buffer-limit 来保护系统安全。</p>
<h4 id="如何解决大key？"><a href="#如何解决大key？" class="headerlink" title="如何解决大key？"></a><strong>如何解决大key？</strong></h4><p>其实就是一个字 “拆”。</p>
<ul>
<li><p>对于字符串类型的key，我们通常要在业务层面将value的大小控制在10KB左右，如果value确实很大，可以考虑<strong>采用序列化算法和压缩算法来处理</strong>，推荐常用的几种序列化算法:Protostuff、Kryo或者Fst。</p>
</li>
<li><p>对于集合类型的key，我们通常要通过控制集合内元素数量来避免bigKey，通常的做法是将<strong>一个大的集合类型的key拆分成若干小集合类型的key来达到目的</strong>。</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-SpringMVC-Controller并发安全问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/21/SpringMVC-Controller%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"
    >SpringMVC Controller并发安全问题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/21/SpringMVC-Controller%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2022-07-21T06:09:01.000Z" itemprop="datePublished">2022-07-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a> / <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/SprigMVC/">SprigMVC</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h4><p>根据Tomcat官网中的介绍，<strong>对于一个浏览器请求，tomcat会指定一个处理线程</strong>，或是在线程池中选取空闲的，或者新建一个线程。</p>
<p>在Tomcat容器中，每个servlet是单例的。<strong>在SpringMVC中，Controller 默认也是单例</strong>。 采用单例模式的最大好处，就是可以<strong>在高并发场景下极大地节省内存资源，提高服务抗压能力</strong>。</p>
<p>单例模式容易出现的问题是：在Controller中定义的<strong>实例变量</strong>，在多个请求并发时会出现竞争访问，<strong>Controller中的实例变量不是线程安全的</strong>。</p>
<h4 id="Controller不是线程安全的"><a href="#Controller不是线程安全的" class="headerlink" title="Controller不是线程安全的"></a><strong>Controller不是线程安全的</strong></h4><p>正因为Controller默认是单例，所以不是线程安全的。如果用SpringMVC 的 Controller时，尽量不在 Controller中使用实例变量，否则会出现线程不安全性的情况，导致数据逻辑混乱。</p>
<p>举一个简单的例子，在一个Controller中定义一个非静态成员变量 num 。通过Controller成员方法来对 num 增加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/addNum&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(++num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">首先访问 http:<span class="comment">// localhost:8080 / addNum，得到的答案是1</span></span><br><span class="line">再次访问 http:<span class="comment">// localhost:8080 / addNum，得到的答案是 2。</span></span><br><span class="line">两次访问得到的结果不同，num已经被修改，并不是我们希望的结果，接口的幂等性被破坏。</span><br></pre></td></tr></table></figure>

<p>所有的请求访问同一个Controller实例，<strong>Controller的私有成员变量就是线程共用的</strong>。某个请求对应的线程如果修改了这个变量，那么在别的请求中也可以读到这个变量修改后的的值。</p>
<h4 id="Controller并发安全的解决办法"><a href="#Controller并发安全的解决办法" class="headerlink" title="Controller并发安全的解决办法"></a><strong>Controller并发安全的解决办法</strong></h4><ul>
<li><p>尽量不要在 Controller 中定义成员变量 ；</p>
</li>
<li><p>如果必须要定义一个非静态成员变量，那么可以通过注解 @Scope(“prototype”) ，将Controller设置为多例模式，容器在接受到该类型对象的请求时，每次都会重新生成一个新的对象给请求方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Scope(value=&quot;prototype&quot;)</span><span class="comment">// 多例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/addNum&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(++num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Controller 中使用 ThreadLocal 变量。 每一个线程都有一个变量的副本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal &lt;Integer&gt; uniqueNum =</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">ThreadLocal</span> &lt;Integer&gt; () &#123;</span><br><span class="line">                 <span class="meta">@Override</span> <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">                     <span class="keyword">return</span> num;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/addNum&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">unum</span> <span class="operator">=</span> uniqueNum.get();</span><br><span class="line">       uniqueNum.set(++unum);</span><br><span class="line">       System.out.println(uniqueNum.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">以上代码运行以后，每次请求 http:<span class="comment">// localhost:8080 / addNum , 得到的结果都是1。</span></span><br><span class="line">更严格的做法是用AtomicInteger类型定义成员变量，对于成员变量的操作使用AtomicInteger的自增方法完成。</span><br></pre></td></tr></table></figure>



</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SprigMVC/" rel="tag">SprigMVC</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-数据库范式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/"
    >数据库范式</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/" class="article-date">
  <time datetime="2022-07-21T05:00:01.000Z" itemprop="datePublished">2022-07-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">MySQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>范式是关系数据库理论的基础，也是我们在设计数据库结构过程中所要遵循的规则和指导方法</p>
<h4 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h4><p>数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保<strong>每一列的原子性   (值不可再分)</strong></p>
<h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><p>满足1NF后，要求表中的<strong>所有列，都必须依赖于主键</strong>，而不能有任何一列与主键没有关系，也就是说<strong>一个表只描述一件事情</strong>；(<strong>消除了部份依赖</strong>)</p>
<p>例如：订单表只描述订单相关的信息，所以所有字段都必须与订单id相关 产品表只描述产品相关的信息，所以所有字段都必须与产品id相 关；因此不能在一张表中同时出现订单信息与产品信息</p>
<h4 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h4><p>必须先满足第二范式（2NF），要求：表中的<strong>每一列只与主键直接相关而不是间接相关</strong>，（表中的每一列只能依赖于主键）；(<strong>消除了传递依赖</strong>)</p>
<p>订单表中需要有客户相关信息，在分离出客户表之后，订单表中只需要有一个用户id即可，而不能有其他的客户信息。因为其他的客户信息直接关联于用户id，而不是直接与订单id直接相关</p>
<h4 id="数据库五大约束"><a href="#数据库五大约束" class="headerlink" title="数据库五大约束"></a>数据库五大约束</h4><ul>
<li><strong>primary KEY</strong>:设置主键约束；</li>
<li><strong>UNIQUE</strong>：设置唯一性约束，不能有重复值；</li>
<li><strong>DEFAULT</strong> 默认值约束，height DOUBLE(3,2)DEFAULT 1.2 height不输入是默认为1,2</li>
<li><strong>NOT NULL</strong>：设置非空约束，该字段不能为空；</li>
<li><strong>FOREIGN key</strong> :设置外键约束</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <!--<ul>
      <li>
        Copyrights &copy;
        2019-2023
        <i class="ri-heart-fill heart_icon"></i> heliqing
      </li>
    </ul> -->
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <!--<ul>
      
    </ul> 
    <ul>
      
      <li>
          <img src="/images/beian.png"></img>
          <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=01234567890123" target="_black" rel="nofollow">浙公网安备01234567890123号</a>
      </li>
        
    </ul> -->
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src=''></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="迷途小书童"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>